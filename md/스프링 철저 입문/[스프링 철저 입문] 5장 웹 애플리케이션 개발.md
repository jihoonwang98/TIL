## 5.1 웹 애플리케이션의 종류

먼저 스프링 MVC를 이용해 작성할 수 있는 웹 애플리케이션의 전체 구조를 파악해 두자. 스프링 MVC는 다음과 같은 두 종류의 애플리케이션을 만들기 위한 기능을 제공한다.

- **화면으로 응답하는 애플리케이션**(이번 장에서 설명)
- **데이터로 응답하는 애플리케이션**



이 두 가지 애플리케이션은 하나의 애플리케이션으로 개발할 수도 있지만 필요에 따라 설정과 구현 방법을 분리할 수 있다. 이 책에서는 두 가지 유형을 별도로 각각 설명한다. 참고로 '데이터로 응답하는 웹 애플리케이션'의 개발 방법은 6장 'RESTful 웹 서비스 개발'에서 설명한다.





### 5.1.1 화면으로 응답하는 웹 애플리케이션

웹 브라우저를 사용자 인터페이스로 사용하는 애플리케이션은 **JSP**와 같은 템플릿 파일을 사용해 **동적 웹 페이지(HTML) 형태로 클라이언트에 응답**한다.





### 5.1.2 데이터로 응답하는 웹 애플리케이션

사용자 인터페이스와 데이터를 분리해서 취급하는 애플리케이션은 **JSON** 또는 **XML**을 사용해 **데이터 형태로 클라이언트에 응답**한다. **RESTful** 웹 서비스(**REST API**) 등이 이 유형으로 분류되며, **SPA(Single Page Application)** 혹은 **Rich Client** 애플리케이션이나 그 밖의 다양한 프런트 시스템의 웹 애플리케이션 등이 클라이언트가 된다.









## 5.2 애플리케이션 설정

이번 절에서는 본격적인 웹 애플리케이션을 개발할 때 필요한 설정에 대해 설명하겠다. 



### 5.2.1 서블릿 컨테이너 설정

스프링 MVC를 이용해 웹 애플리케이션을 할 때는 4장 4.2절 '첫 번째 스프링 MVC 애플리케이션'에서 소개한 **ContextLoaderListener, DispatcherServlet, CharacterEncodingFilter**를 서블릿 컨테이너에 등록해야 한다. 



> 서블릿 3.0.0 이후의 서블릿 컨테이너에서는 서블릿 컨테이너의 초기화를 자바 코드로 할 수 있다. 스프링 MVC에서는 서블릿 컨테이너의 초기화를 자바 코드로 하기 위한 지원 클래스로 **AbstractAnnotationConfigDispatcherServletInitializer**라는 추상 클래스를 제공한다.





### 5.2.2 ApplicationContext 설정

본격적인 웹 애플리케이션을 개발하려면 앞서 4.2절 '첫 번째 스프링 MVC 애플리케이션'에서 소개한 빈 정의에다 **MessageSource**와 **PropertySourcesPlaceholderConfigurer**의 빈 정의도 필요하다.



**MessageSource**는 메시지를 취득하기 위한 컴포넌트이고, **PropertySourcesPlaceholderConfigurer**는 프로퍼티 값(JVM 시스템 프로퍼티, 환경 변수, 프로퍼티 파일에 정의한 값)을 DI 컨테이너에서 관리하는 컴포넌트에 인젝션하기 위한 컴포넌트다. 이러한 컴포넌트에 관한 설명과 빈을 정의한 예는 2장 2.4절 '프로퍼티 관리'와 2.7절 '메시지 관리' 절을 참조하자.





### 5.2.3 Front Controller 설정

스프링 MVC **Front Controller**를 사용하려면 4.3절 '스프링 MVC 아키텍처'에서 소개한 다양한 컴포넌트 설정이 필요하다. 이 설정을 혼자서 하기에는 다소 어려울 수 있는데, 다행스럽게도 스프링 MVC가 이러한 설정을 간단히 할 수 있는 구조를 제공한다. 예를 들어, **자바 기반 설정 방식**을 사용하는 경우 설정 클래스에 **@EnableWebMvc**를 추가하면 되고, **XML** 파일을 사용하는 경우 `<mvc:annotation-driven>`  요소를 추가하기만 하면 스프링 개발팀에서 권장하는 설정이 자동으로 수행된다.







## 5.3 @Controller 구현

여기서는 요청 결과를 화면으로 표시하는 일반적인 웹 애플리케이션을 개발하는 방법을 설명하겠다.



일반적인 웹 애플리케이션을 개발할 때 만들어야 하는 주요 컴포넌트에는 **Controller** 클래스, **Form** 클래스, JSP와 같은 **템플릿 파일(뷰)**의 세 가지가 있다.



이번 절에서는 먼저 **Controller** 클래스의 구현 방법을 살펴보자.



### 5.3.1 Controller에서 구현하는 처리 내용

먼저 **Controller**에서 구현할 처리 내용이 무엇인지 확인하자. **Controller**에서 처리할 내용은 크게 다음의 두 가지로 분류할 수 있다.

- **선언형 처리**: 메서드 시그니처를 참조해서 **Front Controller**가 하는 일
- **프로그래밍형 처리**: **Controller** 클래스의 메서드 안에 하는 일



**Controller**가 하는 일을 조금 더 구체적으로 나눠 보면 다음과 같이 7가지 처리 내용으로 분류할 수 있다.

- **선언형 처리**
  - 요청 매핑
  - 요청 데이터 취득
  - 입력값 검사 수행
- **프로그래밍형 처리**
  - 입력값 검사 결과 확인
  - 비즈니스 로직 호출
  - 이동 대상 확인 및 데이터 연계
  - 이동 대상 지정



**선언형**으로 분류된 처리 내용은 **애너테이션**을 적절히 지정하거나 적절한 **메서드 매개변수**를 잘 선언해주면 프레임워크가 **Front Controller**에서 자동으로 처리해 줄 수 있다.

```java
@RequestMapping(path = "/messages", method = RequestMethod.GET) // 요청 매핑
public String search(@Valid MessageSearchForm form, BindingResult result) {
    // @Valid, BindingResult result -> 입력값 검사 수행
    // MessageSearchForm form -> 요청 데이터 취득
    ...
}
```





**프로그래밍형**으로 분류된 처리 내용은 프레임워크의 도움 없이 개발자가 **직접** 프로그래밍해야 한다.

```java
public String search(@Valid MessageSearchForm form, BindingResult result, Model model) {
    
    // 입력값 검사 결과 처리
    if(result.hasErrors()) {
        return "message/searchForm";
    }
    
    
    // 비즈니스 로직 호출
    List<Message> messages = service.search(form.getKeyword());
    
    
    // 이동 대상과 데이터 연계
    model.addAttribute("messages", messages);
    
    
    // 이동 대상 지정
    return "message/searchResult";
}
```





### 5.3.2 Controller 클래스 작성

**Controller** 클래스는 **POJO**로 작성한다.



- **Controller 클래스의 작성 예**

```java
package exmple.app;
// 생략
@Controller
public class WelcomeController {
    
}
// 클래스에 @org.springframework.stereotype.Controller를 지정한다.
```



**POJO** 클래스에 **@Controller**를 지정하면 다음과 같은 효과를 얻을 수 있다.

- **컴포넌트 스캔** 기능을 사용해 DI 컨테이너에 빈으로 등록할 수 있다.
- 요청을 처리하는 메서드(이후 **핸들러 메서드**로 표기)가 정의돼 있는 클래스로 인식된다.



**Controller**는 DI 컨테이너에 등록될 때 스프링이 정한 명명 규칙에 따라 빈의 이름이 정해진다. 이 예에서는 **welcomeController**라는 이름으로 등록되는데, 만약 이 이름을 바꾸고 싶다면 **@Controller**의 **value** 속성에 명시적으로 원하는 이름을 기재하면 된다.









#### DI 컨테이너 등록

**Controller** 클래스는 **컴포넌트 스캔** 기능을 사용해 DI 컨테이너에 등록하는 것이 일반적이다.



- **DispatcherServlet용 자바 기반 방식의 설정 예**

```java
@Configuration
@EnableWebMvc
@ComponentScan("example.app")
public class WebMvcConfig extends WebMvcConfigurerAdapter {
    // 생략
}
```





- **DispatcherServlet용 XML 기반 방식의 설정 예**

```xml
<context:component-scan base-package="example.app" />
```









### 5.3.3 Handler Method 작성

요청을 처리하는 **Handler Method**를 작성한다.



- **handler method 작성 예**

```java
package example.app;
// 생략
@Controller
public class WelcomeController {
    @RequestMapping("/")
    public String home(Model model){
        model.addAttribute("now", new Date());
        return "home"
    }
}

// 메서드에 @org.springframework.web.bind.annotation.RequestMapping을 지정한다.
// @RequestMapping을 지정한 메서드가 handler method로 인식된다.
```



**handler method**로 인식되면 **Front Controller**가 **@RequestMapping**에 지정된 매핑 정보를 읽고 요청에 대응하는 **handler method**를 자동으로 호출한다. 위의 구현 예에서는 '/'라는 경로에 요청이 보내지면 **home** 메서드가 호출된다.







### 5.3.4 **Handler Method의 매개변수**

**Handler Method**는 인수로 여러 객체를 받을 수 있다.



> 메서드의 매개변수로 받을 수 있는 객체는 **HandlerMethodArgumentResolver** 인터페이스(org.springframework.web.method.support.HandlerMethodArgumentResolver)의 구현 클래스를 만드는 방법으로 확장할 수 있다.







#### 지정 가능한 주요 타입

스프링 MVC가 기본적으로 지원하는 매개변수의 주요 타입은 다음과 같다.

| 타입                                    | 설명                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| **Model**                               | 이동 대상에 전달할 데이터를 가지고 있는 인터페이스           |
| **RedirectAttributes**                  | 리다이렉트 대상에 전달할 데이터를 가지고 있는 인터페이스     |
| **form 클래스 등의 자바빈즈**           | 요청 파라미터를 가지고 있는 자바빈즈 클래스                  |
| **BindingResult**                       | form 클래스의 입력값 검사 결과를 가지고 있는 인터페이스      |
| **MultipartFile**                       | 멀티파트 요청을 사용해 업로드된 파일 정보를 가지고 있는 인터페이스 |
| **HttpEntity<?>**                       | 요청 헤더와 응답 본문을 가지고 있는 인터페이스. 요청 본문은 **HttpMessageConverter**의 메커니즘을 사용해 임의의 타입으로 변환할 수 있다. |
| **java.util.Locale**                    | 클라이언트 Locale                                            |
| **java.util.TimeZone/java.time.ZoneId** | 클라이언트 시간대. ZoneId는 Java SE 8 이상에서 사용 가능.    |
| **java.security.Principal**             | 클라이언트 인증을 위한 사용자 정보를 가지고 있는 인터페이스  |
| **UriComponentBuilder**                 | URI를 조립하기 위한 인터페이스. Context 경로를 기본 URI로 가지고 있는 객체가 전달된다. |
| **SessionStatus**                       | **@SessionAttributes**를 사용해 세션 스코프에 저장한 객체의 라이프 사이클을 관리하는 인터페이스(실제로는 세션 값 설정과 설정 완료 여부만 확인) |





#### 지정 가능한 주요 애너테이션

인수에 애너테이션을 지정하면 **요청 데이터(경로 변수, 요청 파라미터, 요청 헤더, 요청 본문, 쿠키)를 임의의 타입으로 변환해서 가져올 수 있다**. 사용할 수 있는 주요 애너테이션은 다음과 같다.



**인수에 지정 가능한 애너테이션**

| Annotation          | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| **@PathVariable**   | URL에서 경로 변수 값을 가져오기 위한 애너테이션              |
| **@MatrixVariable** | URL에서 매트릭스 변수 값을 가져오기 위한 애너테이션(기본 설정에서는 사용할 수 없다) |
| **@RequestParam**   | 요청 파라미터 값을 가져오기 위한 애너테이션                  |
| **@RequestHeader**  | 요청 헤더 값을 가져오기 위한 애너테이션                      |
| **@RequestBody**    | 요청 본문 내용을 가져오기 위한 애너테이션. 요청 본문은 **HttpMessageConverter** 구조를 사용해 지정한 타입으로 변환된다. |
| **@CookieValue**    | 쿠키 값을 가져오기 위한 애너테이션                           |



그 밖에도 인수에 애너테이션을 지정하면 요청 데이터 이외의 정보도 인수로 받을 수 있다. 사용할 수 있는 주요 애너테이션은 다음과 같다.



**요청 데이터 이외의 정보를 인수로 지정할 수 있는 애너테이션**

| Annotation          | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| **@ModelAttribute** | 모델에 저장된 객체를 인수로 받을 수 있다. 인수가 자바빈즈 형태라면 생략할 수 있다. |
| @**Value**          | **'${...}'**와 같은 플레이스홀더로 대체된 값이나 **'#{...}'**과 같은 **SpEL** 식의 실행 결과를 인수로 받을 수 있다. |



> 스프링 4.3부터 새롭게 **@SessionAttribute**와 @**RequestAttribute**가 추가되어 **HttpSession**과 **HttpServletRequest**에 저장된 객체를 받을 수 있다.









#### 관례에 따른 묵시적인 인수 값 설정

위에서 안내한 방법 외에도 다음 규칙에 따라 요청 정보의 값을 인수의 값으로 채워 넣을 수 있다.

- 인수의 타입이 **String**이나 **Integer** 같은 간단한(?) 타입인 경우에는 인수의 이름과 일치하는 요청 파라미터에서 값을 가져올 수 있다.
- 인수의 타입이 **자바빈즈**인 경우는 자바빈즈의 기본 속성명과 일치하는 객체를 **Model**에서 가져올 수 있다. 만약 해당하는 객체가 **Model**에 없다면 기본 생성자를 호출해서 새로운 객체를 생성한다.



> 간단한 타입이란 org.springframework.beans.BeanUtils#isSimpleProperty(Class<?>)의 결과가 true가 되는 타입을 말한다.







#### 타입을 선택할 때 주의할 점

Servlet API(**HttpServletRequest, HttpServletResponse, HttpSession, Part**)나 저수준 자바 API(**InputStream, OutputStream, Reader, Writer, Map**)의 타입을 사용할 수도 있지만 이 API를 자유롭게 사용하면 애플리케이션 유지보수를 저하할 수 있다. 이 API는 애플리케이션 요구사항이 충족되지 않는 경우에 제한적으로 사용하자.







### 5.3.5 Handler Method의 반환값

**Handler Method**는 반환값으로 여러 객체를 반환할 수 있다.



> 반환할 수 있는 객체는 **HandlerMethodReturnValueHandler** 인터페이스(org.springframework.web.method.support.HandlerMethodReturnValueHandler)의 구현 클래스를 만드는 방법으로 확장할 수 있다.





#### 지정 가능한 주요 타입

스프링 MVC가 기본적으로 지원하는 반환값의 주요 타입은 다음과 같다.



**스프링 MVC가 지원하는 주요 타입**

| 타입                  | 설명                                                         |
| --------------------- | ------------------------------------------------------------ |
| **java.lang.String**  | 이동 대상의 뷰 이름을 반환한다.                              |
| **Model**             | 이동 대상에 전달할 데이터를 반환한다.                        |
| **ModelAndView**      | 이동 대상의 뷰 이름과 이동 대상에 전달할 데이터를 반환한다.  |
| **void**              | **HttpServletResponse**에 직접 응답 데이터를 쓰거나 **RequestToViewNameTranslator**의 메커니즘을 이용해 뷰 이름을 결정할때 void를 사용한다. |
| **ResponseEntity<?>** | 응답 헤더와 응답 본문에 직렬화될 객체를 반환한다. 반환한 객체는 **HttpMessageConverter** 메커니즘을 이용해 임의의 형식으로 직렬화된다. |
| **HttpHeader**        | 응답 헤더만 반환한다.                                        |





#### 지정 가능한 주요 애너테이션

메서드에 애너테이션을 지정하면 임의의 객체를 **Model**에 저장하거나 응답 본문에 직렬화할 수 있다. 지정할 수 있는 주요 애너테이션은 다음과 같다.



**메서드에 지정 가능한 애너테이션**

| Annotation          | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| **@ModelAttribute** | **Model**에 저장하는 객체를 반환한다(반환값의 형이 자바빈즈인 경우는 생략가능) |
| **@ResponseBody**   | 응답 본문에 직렬화하는 객체를 반환한다. 객체는 **HttpMessageConverter**의 메커니즘을 이용해 임의의 형식으로 직렬화된다. |







### 5.3.6 뷰 컨트롤러 이용

여기까지는 **Controller** 클래스에 **handler method**를 구현하는 유형을 설명했지만 **뷰**만 호출하는 경우라면 스프링 MVC가 제공하는 **뷰 컨트롤러(View Controller)**를 이용할 수 있다.



- **자바 기반 설정 방식으로 빈을 정의한 예**

```java
public class WebMvcConfig extends WebMvcConfigurerAdapter {
    // 생략
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/").setViewName("home");
    }
    // 생략
}
```





- **XML 기반 설정 방식으로 빈을 정의한 예**

```xml
<mvc:view-controller path="/" view-name="home" />
```









## 5.4 요청 매핑

스프링 MVC는 **@RequestMapping**의 속성값을 이용해 **요청 매핑 조건**을 지정한다. 이번 절에서는 **매핑 조건**을 구체적으로 지정하는 방법을 설명하겠다.



먼저 **@RequestMapping**에서 지정 가능한 속성을 살펴보자. 각각의 서로 다른 속성들은 AND 조건으로 적용되어 매핑되는 대상 범위를 점점 더 좁게 만드는 역할을 한다.



**@RequestMapping에서 지정 가능한 속성**

| 속성명       | 설명                                                         |
| ------------ | ------------------------------------------------------------ |
| **value**    | 요청 경로(또는 경로 패턴)를 지정한다.                        |
| **path**     | value 속성의 별명을 지정한다.                                |
| **method**   | HTTP 메서드 값(GET, POST, PUT 등)을 지정한다.                |
| **params**   | 요청 파라미터 유무나 파라미터 값을 지정한다.                 |
| **headers**  | 헤더 유무나 헤더 값을 지정한다.                              |
| **consumes** | Content-Type 헤더 값(미디어 타입)을 지정한다.                |
| **produces** | Accept 헤더 값(미디어 타입)을 지정한다.                      |
| **name**     | 매핑 정보에 임의의 이름을 지정한다. 이 속성에 지정하는 값에 따라 매핑 룰이 바뀌는 것은 없다. |



또한 **@RequestMapping**은 클래스 레벨과 메서드 레벨 모두에 지정할 수 있는데 두 곳에서 동시에 같은 속성을 지정한 경우에는 다음과 같이 동작한다.

- value(path), method, params, headers, name의 각 속성은 병합된 값이 적용된다.
- consumes, produces의 각 속성은 메서드 레벨에 지정한 값으로 덮어쓰게 된다.



> 스프링 4.3부터 **@RequestMApping**의 합성 애너테이션 **(@GetMapping, @PostMapping, @PutMapping, @DeleteMapping, @PatchMapping)**이 추가됐다.









### 5.4.1 요청 경로 사용

**요청 경로**는 반드시 설정해야 하는 필수 정보로서 <u>클래스</u>나 <u>메서드</u>에 매핑한다. **요청 경로**, 혹은 **경로 패턴**을 지정할 때는 **value** 속성이나 **path** 속성에 기재하면 된다.



- **요청 경로를 지정한 예**

```java
@Controller
@RequestMapping("accounts")  // 클래스 레벨로 지정하면 기본 경로로 취급된다.
public class AccountController {
	@RequestMapping("me/email")  
    // 메서드 레벨로 지정하면 기본 경로에 상대 경로를 덧붙인 형태로 취급된다. 
    // 이 예에서는 '/accounts/me/email'이라는 경로에 접근할 때 showEmail 메서드가 실행된다.
	public String showEmail(Model model) {
		// 생략
	}
}
```



속성값에는 여러 경로를 지정할 수 있으며, 여러 속성값이 동시에 지정된 경우에는 OR 조건으로 취급된다. 다음 예에서는 '/accounts/me/email' 또는 '/account/my/email'이라는 경로에 접근할 때 **showEmail** 메서드가 실행된다.



- **요청 경로를 여러 개 지정한 예**

```java
@RequestMapping({"me/email", "my/email"}) // 요청 경로를 여러 개 지정
public String showEmail(Model model) {
    // 생략
}
```





### 5.4.2 경로 패턴 사용

요청 경로에는 정적으로 표현된 구체적인 경로만이 아니라 동적으로 표현된 **경로 패턴**도 지정할 수 있다. 스프링 MVC가 지원하는 **경로 패턴 형식**은 다음의 세 가지다.

- **URI 템플릿 형식의 경로 패턴** (예: /accounts/{accountId})
- **URI 템플릿 형식의 경로 패턴 + 정규 표현식** (예: /accounts/{accountId:[a-f0-9-]{36}})
- **앤트 스타일의 경로 패턴** (예: /**/accounts/me/email)



여기서는 URL 템플릿 형식의 경로 패턴을 사용하는 방법을 설명한다. URL 템플릿은 URL 경로 상의 가변 값을 '**경로 변수**'로 취급한다. 예를 들어 `http://example.com/accounts/{accountId}` 같은 형태의 URL이 있다면 그 중에서 **{accountId}** 부분에 계정 ID를 지정하면 된다. 그래서 실제로 사용할 때는 `http://example.com/accounts/1`이나 `http://example.com/accounts/2` 같은 형태로 사용된다.



다음은 URL을 핸들러 메서드에 매핑한 경우로, URL 템플릿 형식의 경로 패턴을 사용했다.



- **URL 템플릿 형식의 경로 패턴을 지정한 예**

```java
@Controller
@RequestMapping("accounts")
public class AccountController {

	@RequestMapping("{accountId}")
	public String showAccount(@PathVariable String accountId, Model model) {
		// 생략
	}
}
```



경로 상의 가변부를 '경로 변수({경로 변수명}형식)'으로 지정한다. 위의 예에서는 `/accounts/{accountId}`라는 패턴의 경로로 접근하면 **showAccount** 메서드가 실행된다.





### 5.4.3 HTTP 메서드 사용

**HTTP 메서드**를 매핑 조건에 지정하는 경우에는 **method** 속성을 사용한다. 브라우저에 화면으로 응답하는 웹 애플리케이션에서는 **HTTP 메서드**로 **GET**과 **POST**의 두 가지를 사용할 수 있다.

- **GET**: 웹 페이지의 내용을 보거나 파일을 다운로드하는 것과 같이 서버에서 어떤 정보를 취득할 때 사용한다.
- **POST**: 서버에 어떤 정보를 전송할 때 사용한다(검색 조건은 POST가 아니라 GET을 사용하는 것이 일반적)





- **HTTP 메서드를 지정한 예**

```java
@Controller
@RequestMapping("accounts")
public class AccountController {
	// 생략
    @RequestMapping(path = "{accountId}", method = RequestMethod.GET)
    public String showAccount(@PathVariable String accountId, Model model) {
        // 생략
    }
}
```



**method** 속성에 `org.springframework.web.bind.annotation.RequestMethod` 열거형 값을 지정한다. 위의 예제에서는 `/accounts/{accountId}`라는 패턴 경로에 **GET** 메서드로 접근하면 **showAccount** 메서드가 실행된다.



속성 값에는 여러 **HTTP 메서드**를 지정할 수 있으며, 여러 속성값을 지정한 경우 **OR** 조건으로 취급한다.





### 5.4.4 요청 파라미터 사용

요청 파라미터를 매핑 조건에 지정하는 경우에는 **params** 속성을 사용한다. **params** 속성에서 지원하는 지정 형식은 다음과 같다.



**params 속성에서 지원되는 지정 형식**

| 지정 형식       | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| **name**        | 지정한 파라미터가 존재하는 경우에 매핑 대상이 된다.          |
| **!name**       | 지정한 파라미터가 존재하지 않는 경우에 매핑 대상이 된다.     |
| **name=value**  | 파라미터 값이 지정한 값에 해당하는 경우에 매핑 대상이 된다.  |
| **name!=value** | 파라미터 값이 지정한 값에 해당하지 않는 경우에 매핑 대상이 된다. |



- **요청 파라미터를 지정한 예**

```java
@Controller
@RequestMapping("accounts")
public class AccountController {
	// 생략
    @RequestMapping(path = "create", params = "form")
    // 요청 파라미터 유무 또는 요청 파라미터 값을 지정한다. 위에서는 파라미터명만 지정하고 있어서
    // '/accounts/create?form='이라는 URL에 접근하면 form 메서드가 실행된다.
    // POST 메서드를 사용해서 요청하는 경우라면 요청 본문에 'form'이라는 파라미터가 포함돼 있으면 된다.
    public String form(Model model) {
        return "account/form";
    }
}
```





화면 이동을 구현하고 싶을 경우, **Controller** 클래스에서는 다음과 같이 요청 매핑을 한다. 



- **요청 파라미터를 이용해 요청 매핑을 지정한 예**

```java
@Controller
@RequestMapping("accounts")
public class AccountController {
    
	@RequestMapping(path = "create", params = "form")
	public String form(Model model) {
        model.addAttribute(new AccountCreateForm());
        return "account/form";
    }
    
    @RequestMapping(path = "create", method = RequestMethod.POST, params = "confirm")
	public String confirm(@Validated AccountCreateForm form, BindingResult result) {
        // 생략
        return "account/confirm";
    }
    
    @RequestMapping(path = "create", method = RequestMethod.POST, params = "redo")
	public String redo(AccountCreateForm form) {
        return "account/form";
    }
    
    @RequestMapping(path = "create", method = RequestMethod.POST, params = "create")
	public String create(@Validated AccountCreateForm form, 
                         BindingResult result, RedirectAttributes redirectAttributes) {
        // 생략
        return "redirect:/accounts/create?complete";
    }
    
    @RequestMapping(path = "create", method = RequestMethod.GET, params = "complete")
	public String complete() {
        return "account/complete";
    }
}
```



HTML(JSP 등의 템플릿 파일) 측에서는 다음 중 한 가지 방법으로 요청 파라미터를 지정한다.

- 링크(\<a> 요소)의 경우는 **URL의 쿼리 문자열에 요청 파라미터를 지정**한다.
- HTML 폼의 버튼 (\<button> 요소나 \<input type="submit"> 요소 등)의 경우는 **name** **속성에 요청 파라미터의 이름을 지정**한다.





### 5.4.5 요청 헤더 사용

**요청 헤더**를 매핑 조건으로 지정하는 경우 **headers** 속성을 사용한다. **headers** 속성에서 지원하는 지정 형식은 **params** 속성과 같다.



- **요청 헤더 지정 예**

```java
@RequestMapping(headers = "X-Migration=true") 
// 요청 헤더 유무 또는 요청 헤더 값을 지정한다.
// 위에서는 X-Migration 헤더 값에 true를 지정하고 접근하면 postMigrationAccount 메서드가 실행된다.
@ResponseBody
public Account postMigrationAccount(@Validated @RequestBody Account account) {
    // 생략
}
```



속성값에는 여러 헤더를 지정할 수 있으며, 여러 속성값이 동시에 지정된 경우에는 AND 조건으로 취급한다.





### 5.4.6 Content-Type 헤더 사용

요청의 **Content-Type 헤더** 값을 매핑 조건으로 지정하는 경우에는 **consumes** 속성을 사용한다. **consumes** 속성에서 지원하는 지정 형식은 다음과 같다.



**consumes 속성에서 지원되는 지정 형식**

| 지정 형식      | 설명                                                  |
| -------------- | ----------------------------------------------------- |
| **mediaType**  | 미디어 타입이 지정한 값인 경우 매핑 대상이 된다.      |
| **!mediaType** | 미디어 타입이 지정한 값이 아닌 경우 매핑 대상이 된다. |





- **Content-Type을 지정한 예**

```java
@RequestMapping(consumes = "application/json")
// 요청 본문의 미디어 타입을 지정한다. 이 예에서는 요청 본문에 JSON(미디어 타입이 application/json)을 지정해서 접근하면 postAccount 메서드가 실행된다.
@ResponseBody
public Account postAccount(@Validated @RequestBody Account account) {
    // 생략
}
```



속성값에는 여러 개의 미디어 타입을 지정할 수 있으며, 동시에 여러 속성값을 지정한 경우에는 OR 조건으로 취급한다.





### 5.4.7 Accept 헤더 사용

요청 Accept 헤더 값을 매핑 조건에 지정하는 경우 **produces** 속성을 사용한다. **produces** 속성에서 지원하는 지정 형식은 **consumes**와 같다. 



- **Accept를 지정한 예**

```java
@RequestMapping(path = "create", produces = "application/json")
// 응답 본문의 미디어 타입을 지정한다. 
// 이 예에서는 응답 본문으로 JSON(미디어 타입이 application/json)을 받을 수 있는 클라이언트가 접근하면 postAccount 메서드가 실행된다.
@ResponseBody
public Account postAccount(@Validated @RequestBody Account account) {
    // 생략
}
```



속성값에는 여러 개의 미디어 타입을 지정할 수 있으며, 동시에 여러 속성값을 지정한 경우에는 OR 조건으로 취급한다.







## 5.5 요청 데이터 취득

스프링 MVC는 **요청 데이터**를 가져올 수 있는 다양한 방법을 제공하고 있어서 요청 데이터를 손쉽게 취득할 수 있다.



**요청 데이터를 가져오는 대표적인 방법**

| 취득 방법                      | 설명                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| **경로 변수 값 취득**          | @PathVariable을 사용해 특정 경로 변수 값을 취득한다.         |
| **요청 파라미터 값 취득**      | @RequestParam을 사용해 특정 요청 파라미터 값을 취득한다.     |
| **요청 헤더 값 취득**          | @RequestHeader를 사용해 특정 요청 헤더 값을 취득한다.        |
| **쿠키 값 취득**               | @CookieValue를 사용해 특정 쿠키 값을 취득한다.               |
| **요청 파라미터 값 일괄 취득** | 폼 클래스(또는 명령 클래스)라 불리는 자바빈즈를 사용해 요청 파라미터를 자바빈즈 프로퍼티에 바인딩해서 취득한다. |



여기서는 애너테이션을 사용해 요청 데이터를 취득하는 방법을 소개한다.



### 5.5.1 경로 변수 값 취득(@PathVariable)

URL에서 경로 변수 값을 취득하려면 메서드 파라미터에 **@PathVariable**을 지정한다.



- **메서드 파라미터를 정의한 예**

```java
@RequestMapping(path = "accounts/{accountId}", method = RequestMethod.GET)
// @RequestMapping의 value(path) 속성에 경로 변수({변수명})를 선언한다. 
// 이 예에서는 accountId라는 이름의 경로 변수를 지정하고 있다.
public String detail(@PathVariable String accountId) {
    // 경로 변수 값을 취득할 인수에 @PathVariable을 지정한다. value 속성을 생략하면 인수명이 경로 변수명이 된다.
     
    // 생략
}
```



> @PathVariable을 사용해 취득한 경로 변수의 값은 Model 객체에 같은 이름으로 저장된다.







### 5.5.2 요청 파라미터 값 취득(@RequestParam)

사용자가 직접 입력하지 않는(프로그램에서 부여하는) 요청 파라미터 값을 취득하려면 메서드 파라미터에 **@RequestParam**을 지정한다.



- **메서드 파라미터 정의 예**

```java
@RequestMapping(path = "detail", method = RequestMethod.GET)
public String detail(@RequestParam String format) {
    // 요청 파라미터 값을 취득하는 인수에 @RequestParam을 지정한다.   
    
    // 생략
}
```



> 요청 헤더 값과 쿠키 값도 유사한 방법으로 정보를 가져올 수 있다. 
>
> 요청 헤더 값이 필요한 경우에는 **@RequestHeader**, 
>
> 쿠키 값이 필요한 경우에는 **@CookieValue**를 사용한다.







### 5.5.3 @RequestParam, @RequestHeader, @CookieValue 속성값

**@RequestParam, @RequestHeader, @CookieValue**에는 다음과 같은 속성이 있어 기본 동작 방식을 커스터마이즈할 수 있다.



**지정 가능한 속성**

| 속성명           | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| **value**        | 값을 취득하는 파라미터명을 지정한다. 생략한 경우에는 인수명이 파라미터명으로 적용된다. |
| **name**         | value 속성의 별명                                            |
| **required**     | 파라미터의 필수 여부를 지정한다. 생략한 경우에는 true(필수)가 적용되고 파라미터가 존재하지 않는 경우에는 org.springframework.web.bind.ServletRequestBindingException이 발생하고 400(Bad Request)로 취급한다. |
| **defaultValue** | 파라미터가 존재하지 않는 경우(또는 파라미터가 공백인 경우)에 적용하는 기본값을 지정한다. 기본값을 지정한 경우 required 속성은 강제적으로 false가 된다. |



> defaultValue 속성에 지정할 수 있는 것은 문자열뿐이지만 지정한 문자열은 스프링 MVC가 제공하는 타입 변환 메커니즘에 따라 인수형으로 변환된다.





- **속성값을 지정한 예**

```java
@RequestMapping(path = "accounts", method = RequestMethod.GET)
public String cart(
	@CookieValue("example.springbook.cartId") String cartId,
    @RequestHeader(name = "X-Track-Id", required = false) String trackingId,
    @RequestParam(defaultValue = 1) Integer page) {
    
    // 생략
}
```



**required = false** 대신 Java SE 8에서 추가된 `java.util.Optional`을 사용해 값을 취득할 수도 있다.



- **Optional 사용 예**

```java
@RequestMapping(path = "accounts/create", method = RequestMethod.POST)
public String create(
	@Validated AccountCreateForm form,
    @RequestHeader("X-Track-Id") Optional<String> trackingId){
    
    // 생략
}
```





### 5.5.4 컴파일 옵션과 주의할 점

**@PathVariable, @RequestParam, @RequestHeader, @CookieValue**의 **value(name)** 속성을 생략하고 싶다면 컴파일할 때 **-g** 옵션(디버깅 정보를 출력하는 모드)이나 Java SE 8에서 추가된 **-parameters** 옵션(메서드 또는 파라미터에 리플렉션용 메타데이터를 생성하는 모드)을 사용해야 한다. 만약 이 옵션을 지정하지 않으면 런타임 시 요청 데이터로부터 값을 받아 인수의 값을 채워주지 못하기 때문에 오동작이 발생할 수 있다.





### 5.5.5 이용 가능한 타입

요청 파라미터, 요청 헤더, 쿠키에 설정되는 값은 물리적으로 **문자열 타입**으로 취급되지만 논리적으로는 **숫자, 날짜/시간, 불린값과 같은 타입**이 더 적절한 경우가 있다. 스프링 MVC에서는 이러한 항목에 대해 요청 데이터를 문자열이 아닌 타입으로 변환하는 메커니즘을 제공한다. 기본적으로 이용 가능한 주요 타입은 다음과 같다.

- **기본형(int, boolean 등) 및 Wrapper 타입(Integer, Boolean 등)**
- **값을 표현하는 타입(String, Date 등)**
- **MultipartFile**



또한 요청 데이터는 컬렉션이나 배열로 취득할 수 있다. 이것은 체크박스나 셀렉트 박스처럼 여러 개의 선택 값을 구할 때 사용할 수 있다.



기본적으로 다양한 타입을 변환할 수 있지만 미처 지원되지 않는 타입을 추가하거나 스프링 MVC의 기본 동작 방식을 커스터마이징하고 싶은 경우에는 `org.springframework.web.bind.WebDataBinder` 클래스의 메서드를 확장하면 된다.





### 5.5.6 바인딩 처리의 커스터마이징(WebDataBinder)

요청 데이터를 폼 클래스의 프로퍼티나 메서드의 파라미터로 바인딩하는 것은 **WebDataBinder**의 메서드를 확장해서 커스터마이징할 수 있다. **WebDataBinder**에는 스프링 MVC가 수행하는 바인딩을 커스터마이징할 수 있도록 다음과 같은 두 가지 메서드가 마련돼 있다.

- **addCustomFormatter**

  `org.springframework.format.Formatter` 인터페이스를 구현해서 문자열을 임의의 타입으로 변환할 수 있는 커스텀 포매터를 적용할 때 사용하는 메서드다.

- **registerCustomEditor**

  `java.beans.PropertyEditor` 인터페이스를 구현해서 문자열을 임의의 타입으로 변환할 수 있는 커스텀 에디터를 적용할 때 사용하는 메서드다.



> **WebDataBinder**는 문자열을 다른 타입으로 변환할 때 스프링 프레임워크가 제공하는 타입 변환 메커니즘을 이용한다. 



먼저 **WebDataBinder** 메서드를 호출하기 위해 `@org.springframework.web.bind.annotation.InitBinder` 애너테이션이 붙은 메서드를 **Controller** 클래스에 구현해야 한다. 스프링 MVC는 요청 데이터의 바인딩을 수행하기 전에 **@InitBinder** 애너테이션이 붙은 메서드를 호출한다.



- **@InitBinder 메서드를 정의한 예**

```java
@InitBinder
// WebDataBinder를 인수로 받는 메서드를 작성하고 @InitBinder를 지정한다. 
// 폼 클래스나 메서드 매개변수에 요청 데이터를 바인딩하기 전에 이 메서드가 호출된다.
public void initBinder(WebDataBinder binder) {
	// 생략
}
```





다음으로 **addCustomFormatter**와 **registerCustomEditor** 메서드를 호출해 커스터마이징된 구현 클래스를 적용한다. 다음 예에서는 스프링 프레임워크가 제공하는 구현 클래스를 이용해 문자열을 **Date** 타입으로 변환하고 있는데, 이때 포맷을 'yyyyMMdd' 형식으로 커스터마이징하고 있다.



- **addCustomFormatter 메서드를 호출한 예**

```java
@InitBinder
public void initBinder(WebDataBinder binder) {
    binder.addCustomFormatter(new DateFormatter("yyyyMMdd"));
}
```



- **registerCustomEditor 메서드를 호출한 예**

```java
@InitBinder
public void initBinder(WebDataBinder binder) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyyMMdd");
    dateFormat.setLenient(false);
    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
}
```



**addCustomFormatter** 메서드와 **registerCustomEditor** 메서드에는 커스터마이징된 구현 클래스를 적용할 대상(폼의 속성명과 요청 파라미터명 등)을 지정할 수 있는 오버로드 메서드가 있다. 또한 **@InitBinder**의 **value** 속성에는 **@InitBinder** 메서드를 적용할 대상을 명시할 수도 있다. 예를 들어, 다음은 **@InitBinder** 메서드를 **'targetDate'**라는 이름의 요청 파라미터에 대해서만 적용해서 'yyyyMMdd'과 같은 포맷으로 바인딩하도록 돼 있다.



- **특정 파라미터에 대해서만 커스텀 구현을 적용하는 예**

```java
@RequestMapping(path = "search", method = RequestMethod.GET)
public String search(@RequestParam targetDate, Model model) {
    // 생략
}

@InitBinder
public void initBinder(WebDataBinder binder) {
    binder.addCustomFormatter(new DateFormatter("yyyyMMdd"), "targetDate");
}

// 또는

@InitBinder("targetDate")
public void initBinder(WebDataBinder binder) {
    binder.addCustomFormatter(new DateFormatter("yyyyMMdd"));
}
```





> 여러 **Controller** 클래스에 대해 커스터마이징된 구현 클래스를 적용하고 싶다면 **@ControllerAdvice** 애너테이션이 붙은 클래스에 구현하면 된다.





### 5.5.7 애너테이션을 사용한 포맷 지정

파라미터마다 '숫자'와 '날짜/시간' 포맷을 지정할 때는 스프링 프레임워크에서 제공하는 다음과 같은 두 애너테이션을 사용해 직관적으로 파악할 수 있게 만들 수 있다.

- **@org.springframework.format.annotation.DateTimeFormat**

  날짜/시간 포맷을 지정하기 위한 애너테이션이다. 이 애너테이션은 자바 표준 **java.util.Date, java.util.Calendar, java.lang.Long** 외에도 **Joda-Time**과 **JSR 310:Date and Time API(java.time.*)** 클래스를 지원한다.



- **@org.springframework.format.annotation.NumberFormat**

  숫자나 통화 포맷을 지정하기 위한 애너테이션이다. 이 애너테이션은 자바 표준 **java.lang.Number** 클래스의 서브 클래스 외에 스프링 프레임워크 4.2 버전부터 **JSR 354: Money and Currency API(javax.money.*)**의 일부 클래스(**MonetaryAmount와 CurrencyUnit**)를 지원한다.



포맷을 지정하는 애너테이션을 사용하면 **@InitBinder**의 메서드를 구현하는 대신 다음과 같이 지정할 수 있다.



- **폼 클래스를 지정한 예**

```java
public class AccountCreateForm implements Serializable {
    // 생략
    @DateTimeFormat(pattern="yyyyMMdd")
    private Date dateOfBirth;
    // 생략
}
```





- **핸들러 메서드의 인수로 지정한 예**

```java
@RequestMapping(path="search", method=RequestMethod.GET)
public String search(@DateTimeFormat(pattern="yyyyMMdd") @RequestParam targetDate, Model model) {
    // 생략
}
```



> **@DateTimeFormat**과 **@NumberFormat**은 메타 애너테이션으로 사용할 수 있다. 메타 애너테이션의 메커니즘을 이용해 커스텀 애너테이션을 만들면 포맷 정의를 관리하기가 쉬워지고 포맷 지정도 직관적으로 할 수 있다.





## 5.6 폼 클래스 구현

**폼 클래스**는 HTML 폼의 입력 필드 구조를 자바빈즈로 표현한 클래스다. 스프링 MVC는 폼 객체를 통해 다음 값을 서버와 클라이언트 사이에서 연계(바인딩)하는 구조로 되어있다.

- **HTML 폼에 표시하는 값**

  폼 객체가 가지고 있는 값을 HTML에 표시하도록 데이터를 연계하는 역할을 한다. JSP 등의 **뷰**에서 구현한다.

- **HTML 폼에 입력한 값**

  입력한 값(요청 파라미터 값)을 폼 객체에 담아 **Front Controller**에 전달하는 역할을 한다.





![](https://docs.google.com/drawings/d/s9htF1VJgl_UgSuTZNU5IBA/image?parent=e/2PACX-1vSgWs9-SkKDVDplyC96i2vj5TuZvbmLHvACG_NMQ3eEa1hFtJwCGbFZVRaHriS3HOeS8O0XIQ6gqqII&rev=477&h=313&w=601&ac=1)



HTML 폼 필드와 폼 클래스의 프로퍼티 간에 **데이터 바인딩**을 할 때는 스프링 MVC가 정한 명명 규칙을 따르게 된다. 구체적인 바인딩 예는 나중에 설명한다.



### 5.6.1 폼 객체의 스코프

폼 클래스의 구체적인 작성 방법을 설명하기 전에 **폼 객체의 스코프**에 대해 설명하겠다. 폼 객체는 **요청 스코프, 플래시 스코프(Flash Scope), 세션 스코프**의 세 가지 스코프 중 하나에서 관리된다.



| 스코프                                            | 설명                                                         |
| ------------------------------------------------- | ------------------------------------------------------------ |
| **요청 스코프                                  ** | 요청에서 객체를 공유하기 위한 스코프(기본값). 객체를 요청 스코프로 취급하는 경우는 특별한 구현은 필요 없다. 단순히 Model에 객체를 저장만 하면 요청 스코프의 객체로 취급된다. |
| **플래시 스코프**                                 | **PRG(Post Redirect Get)** 패턴의 요청 사이(POST와 리다이렉트 후의 GET과의 두 요청 사이)에서 객체를 공유하기 위한 스코프. 객체는 일시적으로 **HttpSession**에 저장되어 리다이렉트 처리 완료 후에 자동으로 파기된다. |
| **세션 스코프**                                   | 같은 세션의 여러 요청에서 객체를 공유하기 위한 스코프. 객체는 **HttpSession**에 저장되어 명시적으로 파기하기 까지 **HttpSession**에 계속 남는다. |



> 위에서 소개한 스코프는 폼 객체만의 개념이 아니라 **Model**에 저장하는 객체에 공통으로 적용되는 개념이다. 





#### 요청 스코프

**폼 객체**를 **요청 스코프**로 취급하는 경우, 특별한 구현은 필요없다. 단순히 **Model**에 객체를 저장하는 것만으로 **요청 스코프의 객체**로  취급된다.



같은 화면을 여러 사용자에게 동시에 표시할 수 있는 애플리케이션을 개발할 때는 **폼 객체**를 **요청 스코프**에서 관리해야 한다. **요청 스코프**를 사용하면 조작성이 좋은 애플리케이션을 만들 수 있지만 화면을 이동할 때마다 **폼 데이터**를 **\<input type="hidden">**을 사용해 여기저기 가지고 다녀야 하기 때문에 JSP 구현이 복잡할 수 있다.



#### 플래시 스코프

**폼 객체**를 **플래시 스코프**로 취급하는 경우 **org.springframework.web.servlet.mvc.support.RedirectAttributes**에 객체를 추가하면 된다. **RedirectAttributes**에 객체를 추가할 때는 **addFlashAttribute** 메서드를 사용하는 것이 중요하다.



- **플래시 스코프의 사용 예**

```java
@RequestMapping(path="create", method=RequestMethod.POST)
public String create(
    @Validated AccountCreateForm form, BindingResult result,
    RedirectAttributes redirectAttributes) {
    redirectAttributes.addFlashAttribute(form);
    return "redirect:/account/create?complete";
}

@RequestMapping(path="create", method=RequestMethod.GET, params="complete")
public String createComplete(AccountCreateForm form) {
    // 생략
    return "account/complete";
}
```



**PRG 패턴**을 사용해 리다이렉트 처리할 때 **컨트롤러**와 **뷰**에서 **폼 객체**를 참조하고 싶다면 **폼 객체**를 **플래시 스코프**에서 관리하면 된다.





#### 세션 스코프

**폼 객체**를 **세션 스코프**로 취급하는 경우 **@org.springframework.web.bind.annotation.SessionAttributes**에 세션 스코프로 관리할 대상(클래스 또는 속성명)을 지정하기만 하면 된다.



- **세션 스코프 관리 대상을 지정한 예**

```java
@Controller
@RequestMapping("account/create")
@SessionAttributes(types=AccountCreateForm.class) // 세션 스코프에서 관리할 대상을 지정
public class AccountCreateController {
	// 생략
}
```



**폼 데이터**를 **\<input type="hiddent">**을 사용해 여기저기 가지고 다니는 것이 어려운 경우에는 **폼 객체**를 **세션 스코프**로 관리하는 방법을 고려해보자.





### 5.6.2 폼 클래스 작성

여기서는 **폼 클래스**를 작성하는 방법을 설명한다.



- **폼 클래스의 작성 예**

```java
public class AccountCreateForm implements Serializable {
    private static final long serialVersionUID = 7857661706767062157L;
    // serialVersionUID 구현이 필수인 것은 폼 객체를 세션 스코프에서 관리하는 경우지만 
    // 스코프와 관계없이 Serializable을 구현해 두는 것이 무난하다.
    
    @NotNull
    @Size(min=1, max=50)
    private String name;
    
    @NotNull
    @Size(min=9, max=11)
    private String tel;
    
    @NotNull
    @DateTimeFormat(pattern="yyyy/MM/dd")
    private Date dateOfBirth;
    
    @NotNull
    @Size(min=9, max=256)
    private String email;
    
    // 생략
}
```





### 5.6.3 HTML 포맷과 바인딩

여기서는 **HTML 폼**과 **폼 객체**의 **바인딩 패턴**에 대해 구체적인 예를 보면서 설명하겠다.

구체적인 패턴을 설명하기에 앞서 **HTML 폼**과 **폼 객체**를 연결하는 방법을 알아보자.



#### 폼 객체를 Model에 저장

**뷰(JSP)**에서 **폼 객체**로 접근할 수 있도록 **폼 객체**를 **Model**에 저장한다. **폼 객체**를 **Model**에 저장하는 방법은 두 가지가 있다.





**첫 번째**는 **Model API**를 직접 호출하는 방법으로 다음과 같이 구현한다.



- **Model API를 직접 호출해서 저장하는 구현 예**

```java
@RequestMapping("create")
public String form(Model model) {
	model.addAttribute(new AccountCreateForm()); 
    // Model에 추가할 때의 속성명은 생략할 수 있으며 생략한 경우에는 기본 속성명이 적용된다.
    // 이 예에서는 'accountCreateForm'(클래스명의 첫 글자를 소문자로 한 값)이 속성명이 된다.    
	return "account/createForm";
}
```







**두 번째**는 **@ModelAttribute** 애너테이션을 메서드에 붙여주는 방법으로 다음과 같이 구현한다.



- **@ModelAttribute 애너테이션을 메서드에 붙여 저장하는 구현 예**

```java
@ModelAttribute
public AccountCreateForm setUpForm() {
	return new AccountCreateForm();
}
// @ModelAttribute가 붙은 메서드는 핸들러 메서드가 호출되기 전에 실행되고 이때 반환되는 객체가 Model에 저장된다.
// Model에 추가할 때의 속성명은 @ModelAttribute의 value 속성에 지정할 수 있고, 생략한 경우에는 기본 속성명이 적용된다.

@RequestMapping("create")
public String form(Model model) {
    return "account/createForm";
}
```





#### 폼 객체와 HTML 객체의 연결

**Model**에 저장된 **폼 객체**와 **HTML 객체**를 연결한다.



- **폼 객체를 HTML 객체에 연결하는 JSP 구현 예**

```jsp
<form:form modelAttribute="accountCreateForm">
	<!-- 생략 -->
</form:form>
```



**폼 객체**의 **프로퍼티**와 **HTML 필드**의 구체적인 연결 방법은 나중에 패턴별로 설명하겠다.







### 5.6.4 간단한 타입과의 바인딩

먼저 간단한 타입과의 바인딩 방법에 대해 설명한다. 5.5절에서는 **요청 데이터(요청 파라미터)**를 받을 수 있는 다양한 타입을 소개했는데, 폼 클래스에서도 마찬가지로 **String** 외의 타입에 바인드할 수 있다.



구체적으로는 다음에 소개하는 타입에 바인드할 수 있다.

- **기본형(int, boolean 등) 및 Wrapper형(Integer, Boolean 등)**
- **값을 표현하는 타입(String, Date 등)**
- **MultipartFile**



간단한 타입의 프로퍼티와 바인딩하는 경우에는 **HTML 폼의 필드명**과 **폼 클래스의 프로퍼티명**을 일치시키기만 하면 된다.





![](https://docs.google.com/drawings/d/sTmFG-42DVYWY_ZB9H1XvwQ/image?parent=e/2PACX-1vSgWs9-SkKDVDplyC96i2vj5TuZvbmLHvACG_NMQ3eEa1hFtJwCGbFZVRaHriS3HOeS8O0XIQ6gqqII&rev=153&h=405&w=601&ac=1)



- **간단한 타입의 프로퍼티와 바인딩하는 예**

```jsp
<form:form modelAttribute="accountCreateForm">
	<span>이름</span><form:input path="name" /><br>
    <span>TEL</span><form:input path="tel" /><br>
    <span>생년월일</span><form:input path="dateOfBirth" type="date" /><br>
    <span>E-Mail</span><form:input path="email" type="email" /><br><br>
    <!-- 생략 -->
</form:form>
```







### 5.6.5 간단한 타입의 컬렉션과의 바인딩

간단한 타입*은 컬렉션으로 바인딩할 수도 있다. 컬렉션은 체크박스나 셀렉트 박스와 같이 여러 개의 값을 선택할 때 이용할 수 있다.



> 여기서 '간단한 타입'이라고 부르는 것은 뒤에 나올 '중첩된 자바빈즈' 형태가 아닌 것을 말한다.



간단한 타입의 컬렉션 프로퍼티와 바인딩하는 경우에는 간단한 타입과 마찬가지로 **HTML 폼의 필드명**과 **폼 클래스의 프로퍼티명**을 일치시키기만 하면 된다. 또한 컬렉션 안의 위치를 명시적으로 지정하고 싶다면 '**컬렉션 프로퍼티명[요소 위치]**' 형식으로 **HTML 폼의 필드명**을 지정한다.



![](https://docs.google.com/drawings/d/sc3Aw62ARa3swnUx7dGL4iw/image?parent=e/2PACX-1vSgWs9-SkKDVDplyC96i2vj5TuZvbmLHvACG_NMQ3eEa1hFtJwCGbFZVRaHriS3HOeS8O0XIQ6gqqII&rev=294&h=354&w=601&ac=1)



> 스프링 MVC는 **맵(java.util.Map)** 과의 바인딩도 지원하며, 맵을 사용하는 경우에는 **path** 속성에 **'맵 프로퍼티명[키명]'** 형식으로 바인딩한다.





### 5.6.6 중첩된 자바빈즈와의 바인딩

**폼 클래스**를 이용하면 **요청 파라미터**를 **중첩된 자바빈즈 프로퍼티**에 바인딩할 수 있다. 중첩된 자바빈즈에서 정의할 수 있는 타입은 폼 클래스에서 정의할 수 있는 타입과 같다.



**중첩된 자바빈즈 프로퍼티**와 바인딩하는 경우에는 **프로퍼티명**을 '.'(마침표)로 연결한 것을 **HTML 폼 필드명**으로 지정한다.



![](https://docs.google.com/drawings/d/sxCmF8MKrmscC9sLQZGjRCw/image?parent=e/2PACX-1vSgWs9-SkKDVDplyC96i2vj5TuZvbmLHvACG_NMQ3eEa1hFtJwCGbFZVRaHriS3HOeS8O0XIQ6gqqII&rev=497&h=403&w=601&ac=1)



- **폼 클래스(중첩된 자바빈즈를 가진 클래스)의 작성 예**

```java
public class AccountCreateForm implements Serializable {
	private static final long serialVersionUID = 227663138337489947L;
    private AccountForm account;
    private CardForm card;
    // 생략
}
```



- **중첩된 클래스의 작성 예(AccountForm)**

```java
public class AccountForm implements Serializable {
	private static final long serialVersionUID = -5862188955700105210L;
    private String name;
    private String email;
    // 생략
}
```



- **중첩된 클래스의 작성 예(CardForm)**

```java
public class CardForm implements Serializable {
	private static final long serialVersionUID = -2291966585119949801L;
    private String no;
    private Date validMonth;
    // 생략
}
```



- **중첩된 자바빈즈 프로퍼티와의 바인딩 예**

```jsp
<form:form modelAttribute="accountCreateForm">
	<!-- 생략 -->
    <span>이름</span><form:input path="account.name" /><br>
    <span>E-Mail</span><form:input path="account.email" /><br>
    <span>번호</span><form:password path="card.no" /><br>
    <span>기간</span><form:input path="card.validMonth" /><br><br>
</form:form>
```







### 5.6.7 자바빈즈의 컬렉션과의 바인딩

**폼 클래스**를 이용하면 **요청 파라미터**를 자바빈즈의 **컬렉션 프로퍼티**에 바인딩할 수 있다.



자바빈즈의 컬렉션 프로퍼티와 바인딩하는 경우에는 '**컬렉션 프로퍼티명[요소 위치].프로퍼티명**' 형식으로 **HTML 폼의 필드명**을 지정한다.



![](https://docs.google.com/drawings/d/saiATeNK_II0SgDtfiIV_3w/image?parent=e/2PACX-1vSgWs9-SkKDVDplyC96i2vj5TuZvbmLHvACG_NMQ3eEa1hFtJwCGbFZVRaHriS3HOeS8O0XIQ6gqqII&rev=334&h=403&w=601&ac=1)



- **컬렉션의 자바빈즈 프로퍼티와 바인딩한 예**

```jsp
<form:form modelAttribute="accountCreateForm">
	<!-- 생략 -->
    <span>번호</span><form:password path="cards[0].no" /><br>
    <span>기간</span><form:input path="cards[0].validMonth"/><br><br>
    <!-- 생략 -->
    <span>번호</span><form:password path="cards[1].no" /><br>
    <span>기간</span><form:input path="cards[1].validMonth"/><br><br>
    <!-- 생략 -->
</form:form>
```



> 스프링 MVC는 자바빈즈의  **맵(java.util.Map)**에 대한 프로피터 바인딩도 지원하며, **path** 속성에 '**맵 프로퍼티명[키 명]**' 형식으로 값을 바인딩한다.





### 5.6.8 프로퍼티 값의 해제

마지막으로 **폼 객체의 프로퍼티값을 설정 해제**하는 방법을 소개하겠다.



프로퍼티의 값의 설정을 해제하는 것은 **폼 객체에 초깃값을 설정**했거나 **폼 객체를 세션 스코프로 관리**하고 있을 때, 다음과 같은 작업(처리)을 할 때 반드시 필요하다.

- **체크박스를 '체크됨'에서 '체크 안 됨' 상태로 변경**
- **여러 선택 가능한 셀렉트 박스를 '선택됨'에서 '선택 안 됨' 상태로 변경**
- **입력 항목을 '활성'에서 '비활성' 상태로 변경**
- **입력 항목을 화면에 표시되지 않게 변경(DOM상에서 삭제)**



이와 같은 작업을 한 후에 폼을 전송해보면 요청 파라미터 자체가 전송되지 않기 때문에 폼 객체의 상태가 변경되지 않는다. 결과적으로 해제했다고 생각한 값이 여전히 설정돼 있는 이상한 현상이 일어나게 된다.



#### 설정 해제용 요청 파라미터

스프링 MVC는 폼 객체의 프로퍼티 값을 설정 해제하기 위해 특수한 요청 파라미터를 지원한다. 설정 해제용 요청 파라미터는 데이터 바인딩용 요청 파라미터 이름의 앞에 '_'(언더 스코어)를 붙인 것이다. 예를 들어, **roles**라는 이름의 프로퍼티에 대한 설정 해제용 요청 파라미터는 **\_roles**가 된다. 



설정 해제용 요청 파라미터를 전송하면 다음과 같은 동작이 일어난다.

1. **폼 객체의 프로퍼티 값에 null을 설정한다.**
2. **다음으로 폼 객체의 프로퍼티 값에 데이터 바인딩용 요청 파라미터를 설정한다.**



결국 데이터 바인딩용 요청 파라미터가 전송되지 않은 프로퍼티는 값이 해제되는 효과를 낸다.



> 스프링 MVC가 제공하는 JSP 태그 라이브러리(\<form:checkboxes> 요소와 \<form:select> 요소 등)를 사용해서 체크박스나 셀렉트 박스를 만들면 설정 해제용 파라미터가 자동으로 전송되어 위와 같은 현상에 대해 특별히 신경 쓰지 않아도 된다. 만약 이들을 사용하지 않는다면 비활성이나 미표시 상태로 변경한 항목에 대해 설정 해제용 요청 파라미터가 전송되도록 \<hidden> 요소를 사용하도록 구현하는 것이 좋다.







## 5.7 입력값 검사

스프링 MVC는 **Bean Validation** 기능을 이용해 요청 파라미터 값이 바인딩된 폼 클래스(또는 커맨드 클래스)의 입력값 검사를 한다. **Bean Validation**을 활용한 입력값 검사는 스프링 프레임워크 3.0부터 지원됐는데 그 이전까지는 스프링이 제공하는 독자적인 **Validation** 메커니즘(이후 **Spring Validator**로 표기)을 이용해 입력값 검사를 했다. 이 절에서는 **Bean Validation**으로 입력값 검사를 구현하는 방법을 살펴본 후에 **Spring Validator** 구조에 대해서도 살펴보기로 하자.



### 5.7.1 입력값 검사 기능의 활성화

스프링 MVC의 기본 동작에서는 폼 클래스에 대한 입력값 검사를 하지 않는다. 입력값 검사를 하기 위해서는 메서드 매개변수에 폼 클래스를 정의하고 **@org.springframework.validation.annotation.Validated** 또는 **@javax.validation.Valid**를 지정하자. **@Validated**를 사용하면 **Bean Validation**의 유효성 검증 그룹 메커니즘을 이용할 수 있어서 이 책에서는 **@Validated**를 사용하는 것을 전제로 설명하겠다.



- **입력값 검사를 활성화하기 위한 핸들러 메서드의 구현 예**

```java
@RequestMapping(method = RequestMethod.GET)
public String search(
	@Validated AccountSearchForm form,
	BindingResult result,
	Model model) {
	// 생략	
}
// 입력값 검사 대상의 폼 클래스 직후에 org.springframework.validation.BindingResult를 정의한다.
// BindingResult에는 요청 데이터의 바인딩 오류와 입력값 검사 오류 정보가 저장된다.
```



요청 파라미터 값에 문제가 있으면 **BindingResult**를 통해 다음과 같이 오류 정보가 전달된다.



![](https://docs.google.com/drawings/d/sWmA844VcjMBkmGdydi0pww/image?parent=e/2PACX-1vSgWs9-SkKDVDplyC96i2vj5TuZvbmLHvACG_NMQ3eEa1hFtJwCGbFZVRaHriS3HOeS8O0XIQ6gqqII&rev=638&h=425&w=601&ac=1)



> 스프링 MVC에서는 숫자 타입이나 날짜/시간 타입과 같은 **유효성 검사를 요청 파라미터가 폼 객체로 바인딩될 때** 함께 하게 되며, **형 변환 오류**가 발생하면 유효성 검사에 실패한 것으로 판단한다. **형 변환 오류**가 발생하면 폼 객체의 프로퍼티와 관련된 바인딩 오류를 **BindingResult**에 저장한다. 만약 인수에 **BindingResult**를 생략하면 **org.springframework.validation.BindException**이 발생하고 **400 (Bad Request)**로 취급된다.



### 5.7.2 입력값 검사 결과의 판정

입력값 검사와 검사 결과(**BindingResult**)를 만드는 것은 프레임워크에서 해주지만 입력값 검사 결과에 대한 **오류를 판단**하고 **그에 맞는 처리**를 하는 것은 **애플리케이션측에서 구현**해야 한다. 입력값 검사 후, 오류 정보를 확인하려면 **BindingResult**의 메서드를 사용하면 된다.



**BindingResult에서 제공하는 오류 판단 메서드**

| 메서드명                   | 설명                                                         |
| -------------------------- | ------------------------------------------------------------ |
| **hasErrors()**            | **오류**가 발생한 경우 true를 반환한다.                      |
| **hasGlobalErrors()**      | **객체 레벨의 오류**가 발생한 경우 true를 반환한다.          |
| **hasFieldErrors()**       | **필드 레벨의 오류**가 발생한 경우 true를 반환한다.          |
| **hasFieldErrors(String)** | **인수에 지정한 필드에서 오류**가 발생한 경우 true를 반환한다. |



다음은 **hasErrors** 메서드를 이용한 전형적인 구현 예다.



- **표준적인 입력값 검사 결과의 판단 예**

```java
@RequestMapping(path="search", method=RequestMethod.GET) 
public String search(@Validated AccountSearchForm form, BindingResult result, Model model) {
    if(result.hasErrors()) {
        return "account/searchForm";
    }
    // 생략
    return "account/searchResult";
}
```





### 5.7.3 미입력 처리

텍스트 필드에 값을 입력하지 않은 채로 HTML 폼을 전송하면 스프링 MVC는 폼 객체에 공백 문자를 설정한다. 그래서 **'미입력은 허용하지만 만약 입력이 되었다면 최소한 6자 이상일 것'**이라는 요구사항을 **Bean Validation**의 표준 애너테이션만으로는 충족시킬 수가 없다. 이런 경우에는 스프링에서 제공하는 **org.springframework.beans.propertyeditors.StringTrimmerEditor**를 사용하는 것을 고려하자. **StringTrimmerEditor**는 요청 파라미터 값을 **trim**하고 그 결과가 공백 문자인 경우에는 **null**로 변환시킨다.



- **StringTrimmerEditor를 적용한 예**

```java
@InitBinder
public void initBinder(WebDataBinder binder) {
	binder.registerCustomEditor(String.class, new StringTrimmerEditor(true));
    // 생성자 인수에 true(공백 문자를 null로 변환한다)를 지정하고 StringTrimmerEditor 인스턴스를 생성한 다음,
    // 이것을 WebDataBinder에 등록한다.
}
```





### 5.7.4 입력값 검사 규칙 지정

입력값 검사 규칙은 **Bean Validation**이 제공하는 제약 애너테이션으로 설정한다. 검사 규칙은 크게 다음 세 가지로 분류할 수 있다.

- **Bean Validation 표준 제약 애너테이션**
- **서드파티에서 구현한 제약 애너테이션(Hibernate Validator)**
- **직접 구현한 제약 애너테이션**



여기서는 **Bean Validator** 표준 제약 애너테이션(**javax.validation.constraints.***)을 중심으로 살펴보고, 서드파티가 구현한 제약 애너테이션 중 **Hibernate Validator**의 대표적인 애너테이션(**org.hibernate.validator.constraints.***)을 소개하겠다.





#### 필수 항목 검사

필수 항목 검사를 할 때는 **@NotNull**을 사용한다.



- **'null이 아닐 것'을 검사하는 애너테이션을 지정한 예**

```java
@NotNull    // null이 아닐 것
private String name;
```





> **Hibernate Validator**에는 문자열이 null이 아니고 trim한 길이가 0보다 크다는 것을 체크하는 **@NotBlank**가 마련돼 있다.



#### 자릿수(사이즈) 검사

글자 수나 컬렉션 등의 요소 개수를 검사할 때는 **@Size**를 이용한다.



| 속성명  | 설명                                                 |
| ------- | ---------------------------------------------------- |
| **min** | 허용 최솟값을 지정한다. (기본값은 0)                 |
| **max** | 허용 최댓값을 지정한다. (기본값은 Integer.MAX_VALUE) |



- **'지정한 사이즈 이내일 것'을 검사할 때 애너테이션을 지정한 예**

```java
@Size(max=50)    // 50자 이내일 것
private String name;
```



> **Hibernate Validator**에는 문자열이나 컬렉션, 맵, 배열 등이 null이 아니고 크기가 0 이상인지를 확인하는 **@NotEmpty**와 문자열 길이를 검사하는 **@Length**가 마련돼 있다.





#### 문자 유형 검사

문자 유형을 검사하는 경우에는 **@Pattern**을 사용한다.



| 속성명     | 설명                                  |
| ---------- | ------------------------------------- |
| **regexp** | 정규 표현식의 패턴 문자열을 지정한다. |
| **flags**  | 플래그(옵션)를 지정한다.              |



- **'영숫자일 것'을 검사할 때 애너테이션을 지정한 예**

```java
@Pattern(regexp="[a-zA-Z0-9]*") // 영숫자일 것
private String couponCode;
```



정규 표현식을 이용한 검사는 매우 강력하고 편리하지만 단점도 있다. 바로 입력값 검사 규칙(정규 표현식)이 여러 곳에 흩어져 버린다는 것이다. **Bean Validation**은 이 문제를 해결하기 위한 메커니즘을 제공한다. **Bean Validation**이 제공하는 해결 방법에 대해서는 뒤에 나올 5.7.6절 '**입력값 검사 규칙 추가**'의 **'기존 규칙 합성'**에서 설명한다.





> **Hibernate Validator**에는 
>
> 'RFC 2822'를 준수하는 이메일 주소일 것'을 검사하는 **@Email**, 
>
> 'RFC 2396를 준수하는 URL일 것'을 검사하는 **@URL**,
>
> '신용카드번호로 입력 오류가 없을 것'을 검사하는 **@CreditCardNumber**가 준비돼 있다.





#### 수치의 유효성 검사

수치의 유효성을 검사할 때는 폼 클래스의 프로퍼티를 숫자형(Integer, Long, BigDecimal 등)으로 정의한다. 스프링 MVC는 요청 파라미터 값을 폼 클래스의 프로퍼티형으로 변환하는 과정에서 오류가 발생하면 요청 파라미터 값이 부적절한 값이라고 판단한다. 한편 **PropertyEditor**와 **@NumberFormat**을 이용하면 값을 변환할 때 사용할 포맷을 지정할 수 있다.



> **@NumberFormat**은 입력값 검사를 수행하는 애너테이션이 아니라 어디까지나 포맷을 지정하는 애너테이션이다.





#### 수치의 범위 검사

수치의 범위(최솟값과 최댓값)를 검사할 때는 검사하려는 수를 얼마나 더 정밀하게 확인하느냐에 따라 사용할 애너테이션을 달리 써야 한다. **long** 타입의 정수를 검사할 때는 **@Min** 또는 **@Max**를 사용해도 되지만, **BigDecimal** 타입의 큰 수를 검사할 때는 **@DecimalMin**과 **@DecimalMax**를 써야 한다. 참고로 이 애너테이션들은 <u>검사 대상 값이 임곗값과 같을 경우</u> 검사하는 범위 내에 있다고 간주하고 허용치로 취급한다.



**공통 속성**

| 속성명    | 설명                                   |
| --------- | -------------------------------------- |
| **value** | 임곗값(최솟값 또는 최댓값)을 지정한다. |



**@DecimalMin과 @DecimalMax 속성**

| 속성명        | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| **inclusive** | 임곗값과 같은 값을 허용치로 볼지 지정한다. 생략한 경우 기본값은 true(허용치로 본다)다. |



- **'수치가 지정한 범위 내일 것'을 검사할 때 애너테이션을 지정한 예**

```java
@Min(1)
@Max(100)  // 1에서 100 사이일 것
private int quantity;
```



> **Hibernate Validator**에는 **@Min**과 **@Max**를 합성한 **@Range**를 사용할 수 있고, 이 **@Digits**를 이용하면 정수부와 소수부 자릿수를 지정해서 수치의 범위를 확인할 수 있다. **@Digits**에서는 정수부 자릿수를 지정하는 **integer** 속성과 소수부 자릿수를 지정하는 **fraction** 속성을 지정한다.
>
> 
>
> - **수치 범위(-99.99부터 99.99 범위의 값에서 0.01 단위일 것)을 검사할 때 애너테이션을 지정한 예**
>
> ```java
> @Digits(integer=2, fraction=2) // -99.99 ~ 99.99 이내일 것
> private BigDecimal rate;
> ```





#### 날짜/시간의 유효성 검사

날짜/시간의 유효성을 검사할 때는 폼 클래스의 프로퍼티를 날짜/시간 타입(**Date**나 **java.time.LocalDate** 등)으로 정의한다. 스프링 MVC는 프로퍼티의 타입과 포맷 정의를 참조해서 날짜/시간 타입으로 변환하는데, 이 과정에서 오류가 발생하면 입력된 값이 부적절하다고 판단한다. 한편 **PropertyEditor**와 **@DateTimeFormat**을 사용하면 값을 변환할 때 사용할 포맷을 지정할 수 있다.



> **@DateTimeFormat**은 입력값 검사를 수행하는 애너테이션이 아니라 어디까지나 포맷을 지정하는 애너테이션이다.



- **'과거 날짜일 것'을 검사할 때 애너테이션을 지정한 예**

```java
@Past   // 과거 날짜일 것
@DateTimeFormat(pattern = "yyyyMMdd")
private Date dateOfBirth;
```







#### 불린값 검사

지정한 불린값(**true** 또는 **false**)인지 검사할 때는 **@AssertTrue**와 **@AssertFalse**를 사용한다.



- **'불린값이 true일 것'을 검사할 때 애너테이션을 지정한 예(예: 이용약관에 동의)**

```java
@AssertTrue    // true일 것
private boolean isAgreedTermsOfUse;
```





#### 제약 애너테이션의 예약 속성

마지막으로 각 애너테이션이 가진 예약 속성을 소개하겠다.



| 속성명      | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| **message** | 제약을 위반할 때 표시되는 오류 메시지를 지정한다. 이 속성에는 메시지를 직접 지정하는 방법과 메시지 코드를 지정하는 방법이 있다. 속성 지정을 생략한 경우에는 기본 메시지가 사용된다. |
| **groups**  | 유효성 검증 그룹을 지정한다. 이 속성에는 그룹을 표현하는 자바 타입(인터페이스 또는 클래스)을 지정한다. 생략한 경우에는 **javax.validatoin.groups.Default**가 적용된다. |
| **payload** | 제약 애너테이션에 대해 임의의 메타 정보(예: 오류 중요도 등)를 지정한다. 이 속성에는 메타 정보를 나타내는 자바 타입(인터페이스 또는 클래스)을 지정한다. 스프링의 기본 구현에는 오류 정보와 관련된 메타 정보를 사용하지 않기 때문에 지정해도 의미가 없다. |





### 5.7.5 중첩된 자바빈즈의 입력값 검사

중첩된 자바빈즈와 자바빈즈의 컬렉션에서 정의한 프로퍼티에 대해 입력값 검사를 할 때는 **@Valid**를 지정한다. 참고로 **@Valid**는 검사 규칙을 표현하는 제약 애너테이션이 아니라 검사 대상임을 나타내는 **마커 애너테이션(Marker Annotation)**이다.



- **중첩된 자바빈즈를 검사 대상으로 할 때 애너테이션을 지정한 예**

```java
@Valid // 중첩된 자바빈즈도 검사 대상이 된다.
private AccountForm account;
```







### 5.7.6 입력값 검사 규칙 추가

실제로 애플리케이션을 개발할 때는 **Bean Validation**과 **Hibernate Validator**가 제공하는 제약 애너테이션 외에도 추가로 사용자가 정의한 입력값 검사 규칙을 추가해야 하는 경우가 있다.



사용자가 정의한 입력값 검사 규칙을 추가하는 방법으로는 **'기존 규칙을 조합해서 만드는 방법'**과 **'필요한 유효성 검사기를 직접 구현해서 만드는 방법'**의 두 가지가 있다.





#### 기존 규칙을 조합해서 만드는 방법

'영숫자 검사'와 같이 여러 곳에서 반복적으로 사용할 수 있는 범용적인 검사라면 폼 객체의 각 프로퍼티에 **@Pattern**을 지정하는 것보다 애당초 원하는 형태의 **@Pattern**을 메타 애너테이션으로 만들어 사용자가 정의한 커스터마이징된 제약 애너테이션을 사용하는 것이 좋다. 이렇게 자신만의 커스터마이징된 제약 애너테이션을 만들면 정규 표현식 패턴을 한 곳에서만 정의하면 되고 애너테이션 이름만 봐도 제약하는 내용을 직관적으로 이해할 수 있게 된다.



- **영숫자인지를 검사하는 사용자 정의 애너테이션을 이용하는 예**

```java
@AlphaNumeric // @Pattern이 아니라 독자적인 제약 애너테이션을 이용.
private String couponCode;
```



사용자가 정의한 애너테이션(**@AlphaNumeric**)은 다음과 같이 만든다.



- **기존 규칙을 조합한 제약 애너테이션을 만드는 예**

```java
import java.lang.annotaion.*;
import javax.validation.*;
import javax.validation.constraints.Pattern;
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Documented
@Constraint(validatedBy = {})
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@ReportAsSingleViolation
@Pattern(regexp = "[a-zA-Z0-9]*") // 영숫자일 것
public @interface AlphaNumeric {
    
    String message() default "{com.example.validation.AlphaNumeric.message}";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
    
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    public @interface List {
        AlphaNumeric[] value();
    }
}
```



> 이 예에서는 규칙을 하나만 사용하지만 기존 규칙을 여러 개 조합한 애너테이션을 만들 수 있다. 예를 들어, **@Size**와 **@Pattern**을 조합해서 **@ZipCode**와 **@TelephoneNumber** 같은 애너테이션을 만들 수 있다. 또한 기존 규칙을 조합한 애너테이션을 만들 때는 **@ReportAsSingleViolation**도 부여하는 것이 일반적이다. **@ReportAsSingleViolation**을 붙여주면 **message** 속성에서 지정한 메시지가 사용된다. 만약 **@ReportAsSingleViolation**을 붙여주지 않았다면 기존 규칙에 지정한 메시지가 사용된다.



#### 사용자 정의 유효성 검사기를 직접 구현해서 만드는 방법

**Bean Validation**은 상관관계 검사(여러 항목 간의 일관성을 검사)를 위한 제약 애너테이션을 제공하지 않는다. 그래서 상관관계 검사가 필요한 경우에는 사용자 정의로 유효성 검사기를 직접 만들어야 한다. 그 밖에도 기존 규칙의 조합만으로는 구현할 수 없는 입력값 검사 규칙이 있는 경우에도 사용자 정의로 유효성 검사기를 직접 만들어서 써야 한다.



여기서는 상관관계 검사를 구현하는 예로 '두 개의 프로퍼티 값이 같을 것'을 검사하는 입력값 검사 규칙을 만들어보자. 이 입력값 검사 규칙은 패스워드나 이메일을 설정할 때 두 개의 필드를 사용해 두 필드의 값이 일치하는지 확인할 때 사용할 수 있다.



- **제약 애너테이션(@EqualsPropertyValues) 작성 예**

```java
// 생략
@Documented
@Constraint(validatedBy = { EqualsPropertyValuesValidator.class }) 
// validatedBy 속성에 유효성 검사기의 구현 클래스를 지정한다.
@Target({ TYPE, ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface EqualsPropertyValues {
    
    String message() default "{com.example.validation.EqualsPropertyValues.message}";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
    
    String property();
    String comparingProperty();
    // 유효성 검사에 필요한 속성을 준비한다. 
    // 여기서는 '검사 대상 프로퍼티명(property)'과 '비교 대상 프로퍼티명(comparing Property)'을 준비하고 있다.
    
    @Target({ TYPE, ANNOTATION_TYPE })
    @Retention(RUNTIME)
    @Documented
    public @interface List {
        EqualsPropertyValues[] value();
    }
}
```



- **유효성 검사기 작성 예**

```java
import javax.validation.*;
import org.springframework.beans.*;
import org.springframework.util.*;

public class EqualsPropertyValuesValidator implements ConstraintValidator<EqualsPropertyValues, Object> {
    // ConstraintValidator 인터페이스를 구현한다. 첫 번째 타입 매개변수에 '제약 애너테이션'을, 
    // 두 번째 타입 매개변수에 '검사 대상 클래스'를 지정한다.
    
    private String property;
    private String comparingProperty;
    private String message;
    
    public void initialize(EqualsPropertyValues constraintAnnotation) {
        this.property = constraintAnnotation.property();
        this.comparingProperty = constraintAnnotaion.comparingProperty();
        this.message = constraintAnnotation.message();
    }
    // initialize 메서드에 유효성 검사기의 초기화 처리를 구현한다. 
    // 인수는 첫 번째 타입 매개변수에 지정한 제약 애너테이션이 된다.
    
    
    public boolean isValid(Object value, ConstraintValidatorContext context) {
    // isValid 메서드에 검증 처리를 구현한다. 첫 번째 인수는 두 번째 타입 매개변수에 지정한 검사 대상 클래스가 된다.
        
        // 두 개의 프로퍼티 값을 가져와서 비교
        BeanWrapper beanWrapper = new BeanWrapperImpl(value);
        Object propertyValue = beanWrapper.getPropertyValue(property);
        Object comparingPropertyValue = beanWrapper.getPropertyValue(comparingProperty);
        boolean matched = ObjectUtils.nullSafeEquals(propertyValue, comparingPropertyValue);
        
        if(matched) {
            return true;
        } else {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate(message)
                	.addPropertyNode(property).addConstraintViolation();
            return false;
        }
    }
}
```



사용자 정의 유효성 검사기를 구현했다면 다음은 상관관계를 검사하는 폼 클래스에 앞서 만들었던 제약 애너테이션을 지정한다.



- **두 개의 프로퍼티의 값이 같은지 검사하는 애너테이션을 지정한 예**

```java
// 클래스 수준의 제약을 애너테이션으로 지정
@EqualsPropertyValues(property="password", comparingProperty="reEnteredPassword")
public class AccountCreateForm implements Serializer {
	// 생략
	@NotNull
	@Password
	private String password;
	
	private String reEnteredPassword;
	// 생략
}
```



상관관계를 검사할 때는 클래스 레벨에 제약 애너테이션을 지정하는 것이 중요하다. 폼 클래스에 제약 애너테이션을 지정하면 유효성 검사기의 **isValid** 메서드에서 첫 번째 인수로 폼 객체를 받을 수 있다.





### 5.7.7 입력값 검사 규칙을 교체하는 방법

입력값 검사를 할 때 유효성 검증 그룹의 메커니즘을 활용하면 적용할 입력값 검사 규칙을 런타임에 동적으로 교체할 수 있다.



다음 예에서는 입력 화면에서 선택한 계정 유형이 무료 계정이나 유료 계정이냐에 따라 서로 다른 카드 번호 검사 규칙을 적용하고 있다.



![](https://docs.google.com/drawings/d/s4N3TEsteAlj1RvenANLhAw/image?parent=e/2PACX-1vSgWs9-SkKDVDplyC96i2vj5TuZvbmLHvACG_NMQ3eEa1hFtJwCGbFZVRaHriS3HOeS8O0XIQ6gqqII&rev=427&h=300&w=601&ac=1)





- **입력값 검사 처리에서 유효성 검증 그룹을 지정한 예**

```java
@RequestMapping(method=RequestMethod.POST, params={"confirm", "type=1"})
public String confirmForFreeAcount(
	@Validated(FreeAccount.class) AccountCreateForm form,
    BindingResult result, Model model) {    
    // 생략
}


@RequestMapping(method=RequestMethod.POST, params={"confirm", "type=2"})
public String confirmForPayAccount(
	@Validated(PayAccount.class) AccountCreateForm form,
    BindingResult result, Model model) {    
    // 생략
}

// 입력 화면에서 선택한 계정 유형(요청 파라미터의 type 값)별로 핸들러 메서드를 준비하고, 
// 폼 클래스에 해당하는 인수에 @Validated를 붙여준다.
// @Validated의 value 속성에는 계정 유형 별로 따로 만들어 둔 그룹 인터페이스를 지정한다.
```



다음으로 폼 클래스의 입력값 검사 규칙을 다음과 같이 지정한다.





- **폼 클래스에 입력값 검사 규칙을 적용한 예**

```java
public class AccountSearchForm implements Serializable {
    interface FreeAccount extends Default { }
    interface PayAccount extends Default { }
    // 그룹 인터페이스를 생성한다. 이 예에서는 무료 계정과 유료 계정의 두 개 그룹의 
    // 인터페이스를 만들고 있다. 그리고 이 그룹 인터페이스는 Bean Validation이 제공하는 
    // Default 인터페이스를 상속한다. 이 방법은 그룹 지정을 하지 않는 검사 규칙(이 예에서는
    // type 프로퍼티에 사용한 @Size)을 검사 대상에 포함시키고 싶을 때 유용하다.
    
    
   	// 생략
    @Size(min=1, max=1)
    private String type;
    
    @Size.List({ @Size(max=0, groups=FreeAccount.class),
               @Size(min=14, max=16, groups=PayAccount.class)
    })
    // 그룹마다 입력값 검사 룰을 지정한다. 이 예에서는 '무료 계정은 카드번호가 없을 것', 
    // '유료 계정은 14자리 이상 16자리 미만의 카드번호를 입력할 것'이라는 검사 규칙이 적용됐다.
    private String cardNo;
    
    // 생략
}
```





### 5.7.8 오류 정보 표시

바인딩 오류나 입력값 검사 오류가 발생하면 오류값과 오류 메시지를 입력 화면에 표시하는 것이 일반적이다.



뷰로 **JSP**를 사용할 때는 스프링 MVC에서 제공하는 JSP 태그 라이브러리를 통해 오류 정보를 손쉽게 화면에 표시할 수 있다. 이후 설명에서는 뷰로 **JSP**를 사용한다고 전제한다.



![](https://docs.google.com/drawings/d/st10y7qp-UHUR_8yfmczRlA/image?parent=e/2PACX-1vSgWs9-SkKDVDplyC96i2vj5TuZvbmLHvACG_NMQ3eEa1hFtJwCGbFZVRaHriS3HOeS8O0XIQ6gqqII&rev=302&h=324&w=601&ac=1)





#### 오류값 표시

사용자가 입력한 오류값은 **\<form:form>**이나 **\<form:input>** 등의 요소를 이용하면 자동으로 오류값이 표시된다. 그래서 이러한 태그 라이브러리를 사용한 개발자는 오류값을 표시하기 위한 처리를 따로 구현할 필요가 없다.



#### 항목마다 오류 메시지 표시

오류가 발생한 항목 가까이(옆이나 아래 등)에 오류 메시지를 표시하려면 **\<form:errors>** 요소의 **path** 속성에 프로퍼티명을 지정하면 된다.



- **항목마다 오류 메시지를 표시할 때의 구현 예**

```jsp
이름:<form:input path="name" />
	<form:errors path="name" />  -> path 속성에 프로퍼티명을 지정한다. 지정한 프로퍼티의 오류 메시지만 HTML에 출력된다.
	
```





#### 모든 오류 메시지를 한 번에 표시

페이지 상단과 같이 메시지를 표시하기 위해 준비된 영역에 모든 오류 메시지를 한번에 표시하고 싶다면 **\<form:errors>** 요소의 **path** 속성에 '*'를 지정하면 된다.



- **모든 메시지를 한 번에 표시할 때의 구현 예**

```jsp
<div id="messages">
	<form:errors path="*"/>
</div>
```



> 모든 오류 메시지를 한 번에 표시할 때, 스프링의 기본 구현을 그대로 이용하면 메시지가 표시되는 순서를 보장할 수 없다. 실행 시점에 따라 오류 메시지의 표시 순서가 바뀔 수도 있다는 점을 주의하자.





### 5.7.9 오류 메시지의 재정의

바인딩 오류나 입력값 검사 오류가 발생할 때 화면에 표시되는 오류 메시지는 서드파티 프로바이더가 구현 클래스로 제공한 메시지다. **Hiberbate Validator**를 사용할 때 표시되는 메시지는 모든 국가의 언어를 지원하는 것은 아니기 때문에 원하는 언어가 표시되지 않을 수 있다. 또한 기본적으로 제공되는 영어 메시지도 표현이 너무 간단해서 그대로 사용하는 경우는 거의 없을 것이다. 여기서는 기본적으로 제공되는 메시지를 변경하는 방법을 설명한다.



#### 오류 메시지를 정의하는 방법

스프링과 **Bean Validator**을 조합하는 경우 오류 메시지는 다음과 같은 세 가지 방법으로 정의할 수 있다.

- **MessageSource에서 사용하는 프로퍼티 파일에 메시지를 정의한다.**
- **Bean Validator에서 사용하는 프로퍼티 파일에 메시지를 정의한다.**
- **제약 애너테이션의 message 속성에 메시지를 정의한다.**



스프링의 기본 구현에서는 먼저 **MessageSource**에서 메시지를 가져오려고 하는데 만약 **MessageSource**에서 원하는 메시지를 찾을 수 없다면 이번에는 **Bean Validator**이 관리하는 메시지 중에서 자신이 찾는 메시지가 있는지 확인한다.



![](https://docs.google.com/drawings/d/sU7GC2JQrkBk_qYKUopbGzQ/image?parent=e/2PACX-1vSgWs9-SkKDVDplyC96i2vj5TuZvbmLHvACG_NMQ3eEa1hFtJwCGbFZVRaHriS3HOeS8O0XIQ6gqqII&rev=459&h=372&w=601&ac=1)



#### MessageSource에서 사용하는 프로퍼티 파일에 오류 메시지를 정의

스프링에서 기본적으로 제공하는 **MessageSource**에서 메시지를 정의할 수 있다.



- **메시지 정의 예**

```properties
NotNull= 값을 입력해 주세요.
```

프로퍼티 키에 메시지 코드, 프로퍼티 값에 메시지를 지정한다. 이 예에서는 **@NotNull**에 대한 오류 메시지가 정의돼 있다.





이때 사용되는 메시지 코드는 스프링이 제공하는 **org.springframework.validation.MessageCodesResolver**의 구현 클래스에 따라 메시지 코드의 명명법이 달라질 수 있다. 만약 기본 구현 클래스인 **DefaultMessageCodesResolver**를 사용한다면 다음과 같은 명명법을 따른다.

- **제약 애너테이션의 클래스명 + '.' + 폼 객체의 속성명 + '.' + 프로퍼티명**
- **제약 애너테이션의 클래스명 + '.' + 폼 객체의 속성명**
- **제약 애너테이션의 클래스명 + '.' + 프로퍼티명**
- **제약 애너테이션의 클래스명 + '.' + 프로퍼티 타입명(FQCN)**
- **제약 애너테이션의 클래스명**



> 형 변환 오류(바인딩 오류)에 대한 메시지는 '제약 애너테이션의 클래스명' 부분이 'typeMismatch'로 대체된다.



- **다양한 메시지 코드를 사용해 메시지를 정의한 예**

```properties
# 입력값 검사 오류에 대한 메시지를 정의한 예
NotNull.accountForm.name = 계정 등록자의 성을 입력해 주세요.
NotNull.name = 이름을 입력해 주세요.
NotNull.java.lang.String = 문자열을 입력해 주세요.
NotNull = 값을 입력해 주세요.
```



오류 메시지에는 **java.text.MessageFormat**의 메시지 포맷을 사용할 수 있다. 메시지 포맷에는 플레이스홀더를 지정할 수 있는데, 여기에 프로퍼티명과 제약 애너테이션의 속성값이 들어가도록 만들 수 있다.



- **오류 메시지를 정의한 예**

```properties
Size = {0}은 {2}문자 이상, {1}문자 이하로 입력해 주세요.
```



플레이스홀더에 들어갈 값은 다음과 같다.

- **{0}**: 프로퍼티명(물리명 또는 논리명)
- **{1}**: 이후: 제약 애너테이션의 속성값(인덱스 위치는 애너테이션 속성명의 알파벳 순서임)



**@Size**를 예로 들면 메시지 가변부에는 다음과 같은 값이 들어간다. 여기서 중요한 것은 인덱스 위치가 '속성의 정의 순서가 아니라 알파벳 순서'라는 것이다.

- **{0}**: 프로퍼티명(물리명 또는 논리명)
- **{1}**: max 속성값
- **{2}**: min 속성값





#### Bean Validation에서 사용하는 프로퍼티 파일에 오류 메시지를 정의

**Bean Validation**에서 사용하는 프로퍼티 파일에 기본 오류 메시지를 정의할 때는 classpath 바로 아래의 **ValidationMessages.properties**에 메시지를 정의한다.



- **메시지를 정의한 예**

```properties
javax.validation.constraints.NotNull.message = 입력해 주세요.
// 프로퍼티 키에 메시지 코드를, 프로퍼티 값에 오류 메시지를 지정한다. 
// 기본 메시지 코드는 '제약 애너테이션 클래스명(FQCN) + .message'다.
javax.validation.constraints.Size.message = {0}은 {min} 문자 이상, {max} 문자 이하로 입력해 주세요.
// 제약 애너테이션의 속성값을 포함하고 싶다면 포함하고 싶은 위치에 플레이스홀더({제약 애너테이션의 속성명})를 지정하면 된다.
```



> **{0}**을 지정하면 프로퍼티명(물리명 또는 논리명)을 표시할 수 있는데, 사실 이 기능은 Bean Validation이 제공하는 것이 아니라 스프링이 기본적으로 제공하는 기능을 활용하는 것이다.



기본적으로 적용되는 메시지 코드는 제약 애너테이션의 **message** 속성에서 임의의 다른 메시지 코드로 변경할 수도 있다.



- **기본 적용되는 메시지 코드를 변경한 예**

```java
@NotNull(message = "{validation.erros.required}") // 제약 애너테이션의 message 속성에 에러 메시지를 지정한다.
private String name;
```







#### 제약 애너테이션의 message 속성에 메시지를 정의

오류 메시지는 제약 애너테이션의 **message** 속성에 직접 지정할 수 있다.



- **오류 메시지를 message 속성에 직접 지정한 예**

```java
@NotNull(message = "입력해 주세요")
private String name;
```







#### 프로퍼티명의 논리명 정의

메시지에 프로퍼티명을 포함하려면 **{0}**을 지정하면 되는데, 기본적으로는 프로퍼티의 물리명이 사용된다. 이것을 논리명으로 표시되게 하려면 스프링이 사용하는 프로퍼티 파일에 물리명과 논리명을 함께 정의해서 매핑하면 된다.



매핑할 때 사용할 수 있는 **키 이름**은 다음과 같다.

1. **폼 객체의 속성명 + '.' + 프로퍼티명**
2. **프로퍼티명**



- **프로퍼티명의 물리명과 논리명을 매핑한 예**

```properties
accountForm.name = 계정명
name = 이름
```





### 5.7.10 Bean Validation의 커스터마이징

스프링 MVC를 설정할 때 **@EnableWebMvc**와 **\<mvc:annotation-driven>** 요소를 사용하면 **Bean Validation**에서 사용하는 **javax.validation.Validator** 인터페이스의 구현 클래스가 자동으로 적용된다. 이때 실제로 적용되는 클래스는 **org.springframework.validation.beanvalidation.OptionalValidatorFactoryBean**이다. **OptionalValidatorFactoryBean**은 **Bean Validation**의 사양을 구현한 서드파티(Hibernate Validator 등)와의 어댑터 역할을 한다. 그래서 실제로 유효성 검사를 위임받아 처리하는 것은 서드파티가 구현한 **Validator** 클래스다.



스프링 MVC에 적용되는 **Bean Validation** 기능을 커스터마이징하고 싶다면 **OptionalValidatorFactoryBean**이나 **LocalValidatorFactoryBean**과 같은 빈을 명시적으로 정의하는 방법으로 스프링 MVC가 사용하는 Validator를 교체하면 된다.





- **자바 기반 설정 방식을 이용해 빈을 정의한 예**

```java
// 생략
@Configuration
public class WebMvcConfig extends WebMvcConfigurerAdapter {
	// 생략
	@Bean
	OptionalValidatorFactoryBean validator() {    // 커스터마이즈할 Validator를 DI 컨테이너에 등록한다.
		OptionalValidatorFactoryBean validator = new OptionalValidatorFactoryBean();
		// 설정자 메서드를 이용해 커스터마이징한다.
		return validator;
	}
	
	@Override  // getValidator 메서드를 오버라이드한다. 위에서 커스터마이징한 Validator를 반환하고 스프링 MVC가 기본적으로 이용하는 Validator를 교체한다.
	public Validator getValidator() {
		return validator();
	}
}
```





- **XML을 이용해 빈을 정의한 예**

```xml
<bean id="validator"     <!-- 커스터마이즈할 Validator를 DI 컨테이너에 등록한다. -->
      class="org.springframework.validation.beanvalidation.OptionalValidatorFactoryBean">
	<!-- 세터 인젝션을 이용해 커스터마이징한다. -->
</bean>
<mvc:annotation-driven validator="validator" />
<!-- <mvc:annotation-driven> 요소의 validator 속성에 위에서 커스터마이징한 Validator의 빈 이름을 지정하고 
스프링 MVC가 기본적으로 이용하는 Validator를 교체한다. -->
```







### 5.7.11 Spring Validator 이용

마지막으로 스프링 프레임워크 3.0.0 이전 버전부터 존재하는 **Spring Validator** 인터페이스의 사용법을 소개한다. **Spring Validator**의 핵심이 되는 인터페이스는 **org.springframework.validation.Validator**와 **org.springframework.validation.SmartValidator**다.



- **Validator 인터페이스**

```java
public interface Validator {
	boolean supports(Class<?> clazz);
	void validate(Object target, Errors errors);
}
```



**Validator 인터페이스의 메서드**

| 메서드명     | 설명                                                         |
| ------------ | ------------------------------------------------------------ |
| **supports** | 인수에 전달된 클래스가 검사 대상인지 판단한다. 검사 대상이라면 **true**를 반환한다. **true**를 반환하면 **validate** 메서드가 호출된다. |
| **validate** | 인수에 전달된 객체의 상태를 검사한다.                        |



- **SmartValidator 인터페이스**

| 메서드명     | 설명                                                         |
| ------------ | ------------------------------------------------------------ |
| **validate** | 인수로 전달된 객체의 상태를 검사한다. 인수의 **validationHints**에는 **@Validate**의 **value** 속성에 지정한 그룹 인터페이스가 전달된다. |



이 책에서는 이 두가지 인터페이스를 이용한 '**상관 항목 검사 구현 예**'와 '**Spring Validator**를 통해 **Bean Validation** 기능을 사용하는 방법'을 소개한다.





#### Spring Validator를 이용한 상관관계 검사의 구현 예

**Spring Validator** 인터페이스는 특정 자바빈즈에 대한 상관관계 검사를 구현하기 쉽게 만드는 인터페이스다. **Bean Validation**의 **ConstraintValidator** 인터페이스도 같은 역할을 할 수 있지만, 제약 애너테이션도 함께 만들어야 하기 때문에 **Spring Validator**에 비해 구현할 때 손이 더 많이 가는 단점이 있다.



- **Spring Validator를 이용한 연관 항목 검사의 구현 예**

```java
@Component
public class AccountCreateFormValidator implements Validator {
	@Override
	public boolean supports(Class<?> clazz) { 
    // 검사 대상 클래스인지 확인한다. 이 예에서는 AccountCreateForm 클래스와 이를 상속한 클래스가 검사 대상이다.
		return AccountCreateForm.class.isAssignableFrom(clazz);
	}
    
    @Override
    public void validate(Object target, Errors errors) {
    // 상관관계에 있는 항목을 검사할 준비를 한다. Bean Validation과 같은 다른 Validator에서 오류가 발생했는지를
    // errors 인수로 확인할 수 있다.
        if(errors.hasFieldErrors("type")) {
        // 단일 항목에 대한 검사 결과를 확인한다. 이 예에서는 단일 항목 검사에서 오류가 확인되면 다른 확인은 하지 않는다.
            return;
        }
        AccountCreateForm form = AccountCreateForm.class.cast(target);
        // 상관관계에 있는 항목을 검사한다. 이 예에서는 회원 유형에 따라 카드번호 검사 방법을 다르게 적용한다.
        if("1".equals(form.getType())) {
            // 일반 회원의 경우
            if(StringUtils.hasLength(form.getCardNo())) {
                errors.rejectValue("cardNo", "Size");
            }
        } else {
            // 프리미엄 회원의 경우
            if(form.getCardNo() == null || form.getCardNo().length() < 14 
              		|| form.getCardNo.length() > 16) {
                errors.rejectValue("cardNo", "Size", new Object[] {14, 16}, null);
            }
        }
    }
}
```



이렇게 만든 **Spring Validator** 구현 클래스는 **@InitBinder** 메서드를 이용해 스프링 MVC에 적용한다.



- **Spring Validator를 스프링 MVC에 적용한 예**

```java
@Autowired   
AccountCreateFormValidator accountCreateFormValidator;  // 작성한 Validator를 인젝션한다.

@InitBinder
public void initBinder(WebDataBinder binder) {
	binder.addValidators(accountCreateFormValidator);   // 작성한 Validator를 WebDataBinder에 추가한다.
}
```



**WebDataBinder**에 **Spring Validator** 구현 클래스를 추가하면 **Bean Validation**에 의한 입력값 검사를 먼저 수행한 후 **WebDataBinder**에 추가된 **Spring Validator** 메서드가 호출되는 방식으로 동작한다.









#### Spring Validator를 통해 Bean Validation 기능을 이용하는 방법

스프링이 제공하는 **OptionalValidatorFactoryBean**과 **LocalValidatorFactoryBean**은 사실 **SmartValidator** 인터페이스도 구현하고 있다. 그래서 **Spring Validator** 메서드를 통해 **Bean Validation**의 기능을 이용할 수 있다. 기본적으로 **@Validated**를 이용한 선언 기반의 입력값 검사를 권장하지만, **@Validated**에서 표현할 수 없는(또는 표현하기 어려운) 입력값 검사의 요구사항이 있는 경우에는 **Spring Validator** 메서드를 직접 호출하는 방식을 고려해볼 수 있다.



**Spring Validator** 메서드를 직접 호출하려면 DI 컨테이너에 등록된 **Spring Validator**의 빈을 인젝션하고 **Spring Validator**의 **validate** 메서드를 호출하면 된다. 한편 **Spring Validator** 인터페이스를 구현한 빈이 DI 컨테이너 상에 여러 개 존재하는 경우에는 **@Autowired**와 **@Qualifier**를 병용해서 **@OptionalValidatorFactoryBean**과 **LocalValidatorFactoryBean**의 빈이 인젝션되도록 설정해야 한다.



- **SmartValidator 메서드를 이용하는 예**

```java
@Autowired
SmartValidator validator;  // Spring Validator를 인젝션한다.
// 생략
@RequestMapping(method=RequestMethod.POST, params="confirm")
public String confirm(AccountCreateForm form, // @Validated는 지정하지 않음
                     BindingResult result, Model model) {
    Class<?> validationGroup = null;
    // validationGroup을 결정하는 로직의 구현
    // 생략
    validator.validate(form, result, validationGroup);
    if(result.hasErrors()) {
        return "account/form";
    }
    
    // 생략
    return "account/confirm";
}
```





## 5.8 화면 이동

화면 이동을 하려면 이동 대상을 지정하는 방법은 물론이고 이동 대상과 데이터를 연계하는 방법을 이해하고 있어야 한다. 먼저 이동 대상을 지정하는 방법을 살펴보자.



### 5.8.1 이동 대상을 지정하는 방법

이동 대상을 지정할 때는 **핸들러의 메서드**가 **뷰 이름**(이동 대상에 할당된 논리적인 이름)을 반환하도록 만들면 된다. 일단 뷰 이름을 반환하면 스프링 MVC가 **ViewResolver**를 통해 논리적인 뷰 이름과 연결된 물리적인 뷰(예: **JSP**)가 어떤 것인지 판단하게 된다.



- **뷰 이름을 문자열로 반환하는 구현 예**

```java
@Controller
public class WelcomeController {
	
	@RequestMapping("/")
	public String home() {
		return "home";  // 핸들러 메서드의 반환값으로 뷰 이름을 반환한다.
	}
}
```



예를 들어, **JSP**용 **ViewResolver**를 기본 상태로 적용하면 웹 애플리케이션 안에 있는 **/WEB-INF/home.jsp**가 호출되고 **/WEB-INF/home.jsp**에서 생성한 HTML이 브라우저에 그려진다.





### 5.8.2 요청 경로로 리다이렉트

다음 이동 대상이 리다이렉트해야 할 요청 경로라면 뷰 이름에 '**redirect: + 리다이렉트할 요청 경로**'를 지정한다.



- **리다이렉트할 뷰 이름을 지정하는 예**

```java
@Controller
public class WelcomeController {

	@RequestMapping("/")
	public String home() {
		return "redirect:/menu"; // 리다이렉트로 이동 대상의 요청 경로를 지정
	}
}
```





#### 요청 파라미터 지정

리다이렉트를 사용할 때 다음 이동 대상에 요청 파라미터를 전달해야 한다면 **org.springframework.web.servlet.mvc.support.RedirectAttributes**에 파라미터를 지정하면 된다.



- **RedirectAttributes에 요청 파라미터를 저장하는 구현 예**

```java
@RequestMapping(path="create", method=RequestMethod.POST)
public String create(@Validated AccountCreateForm form,
                    BindingResult result, RedirectAttributes redirectAttributes) {
    // 생략
    redirectAttributes.addAttribute("accountId", createdAccount.getAccountId());
    // RedirectAttributes의 addAttribute 메서드를 호출해서 요청 파라미터를 지정한다.
    // 이 예에서는 리다이렉트할 때의 URL이 '/account/create?complete&accountId=A0001'과 같은 형식으로 만들어진다.
    return "redirect:/account/create?complete";
}
```





#### 경로 변수 지정

리다이렉트할 URL을 동적으로 만들어야 할 때는 URL에 경로 변수를 추가하고, 경로 변수에 들어갈 값을 **RedirectAttributes**에 저장하면 된다.



- **리다이렉트 대상의 URL을 동적으로 조합하는 구현 예**

```java
@RequestMapping(path="create", method=RequestMethod.POST)
public String create(@Validated AccountCreateForm form,
                    BindingResult result, RedirectAttributes redirectAttributes) {
    // 생략
    redirectAttributes.addAttribute("accountId", createdAccount.getAccountId());
    // RedirectAttributes의 addAttribute 메서드를 호출해서 경로 변수에 들어갈 값을 저장한다.
    return "redirect:/account/{accountId}?createComplete";
    // 리다이렉트할 URL에 경로 변수를 추가한다. 이 예에서는 URL에서 {accountId} 부분이 경로 변수에 해당하고, 
    // 리다이렉트할 때의 URL은 '/account/A0001?createComplete'과 같은 형식으로 만들어진다.
}
```





> 리다이렉트할 곳으로 요청 파라미터를 연계하는 경우나 리다이렉트할 URL을 동적으로 만들 때는 반드시 **RedirectAttributes**의 **addAttribute** 메서드를 사용하자. 다음 예와 같이 프로그램에서 조합한 값을 뷰 이름으로 반환해 버리면 뷰 객체를 캐시하는 메커니즘을 효율적으로 사용할 수 없기 때문이다.
>
> 
>
> **뷰의 캐시 구조를 효율적으로 활용할 수 없는 구현 예**
>
> ```java
> return "redirect:/account/create?complete&accountId=" + createdAccount.getAccountId();
> // 또는
> return "redirect:/account/" + createdAccount.getAccountId() + "?createComplete";
> ```
>
> 
>
> 한편 **addAttribute** 메서드를 사용하면 요청 파라미터와 경로 변수 값이 자동으로 URL 인코딩되는 장점도 있다.





### 5.8.3 요청 경로로 포워드

다음 이동 대상이 리다이렉트해야 할 요청 경로라면 뷰 이름에 '**forward: + 전송 대상의 요청 경로**'를 지정한다.



**포워드할 때의 뷰 이름을 지정하는 예**

```java
@Controller
@RequestMapping("auth")
public class AuthController {
    @RequestMapping("login")
    public String login(@Validated LoginForm form, BindingResult result) {
        if(result.hasErrors()) {
            return "auth/loginForm";
        }
        return "forward:/auth/authenticate";    // 이동 대상의 경로를 지정
    }
}
```



### 5.8.4 뷰와의 데이터 연계

뷰 처리에 필요한 데이터(자바 객체)는 **Model**에 저장해야 연계가 된다. **Model**에 자바 객체를 저장하면 스프링 MVC가 뷰에서 접근할 수 있는 영역(**JSP**라면 **HttpServletRequest**)에 자바 객체를 **export**해준다.



자바 객체를 **Model**에 저장하는 방법은 다음의 두 가지가 있다.

- **Model API를 직접 호출한다.**
- **ModelAttribute 애너테이션이 붙은 메서드를 준비한다.**



#### 스코프

**Model**에 저장하는 객체는 **요청 스코프, 플래시 스코프, 세션 스코프** 중 하나의 스코프에서 관리된다. **Model**에서 저장하는 객체의 스코프에 대한 자세한 내용은 5.6.1절 '폼 객체 스코프'를 참고하자.





#### Model API를 사용해 Model을 저장하는 방법

**Model**의 **addAttribute** 메서드를 사용해 자바 객체를 **Model**에 저장한다.



- **Model API를 명시적으로 호출하는 구현 예**

```java
@RequestMapping("{accountId}")
public String detail(@PathVariable String accountId, Model model) {
	Account account = accountService.findOne(accountId);
	model.addAttribute(account);  // 명시적으로 추가
	return "account/detail";
}
```



> **Model** 객체를 추가할 때 속성명을 생략하면 클래스명을 자바빈즈 프로퍼티의 명명 규칙에 따라 변환한 이름으로 속성명이 만들어진다. 예를 들어, 추가한 객체의 클래스명이 **com.myapp.Product**라면 **product**가 속성명이 된다. 마찬가지로 **com.myapp.MyProduct**라면 **myProduct**, **com.myapp.UKProduct**라면 **UKProduct**가 속성명이 된다.
>
> 속성명을 만들 때는 **org.springframework.core.Conventions** 클래스의 **getVariableName(Object)** 메서드가 사용된다. 자세한 변환 원리를 알고 싶다면 **Convetions** 클래스의 소스코드를 참조하자.





#### @ModelAttribute를 사용해 Model을 저장하는 방법

**ModelAttribute** 애너테이션을 붙인 메서드를 이용하면 자바 객체를 **Model**에 저장할 수 있다.



- **ModelAttribute 애너테이션을 붙인 메서드를 준비하는 구현 예**

```java
@ModelAttribute // 메서드 반환값을 Model에 추가
public Account setUpAccount(@PathVariable String accountId) {
    return accountService.findOne(accountId);
}

@RequestMapping("{accountId}")
public String detail() {
    return "account/detail";
}
```



**@ModelAttribute**를 붙인 메서드를 준비해 두면 핸들러 메서드가 호출되기 전에 먼저 실행되고, 그 결과 반환된 객체가 **Model**에 저장된다. **Model**에 추가할 때의 속성명은 **@ModelAttribute**의 **value** 속성으로 지정할 수 있으며, 생략한 경우에는 기본 속성명이 적용된다.





#### 뷰에서 접근

**뷰**(여기서는 JSP)에서 **Model**에 저장한 자바 객체에 접근할 때는 다음과 같이 구현한다.



- **JSP에서 모델이 저장한 자바 객체에 접근하는 예**

```jsp
성명 : <c:out value="${account.name}" />
```

요청 스코프에 저장돼 있는 자바 객체에 접근한다. 이 예에서는 EL을 사용해 **account**라는 속성명으로 저장된 자바빈즈에서 **name** 프로퍼티의 값을 가져오고 있다.







### 5.8.5 리다이렉트 대상과의 데이터 연계

화면을 이동할 때 리다이렉트 방식으로 핸들러나 뷰에 도달하게 되면 리다이렉트 전의 정보를 참조하지 못한다. 이런 경우에는 리다이렉트하기 전에 리다이렉트될 **컨트롤러**나 **뷰**에서 사용할 데이터를 **org.springframework.web.servlet.mvc.support.RedirectAttributes**에 저장하면 된다. 그러면 **RedirectAttributes**에 저장된 객체가 **플래시 스코프**에 관리되고, 리다이렉트된 후의 **GET** 요청 과정에서 **Model**에 저장한 값이 **export**된다.



- **RedirectAttributes에 자바 객체를 저장**

```java
@RequestMapping(path="create", method=RequestMethod.POST)
public String create(@Validated AccountCreateForm form, BindingResult result,
                    RedirectAttributes redirectAttributes) {
    Account createdAccount = accountService.create(...);
    redirectAttributes.addFlashAttribute(createdAccount);
    // RedirectAttributes의 addFlashAttribute 메서드를 호출해서 자바 객체를 RedirectAttributes(플래시 스코프)에 저장한다. RedirectAttributes에 추가할 때 속성명은 생략할 수 있으며, 생략한 경우 기본 속성명이 적용된다.
    return "redirect:/account/create?complete";
}

@RequestMapping(path="create", method=RequestMethod.GET, params="complete")
public String createComplete() {  
// 이 메서드가 호출되기 전에 위에서 추가한 자바 객체가 플래시 스코프에서 Model에 export되기 때문에 이동 대상의 뷰에서 요청 스코프에 저장된 자바 객체를 사용할 수 있다.
    return "account/createComplete";
}
```



> **RedirectAttributes**에는 **addAttribute**라는 메서드가 있다. 이 메서드는 리다이렉트 대상에 요청 파라미터와 경로 변수 값을 전달할 때 사용하는 메서드다. **addAttribute**의 사용법은 5.8.2절 '요청 경로로 리다이렉트'에서 설명한다.





## 5.9 뷰 선택

**뷰**는 **Model**에 저장된 자바 객체를 참조해서 클라이언트에 반환할 응답 데이터를 만드는 컴포넌트다. 스프링 MVC에서는 **뷰**를 **org.springframework.web.servlet.View** 인터페이스로 표현하는데, 실제로 사용할 **View** 클래스는 **org.springframework.web.servlet.ViewResolver** 인터페이스의 구현 클래스에 의해 결정된다.





![](https://docs.google.com/drawings/d/s-EoBV1QDqoIiLq9-N2B3Qg/image?parent=e/2PACX-1vSgWs9-SkKDVDplyC96i2vj5TuZvbmLHvACG_NMQ3eEa1hFtJwCGbFZVRaHriS3HOeS8O0XIQ6gqqII&rev=527&h=402&w=601&ac=1)





**ViewResolver**는 여러 개를 정의할 수 있는데, 우선순위가 높은 것부터 차례대로 호출되다가 가장 먼저 선택된 뷰를 사용하도록 돼 있다.



### 5.9.1 템플릿 기반 뷰

먼저 스프링 MVC가 지원하는 대표적인 템플릿 기반 뷰 클래스와 **ViewResolver** 클래스를 살펴보자. 스프링 VMC는 다양한 **View** 클래스를 제공하며, **JSP** 이외의 템플릿 엔진도 사용할 수 있다.



**템플릿 기반 View 클래스**

| 클래스명                 | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| **InternalResourceView** | JSP를 이용할 때 사용하는 View 클래스                         |
| **JstlView**             | JSP + JSTL을 이용할 때 사용하는 View 클래스                  |
| **TilesView**            | 레이아웃 엔진으로 Apache Tiles, 템플릿 엔진으로 JSP를 이용할 때 사용하는 View 클래스 |
| **FreeMarkerView**       | FreeMarker를 이용할 때 사용하는 View 클래스                  |
| **GroovyMarkupView**     | Groovy Markup Template Engine을 이용할 때 사용하는 View 클래스 |
| **ScriptTemplateView**   | JSR 223 script engine 통해 자바스크립트 라이브러리(Handlebars.js, Mustache.js, React.js, EJS 등)의 템플릿 엔진을 이용할 때 사용하는 View 클래스 |



**템플릿 기반 ViewResolver 클래스**

| 클래스명                         | 설명                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| **InternalResourceViewResolver** | JSP를 이용할 때 사용하는 ViewResolver 클래스                 |
| **TilesViewResolver**            | 레이아웃 엔진으로 Apache Tiles, 템플릿 엔진으로 JSP를 이용할 때 사용하는 ViewResolver 클래스 |
| **FreeMarkerViewResolver**       | FreeMarker를 이용할 때 사용하는 ViewResolver 클래스          |
| **GroovyMarkupViewResolver**     | Groovy Markup Template Engine을 이용할 때 사용하는 ViewResolver 클래스 |
| **ScriptTemplateViewResolver**   | JSR 223 script engine 통해 자바스크립트 라이브러리(Handlebars.js, Mustache.js, React.js, EJS 등)의 템플릿 엔진을 이용할 때 사용하는 ViewResolver 클래스 |





### 5.9.2 InternalResourceViewResolver의 빈 정의

스프링 MVC는 다양한 **View** 클래스를 제공하지만 여기서는 **JSP**를 이용해 뷰를 구현하는 방법을 설명한다.



> 최근 서드파티 템플릿 엔진으로 주목받는 것이 **타임리프(Thymeleaf)**다. 이 책에서 소개하는 스프링 부트에서는 JSP 사용을 권장하지 않으며, 타임리프와 같이 서블릿 컨테이너에 의존하지 않는 템플릿 엔진을 사용하길 권장하고 있다. 이 책에서도 스프링 MVC와 타임리프를 조합해서 사용하는 방법을 12장에서 설명한다.



**JSP**를 이용해 뷰를 구현할 때는 **InternalResourceViewResolver**를 사용한다.



- **자바 기반 설정 방식을 이용한 빈 정의**

```java
@Override
public void configureViewResolvers(ViewResolverRegistry registry) {
	registry.jsp();
    // ViewResolverRegistry의 jsp 메서드를 호출한다. InternalResourceViewResolver가 생성되어 
    // prefix 프로퍼티에 '/WEB-INF', suffix 프로퍼티에 '.jsp'가 설정된다.
}
```



- **XML 기반 설정 방식을 이용한 빈 정의**

```xml
<mvc:view-resolvers>
	<mvc:jsp />  
    <!-- <mvc:jsp> 요소를 정의한다. InternalResourceViewResolver가 생성되어 
	     prefix 프로퍼티에 '/WEB-INF', suffix 프로퍼티에 '.jsp'가 설정된다. -->
</mvc:view-resolvers>
```



> **JSP 파일의 저장 위치**를 변경하려면 **InternalResourceViewResolver**의 **prefix** 프로퍼티 값을 변경한다. 다음은 JSP 파일의 저장 위치를 '**/WEB-INF/views/**'로 변경할 때 빈을 정의하는 예다.
>
> 
>
> **자바 기반 설정 방식을 이용한 빈 정의**
>
> ```java
> @Override
> public void configureViewResolvers(ViewResolverRegistry registry) {
>     registry.jsp().prefix("/WEB-INF/views/");
> }
> ```
>
> 
>
> **XML 기반 설정 방식을 이용한 빈 정의**
>
> ```xml
> <mvc:view-resolvers>
> 	<mvc:jsp prefix="/WEB-INF/views/" />
> </mvc:view-resolvers>
> ```





## 5.10 JSP 구현

여기서는 **JSP**를 이용해 뷰를 구현하는 방법을 설명하겠다.



(생략)



## 5.11 스프링 HTML 폼 전용 태그 라이브러리의 활용



(생략)



## 5.12 스프링 범용 태그 라이브러리의 활용

스프링 MVC는 JSP 구현을 지원하기 위한 범용 태그 라이브러리를 제공한다.

(생략)



## 5.13 예외 처리

예외 처리는 애플리케이션을 개발할 때 빼놓을 수 없는 중요한 요소 중 하나다. 여기서는 웹 애플리케이션에서 발생할 수 있는 예외 처리 방법에 대해서 설명한다.



### 5.13.1 예외의 종류

예외 처리 방법을 설명하기 전에 웹 애플리케이션에서 발생할 수 있는 예외를 정리해 두자.



웹 애플리케이션에서 발생하는 예외는 크게 다음의 세 가지로 분류된다. 애플리케이션 개발자는 이 예외에 대해 적절하게 오류 처리를 할 수 있어야 한다.

- **시스템 예외**

  **처리를 계속할 수 없는 예외**(애플리케이션 자체의 버그, 의존 라이브러리의 버그, 미들웨어 및 하드웨어의 고장, 시스템 리소스의 고갈, 네트워크 장애 등)는 **시스템 예외**로 분류된다. 시스템 예외가 발생한 경우에는 시스템 사용자에게 시스템 오류 화면을 표시하고 시스템 운영자에게는 시스템 장애가 발생했다는 것을 알릴 수 있도록 구현해야 한다.



- **잘못된 요청 예외**

  **잘못된 요청으로 발생하는 예외**(존재하지 않는 경로의 요청, 바인딩 오류, 입력값 검사 오류 등)는 잘못된 요청 예외로 분류된다. 잘못된 요청 예외가 발생하는 경우에는 시스템 사용자에게 요청 내용이 잘못됐다는 것을 알릴 수 있도록 구현해야 한다.



- **애플리케이션 예외**

  비즈니스 규칙을 위반했을 때 발생하는 예외(사용자 등록 시 ID 중복 오류, 재고 부족 오류 등)는 애플리케이션 예외로 분류된다. 애플리케이션 오류가 발생한 경우에는 애플리케이션 요구사항에 정해져 있는 오류 처리 내용을 구현해야 한다.





### 5.13.2 예외의 발생 장소와 그에 따른 처리 방법

스프링 MVC를 사용한 웹 애플리케이션에서는 다음과 같은 장소에서 예외가 발생할 수 있으며, 예외 처리 방법도 발생 장소에 따라 달라진다.



![](https://docs.google.com/drawings/d/s483CihTJre0C3ZwsP-OM2A/image?parent=e/2PACX-1vSgWs9-SkKDVDplyC96i2vj5TuZvbmLHvACG_NMQ3eEa1hFtJwCGbFZVRaHriS3HOeS8O0XIQ6gqqII&rev=483&h=273&w=601&ac=1)



**(1)** **Servlet Filter**

서블릿 필터를 사용해서 공통 기능을 구현할 때는 서블릿 필터에서 발생하는 예외를 처리할 수 있어야 한다. 이러한 예외는 서블릿 컨테이너가 제공하는 오류 페이지 기능(**web.xml**의 **\<error-page>** 요소)을 사용해서 예외 처리를 한다.



**(2) DispatcherServlet**

스프링 MVC를 사용할 때는 **Front Controller**에서 프레임워크 기능을 활용할 때 발생하는 오류에 대해서도 예외 처리를 할 수 있어야 한다. 이러한 예외는 스프링 MVC가 제공하는 **HandlerExceptionResolver**를 사용해서 예외 처리를 한다.



**(3) 애플리케이션(컨트롤러, 서비스, 리포지토리 등)**

스프링 MVC를 사용할 때는 **Controller**에서 비즈니스 로직과 같은 애플리케이션 기능을 수행하다 발생하는 오류에 대해서도 예외 처리를 할 수 있어야 한다. 이러한 예외는 프로그램 안에서 **try ~ catch** 문과 스프링 MVC가 제공하는 **HandlerExceptionResolver**를 사용해서 예외 처리를 한다.



**(4) 뷰(JSP 등)**

뷰를 통해 클라이언트에 응답할 데이터를 만들 때는 뷰에서 발생하는 오류에 대해서도 예외 처리를 할 수 있어야 한다. 이러한 예외는 서블릿 컨테이너의 오류 페이지 기능(**web.xml**의 **\<error-page>** 요소)을 사용해서 예외 처리를 한다.



> 사용하는 라이브러리에 따라 라이브러리 자체에서 예외 처리 메커니즘을 제공하는 경우도 있다. 이럴 때는 시스템이나 애플리케이션의 요구사항에 맞춰 예외 처리 방법을 적절히 구현해줘야 한다.







### 5.13.3 서블릿 컨테이너의 오류 페이지 기능 활용

서블릿 컨테이너는 서블릿 컨테이너까지 전달된 예외나 응답 오류(**HttpServletResponse**의 **sendError** 메서드 호출)를 처리하고 이동할 페이지를 지정하는 기능을 제공한다.



오류가 발생했을 때 이동할 페이지는 **web.xml**의 **\<error-page>** 요소에 설정한다.



- **상태 코드를 사용한 이동 대상 페이지 설정 예**

```xml
<error-page>
	<error-code>500</error-code> 
    <!-- 상태 코드를 사용해 이동 대상 페이지를 지정할 때는 <error-code> 요소에 상태 코드를 설정한다.
		 <error-code>에는 오류를 나타내는 계열의 응답 코드(4xx 또는 5xx)를 지정할 수 있다. -->
    <location>/WEB-INF/error/systemError.jsp</location>
    <!-- <location> 요소로 이동 대상 페이지를 지정한다. -->
</error-page>
```



- **예외 타입을 사용한 이동 대상 페이지의 설정 예**

```xml
<error-page>
	<exception-type>java.lang.Exception</exception-type>
    <!-- 예외 타입을 사용해 이동 대상을 지정할 때는 <exception-type> 요소에 예외 타입을 설정한다. -->
    <location>/WEB-INF/error/systemError.jsp</location>
</error-page>
```



- **기본 이동 대상의 설정 예(서블릿 3.1 이상인 경우)**

```xml
<error-page>
	<location>/WEB-INF/error/defaultError.jsp</location>
</error-page>
```



> 일반 사용자에게 서비스되는 애플리케이션에서는 서블릿 컨테이너의 오류 페이지 기능을 사용해 기본 이동 대상을 지정하는 것을 적극 권장한다.





#### 오류 페이지에서 사용할 수 있는 오류 정보

오류 페이지로 지정한 이동 대상에서는 다음과 같은 오류 정보를 요청 스코프에서 꺼내올 수 잇다.



**오류 페이지에서 사용할 수 있는 요청 스코프 속성**

| 속성명                                 | 타입      | 설명                                    |
| -------------------------------------- | --------- | --------------------------------------- |
| **javax.servlet.error.status_code**    | Integer   | 응답 상태 코드                          |
| **javax.servlet.error.exception_type** | Class     | 예외 객체 타입                          |
| **javax.servlet.error.message**        | String    | 예외 메시지                             |
| **javax.servlet.error.exception**      | Throwable | 예외 객체                               |
| **javax.servlet.error.request_uri**    | String    | 예외가 발생한 요청 URI                  |
| **javax.servlet.error.servlet_name**   | String    | 예외가 발생한 요청에 할당된 서블릿 이름 |





#### 예외 클래스와 타입 계층

예외 타입을 사용해서 오류 페이지를 정의한 경우에는 발생한 **예외 클래스**와 예외 페이지에서 정의한 **예외 타입**이 타입 계층 상에서 가장 가까운 내용이 적용된다.



- **타입 계층을 고려해서 이동 대상을 지정한 예**

```xml
<error-page>
	<exception-type>java.lang.Exception</exception-type>
    <location>/WEB-INF/systemError.jsp</location>
</error-page>

<error-page>
	<exception-type>java.io.IOException</exception-type>
    <location>/WEB-INF/ioError.jsp</location>
</error-page>
```



위와 같은 예에서는 **java.io.FileNotFoundException**(IOException의 서브클래스)이 발생하면 **/WEB-INF/ioError.js**가 이동 대상 페이지가 된다.



#### 근원 예외 정보를 사용한 오류 처리

서블릿 컨테이너가 전달된 예외가 **javax.servlet.ServletException**(또는 **ServletException**의 서브클래스)이라서 예외 타입에 대응하는 오류 페이지가 정의돼 있지 않은 경우에는 예외를 유발한 근원 예외(**ServletException**의 **getRootCause** 메서드의 반환값)에 대응하는 오류 페이지가 적용된다.



반대로 말하면 **ServletException**(또는 **ServletException**의 서브클래스)이나 **java.lang.Exception**에 대한 오류 페이지를 정의한 경우에는 근원 예외 정보를 사용한 오류 처리를 할 수 없다.







### 5.13.4 스프링 MVC의 예외 핸들러 활용

스프링 MVC는 프런트 컨트롤러와 컨트롤러 이후의 애플리케이션 기능에서 발생하는 예외를 처리하기 위해 **org.springframework.web.servlet.mvc.method.annotation.HandlerExceptionResolver** 인터페이스와 이것을 구현한 기본 구현 클래스를 제공한다. 스프링 MVC에서는 다음과 같은 세 가지 구현 클래스가 기본으로 적용된다.



| 클래스명                              | 설명                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| **ExceptionHandlerExceptionResolver** | @ExceptionHandler를 붙인 메서드를 구현해서 예외를 처리하는 예외 핸들러 |
| **ResponseStatusExceptionResolver**   | @ResponseStatus를 붙인 예외 클래스를 작성해서 예외를 처리하는 예외 핸들러. @ResponseStatus에 지정한 상태 코드를 사용해 HttpServletResponse의 sendError 메서드가 호출된다. |
| **DefaultHandlerExceptionResolver**   | 스프링 MVC의 프런트 컨트롤러에서 발생하는 예외를 처리하기 위한 예외 핸들러. 예외 클래스에 대응하는 상태 코드를 사용해 HttpServletResponse의 sendError 메서드가 호출된다. |



스프링 MVC에서 발생한 예외는 **DispatcherServlet**이 포착한 후, **HandlerExceptionResolver**의 **resolveException** 메서드에서 예외 처리 과정을 거치게 된다. **resolveException** 메서드 안에서는 **ModelAndView** 클래스 객체를 반환하는 방법으로 다음 이동 대상 뷰를 결정하고, 이동 후의 뷰에서 필요로 하는 정보를 전달한다. 이때 오류 화면으로 이동할 때는 일반적인 화면 방식과 마찬가지로 **ViewResolver**가 사용된다.



![](https://docs.google.com/drawings/d/sci30mPDtKYirXF0E38ShGw/image?parent=e/2PACX-1vSgWs9-SkKDVDplyC96i2vj5TuZvbmLHvACG_NMQ3eEa1hFtJwCGbFZVRaHriS3HOeS8O0XIQ6gqqII&rev=437&h=296&w=601&ac=1)



> 스프링 MVC의 처리 과정에서 에러(java.lang.Error 클래스나 그 서브클래스)가 발생하면 org.spring.framework.web.util.NestedServletException에 래핑된 예외가 서블릿 컨테이너에 전달된다. 즉, 에러(java.lang.Error)는 스프링 MVC의 예외 핸들러를 사용하더라도 오류 처리를 하지 못한다.
>
> -> 스프링 4.3부터 Error나 Throwable을 처리할 수 있다.





#### HandlerExceptionResolver 적용순서

**HandlerExceptionResolver**는 **ExceptionHandlerExceptionResolver**, **ResponseStatusExceptionResolver**, **DefaultHandlerExceptionResolver** 순으로 적용된다. 다만, 이들 중 어느 하나의 **resolveException** 메서드에서 예외가 처리되고 나면 이후의 **HandlerExceptionResolver**는 동작하지 않는다. 만약 모든 **HandlerExceptionResolver**에서 예외가 처리되지 않는 경우에는 **org.springframework.web.util.NestedServletException**(**ServletException**의 서브 클래스)로 래핑된 예외가 서블릿 컨테이너로 전달된다.





#### DefaultHandlerExceptionResolver에서 처리되는 예외

**DefaultHandlerExceptionResolver**에서 처리되는 예외 클래스와 이에 대응하는 상태 코드와의 관계는 다음과 같다.



**기본적으로 적용되는 HandlerExceptionResolver 구현 클래스**

| 클래스명                                    | 설명                                                         | 응답코드 |
| ------------------------------------------- | ------------------------------------------------------------ | -------- |
| **NoSuchRequestHandlingMethodException**    | 요청에 대응할 핸들러 메서드가 발견되지 않았을 때 발생하는 예외. MultiActionController를 상속해서 컨트롤러를 만든 경우에 발생한다. | 404      |
| **HttpRequestMethodNotSupportedException**  | 지원하지 않는 HTTP 메서드가 호출됐을 때 발생하는 예외. 응답의 Allow 헤더에 지원하는 HTTP 메서드 목록이 설정된다. | 405      |
| **HttpMediaTypeNotSupportedException**      | 요청의 Content-Type에 지정한 미디어 타입이 지원되지 않을 때 발생하는 예외. 응답의 Accept 헤더에 지원하는 미디어 타입 목록이 설정된다. | 415      |
| **HttpMediaTypeNotAcceptableException**     | 요청의 Accept 헤더에 지정한 미디어 타입으로 응답이 지원되지 않는 경우에 발생하는 예외 | 406      |
| **MissingPathVariableException**            | @PathVariable로 경로 변수 값을 구할 때 URI 템플릿에 경로 변수가 없을 때 발생하는 예외 | 500      |
| **MissingServletRequestParameterException** | 필수 요청 파라미터가 지정되지 않았을 때 발생하는 예외. @RequestParam으로 요청 파라미터 값을 가져올 때 발생한다. | 404      |
| **ServletRequestBindingException**          | @RequestMapping의 params 속성으로 요청을 매핑할 때 params 속성에 대응하는 요청 파라미터가 존재하지 않을 때 발생한다. | 400      |
| **ConversionNotSupportedException**         | 스프링의 형 변환 메커니즘에서 변환할 수 없는 타입이 있을 때 발생하는 예외 | 500      |
| **TypeMismatchException**                   | 요청 파라미터 값이 형 변환에 실패했을 때 발생하는 예외. 예를 들어, @RequestParam를 통해 요청 파라미터 값을 Integer로 받아야 하는 상황에서 요청 파라미터 값에 숫자가 아닌 다른 타입의 값이 지정되면 이 예외가 발생한다. | 400      |
| **HttpMessageNotReadableException**         | HttpMessageConverter를 통해 요청 본문(JSON이나 XML 등)을 읽지 못했을 때 발생하는 예외 | 400      |
| **HttpMessageNotWritableException**         | HttpMessageConverter를 통해 요청 본문(JSON이나 XML 등)을 쓰지 못했을 때 발생하는 예외 | 500      |
| **MethodArgumentNotValidException**         | @RequestBody나 @RequestPart를 지정해서 가져온 객체에서 바인딩 오류(입력값 검사 오류)가 발생할 때 나는 예외 | 400      |
| **MissingServletRequestPartException**      | 필수적으로 입력돼야 할 업로드 파일이 지정되지 않았을 때 발생하는 예외. @RequestPart를 통해 업로드 파일을 가져올 때 발생한다. | 400      |
| **BindException**                           | 폼 객체에서 입력값 검사 오류가 발생했을 때 나는 예외. 핸들러 메서드 매개변수에 BindingResult를 지정하면 이 예외가 발생하지 않는다. | 400      |
| **NoHandlerFoundException**                 | 요청에 대응하는 핸들러 메서드가 발견되지 않았을 때 발생하는 예외. 기본 설정에서는 핸들러 메서드를 못찾아도 예외가 발생하지 않는다. 예외를 발생시키려면 DispatcherServlet의 throwExceptionIfNoHandlerFound 속성을 true(기본값은 false)로 설정해야 한다. | 404      |



### 5.13.5 @ExceptionHandler 메서드 활용

**DefaultHandlerExceptionResolver**에서 처리되지 않는 예외를 처리하려면 **@org.springframework.web.bind.annotation.ExceptionHandler**를 붙인 메서드를 구현하면 된다.



**@ExceptionHandler**가 붙은 메서드는 **Controller** 클래스나 **ControllerAdvice** 클래스(**@ControllerAdvice**가 붙은 클래스)에 구현할 수 있다. Controller 고유의 예외 처리는 Controller 클래스에 구현하고 애플리케이션 전체에서 필요로 하는 공통적인 예외 처리는 **ControllerAdvice** 클래스에 구현하는 것이 일반적이다.



> 예외 처리 내용이 **'이동 대상의 뷰 지정'**과 **'응답 코드 지정'**만이라면 스프링 MVC에서 제공하는 **org.springframework.web.servlet.handler.SimpleMappingExceptionResolver**를 활용해 볼 수 있다. **SimpleMappingExceptionResolver**를 사용하려면 **SimpleMappingExceptionResolver**를 빈으로 정의한 다음, DI 컨테이너에 등록해야한다. 적용 순서를 바꾸고 싶다면 **SimpleMappingExceptionResolver**의 **order** 프로퍼티를 조절하면 된다. **order** 프로퍼티를 생략하면 가장 우선순위가 낮은 **ExceptionHandlerExceptionResolver**로 DI 컨테이너에 등록된다.





#### 공통적인 예외 처리의 구현

애플리케이션 전체에서 공통적으로 발생하는 예외를 처리하려면 예외 처리용 **ControllerAdvice** 클래스를 작성하고 **@ExceptionHandler** 메서드를 구현한다.



- **공통적인 예외 처리 구현 예**

```java
import org.springframework.http.HttpStatus;
import org.spinrgframework.web.bind.annotation.*;

@ControllerAdvice // 공통적인 예외 처리를 위해 @ControllerAdvice를 붙인 클래스를 구현한다.
public class GlobalExceptionHandler {
    
    @ExceptionHandler 
    // @ExceptionHandler를 붙인 메서드를 구현한다. 처리할 예외 클래스는 메서드 매개변수나 @ExceptionHandler의
    // value 속성에 지정한다. 이 예에서는 처리할 예외 클래스를 메서드의 매개변수에 지정하고 있다.
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) 
    // 클라이언트에 응답할 상태 코드를 지정한다. 이 예에서는 500(Internal Server Error)을 지정하고 있다. 
    // 상태 코드를 생략하면 기본값은 200(OK)이 된다.
    public String handleException(Exception e) {
        // 오류 처리를 한다.
        
        return "error/systemError";
        // 오류 처리를 위해 다음에 이동할 뷰 이름을 반환한다. 
        // 이 예에서는 시스템 오류 화면으로 이동하기 위한 뷰 이름('error/systemError')을 반환한다.
    }
}
```



이 예에서는 **handleException**이라는 메서드를 하나만 구현하고 있지만 상황에 따라 여러 개의 메서드를 구현할 수 있다. 그리고 애너테이션을 사용하고 있기 때문에 특별히 클래스명이나 메서드명에 대한 명명법과 같은 제약은 없다.



#### @ExceptionHandler 메서드의 매개변수

**@ExceptionHandler** 메서드의 매개변수에는 다음과 같은 타입을 지정할 수 있다.



| 클래스명                                  | 설명                                                     |
| ----------------------------------------- | -------------------------------------------------------- |
| **Exception**                             | 발생한 예외 객체                                         |
| **HandlerMethod**                         | 요청에 대응하는 HandlerMethod 객체                       |
| **java.util.Locale**                      | 클라이언트 로캘                                          |
| **java.util.TimeZone / java.time.ZoneId** | 클라이언트 시간대. ZoneId는 Java SE 8 이상에서 사용 가능 |
| **java.security.Principal**               | 클라이언트의 인증된 사용자 정보를 가지고 있는 인터페이스 |



> 핸들러 메서드의 매개변수와 마찬가지로 서블릿 API(HttpServletRequest, HttpServletResponse, HttpSession)나 저수준 자바 API(InputStream, Reader, OutputStream, Writer)의 타입도 지정할 수 있지만 이러한 API를 남발해서 사용하면 애플리케이션의 유지보수가 힘들어질 수 있다. 애플리케이션 요구사항이 충족되지 않는 경우에 한해서만 이러한 API를 사용하자.





#### @ExceptionHandler 메서드의 반환값

**@ExceptionHandler** 메서드의 반환값으로 다양한 객체를 지정할 수 있다. 스프링 MVC가 기본적으로 지원하는 주요 타입은 다음과 같다.



| **형**                    | **설명**                                                     |
| ------------------------- | ------------------------------------------------------------ |
| **String**                | 이동 대상의 뷰 이름을 반환한다.                              |
| **ModelAndView**          | 이동 대상의 뷰 이름과 이동 대상에 연계할 데이터(Model)를 반환한다. |
| **void**                  | HttpServletResponse에 직접 응답 데이터를 쓰는 경우에는 void로 지정한다. |
| **ResponseEntity<?>    ** | 응답 헤더와 응답 본문에 직렬화 객체를 반환한다. 반환한 객체는 HttpMessageConverter를 사용해 임의의 형식으로 직렬화된다. |





그리고 핸들러 메서드와 마찬가지로 **@ModelAttribute**나 **@ResponseBody**를 메서드에 지정해 임의의 객체를 **Model**에 저장하거나 응답 본문에 직렬화할 수 있다.









### 5.13.6 @ResponseStatus를 지정한 예외 클래스의 활용

예외 처리 내용이 상태 코드만 설정하는 것이라면 **@org.springframework.web.bind.annotation.ResponseStatus**를 붙인 예외 클래스를 구현하면 된다.



- **@ResponseStatus를 붙인 예외 클래스의 구현 예**

```java
@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    // 생략
}
```



위의 예외 클래스가 스프링 MVC로 전달되면 응답 상태 코드에 404(Not Found)가 설정된다. 한편 **@ResponseStatus**는 부모 클래스나 원인이 되는 예외 클래스에 지정할 수도 있다.

