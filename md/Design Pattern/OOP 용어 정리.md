## OOP 용어 정리



### 캡슐화(Encapsulation)

**캡슐화**는 <span style="color:red">중요한 데이터를 보존, 보호</span>하는 것이다.

**캡슐화**는 일반적으로 <span style="color: red">연관 있는 변수와 함수를 클래스로 묶는 작업</span>을 말합니다. 또한, 캡슐화에는 **은닉성**이란 것이 있어서 클래스에 담는 내용 중 중요한 데이터나 기능을 외부에서 접근하지 못하게 할 수 있습니다.

**캡슐화**는 필요한 속성(Attribute)와 행위(Method)를 하나로 묶고 그 중 일부를 외부에서 사용하지 못하도록 은닉한다.





**캡슐화**

- 객체의 필드(속성), 메서드를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것
- 외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메서드만 이용할 수 있다.
- 필드와 메서드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는데 있다.
- 자바는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지를 결정하기 위해 접근 제한자(Access Modifier)를 사용한다.





## 객체지향의 4대 특성



### 캡슐화(Encapsulation) = 정보은닉

접근제어자(private, protected, public)을 사용해 객체 외부에서 내부 데이터의 접근을 통제하는 것이다. 



### 상속(Inheritance) = 재사용 + 확장

상속에서 주의할 점은 계층도, 조직도 관점(할아버지를 상속받은 아버지?)에서 이해하면 안된다.

분류도 관점에서 이해해야 한다. 포유류의 부모는 동물은 아니지만, `class 포유류 extends 동물`로 충분히 구현된다. 

객체지향에서 상속은 상위 클래스의 특성을 하위 클래스에서 상속하고 더 필요한 속성을 확장해서 쓰는 것이다. 



### 추상화(Abstraction) = 모델링

객체지향의 추상화는 모델링이다. 추상화란 구체적인 것을 관심영역(해당 애플리케이션, 서비스의 도메인)에 있는 특성만을 가지고 재조합하는 것을 말한다. 예를 들어, class Person은 병원이라면 환자 도메인에 맞는 속성이 좀 더 많을 것이고, 상점이라면 고객 입장에서의 속성이 좀 더 많을 것이다.



### 다형성(Polymorphism) = 사용편의

오버라이딩(overriding)과 오버로딩(overloadding)이 여기에 해당된다. 

오버라이딩은 상위클래스의 메서드와 같은 시그니처로 메서드를 재정의하는 것을 말한다.

오버로딩은 메서드 이름만 같고 시그니처가 다른 것들을 말한다.

이때 유의할 점은 변수타입을 상위클래스로 써서, 메서드를 호출한다고 해도 하위 클래스에서 오버라이딩한 메서드의 로직이 호출된다는 점이다.





## SOLID 원칙

SOLID 원칙이란 객체지향 설계에서 지켜줘야 하는 5개의 원칙을 말합니다. 이 설계원칙들을 알아야 하는 이유는 시스템에 예상치 못한 **변경사항**이 발생하더라도, **유연하게 대처하고** 이후에 **확장성 있는** 시스템 구조를 설계하기 위해서입니다.



좋은 설계란 **시스템에 새로운 요구사항이나 변경사항이 있을 때, 영향을 받는 범위가 적은 구조**를 말합니다. 앞으로 알아볼 여러 디자인 패턴들은 아래의 SOLID 원칙에 입각해서 만들어진 것이므로, SOLID 원칙이 무엇인지 알아보도록 하겠습니다.





### SRP(Single Responsibility Principle), 단일 책임 원칙

**객체는 단 하나의 책임만 가져야 한다**는 원칙을 말합니다.



객체지향적으로 설계할 때는 **응집도는 높게, 결합도는 낮게** 설계하는 것이 좋습니다.



- **응집도**: 한 프로그램의 요소가 얼마나 뭉쳐있는지, 즉 구성 요소들 사이의 응집력을 뜻함. **한 클래스 내**
- **결합도**: 프로그램 구성 요소들 사이가 얼마나 의존적인지를 뜻함. **여러 클래스 사이**



한 객체에 책임이 많아질수록 클래스 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게 결합될 가능성이 높아집니다. 즉, 객체마다 책임을 제대로 나누지 않으면 시스템은 매우 복잡해집니다. 왜냐하면 그 객체가 하는 일(함수)에 변경사항이 생기면 이 기능을 사용하는 부분의 코드를 모두 다시 테스트해야 하기 때문입니다.



따라서 여러 객체들이 하나의 책임만 갖도록 분배한다면, 시스템에 변화가 생기더라도 그 영향을 최소화할 수 있기 때문에 SRP 원칙을 따르는 것이 좋습니다.







### OCP(Open-Closed Principle), 개방-폐쇄 원칙

**기존의 코드를 변경하지 않으면서(closed), 기능을 추가할 수 있도록(open)** 설계가 되어야 한다는 원칙을 말합니다. 즉, 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 한다는 의미를 갖습니다.



이를 만족하는 설계가 되려면, **캡슐화**를 통해 여러 객체에서 사용하는 같은 기능을 인터페이스에 정의하는 방법이 있습니다.



![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F99B4BD3F5BF797F11AA903)





### LSP(Liskov Substitution Principle), 리스코프 치환 원칙

**자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다**는 설계 원칙입니다. 즉, 자식 클래스는 언제나 부모 클래스의 역할을 대체할 수 있어야 한다는 것을 말하며, 부모 클래스와 자식 클래스의 행위가 일관됨을 의미합니다.



자식 클래스가 부모 클래스를 대체하기 위해서는 부모의 기능에 대해 오버라이드되지 않도록 하면 됩니다. 즉, **자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야 LSP를 만족하게 됩니다**.



처음 OOP를 공부할 때 오버라이드가 OOP의 특징이라 배웠고 이를 잘 활용해야 할 것만 같았는데, LSP에 따르면 객체지향적으로 설계를 하기 위해서는 오버라이드는 가급적 피하는 것이 좋다고 합니다.





### ISP(Interface Segregation Principle), 인터페이스 분리 원칙

**자신이 사용하지 않는 인터페이스는 구현하지 않아야 한다**는 설계 원칙입니다. 즉, 하나의 거대한 인터페이스보다는 여러 개의 구체적인 인터페이스가 낫다는 것을 의미합니다.

SRP가 객체의 단일 책임을 뜻한다면, ISP는 인터페이스의 단일 책임을 의미한다고 보면 됩니다.



예를 들어, 핸드폰(Phone)에는 전화(call), 문자(sms), 알람(alarm), 계산기(calculator) 등의 기능이 있습니다. 옛날 3G폰과 현재 스마트폰은 Phone의 기능들을 사용하므로, call, sms, alarm, calculator 기능이 정의된 Phone 인터페이스를 정의하려고 합니다.



![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F99AC86385BF7A5D902310B)



그러나 ISP를 만족하려면 Phone 인터페이스에 call(), sms(), alarm(), calculator() 함수를 모두 정의하는 것보다, Call, Sms, Alarm, Calculator 인터페이스를 각각 정의하여, 3G폰과 스마트폰 클래스에서 4개의 인터페이스를 구현하도록 설계되어야 합니다.



![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F99BB71345BF7A5EC08BD3C)



이렇게 설계를 하면, 각 인터페이스의 메서드들이 서로 영향을 미치지 않게 됩니다. 즉, 자신이 사용하지 않는 메서드에 대해서 영향력이 줄어듭니다.





### DIP(Dependency Inversion Principle), 의존 역전 원칙

객체들이 서로 정보를 주고 받을 때 의존 관계가 형성되는데, 이 때 객체들은 나름대로의 원칙을 갖고 정보를 주고 받아야 한다는 설계 원칙입니다. 여기서 나름대로의 원칙이란, **추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다**는 것을 의미합니다.

일반적으로 인터페이스를 활용하면 이 원칙을 준수할 수 있게 됩니다.



![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F9993CF4D5BF7A8290F9519)



Client 객체는 Cat, Dog, Bird의 crying() 메서드에 직접 접근하지 않고, Animal 인터페이스의 crying() 메서드를 호출함으로써 DIP를 만족할 수 있습니다.



























