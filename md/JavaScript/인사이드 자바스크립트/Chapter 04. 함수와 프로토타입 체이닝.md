## Chapter 04. 함수와 프로토타입 체이닝



### 목차

- 4.1 함수 정의
  - 함수 리터럴
  - 함수 선언문 방식으로 함수 생성하기
  - 함수 표현식 방식으로 함수 생성하기
  - Function() 생성자 함수를 통한 함수 생성하기
  - 함수 호이스팅
- 4.2 함수 객체: 함수도 객체다
  - 자바스크립트에서는 함수도 객체다
  - 자바스크립트에서 함수는 값으로 취급된다
  - 함수 객체의 기본 프로퍼티
- 4.3 함수의 다양한 형태
  - 콜백 함수
  - 즉시 실행 함수
  - 내부 함수
  - 함수를 리턴하는 함수
- 4.4 함수 호출과 this
  - arguments 객체
  - 호출 패턴과 this 바인딩
  - 함수 리턴
- 4.5 프로토타입 체이닝
  - 프로토타입의 두 가지 의미
  - 객체 리터럴 방식으로 생성된 객체의 프로토타입 체이닝
  - 생성자 함수로 생성된 객체의 프로토타입 체이닝
  - 프로토타입 체이닝의 종점
  - 기본 데이터 타입 확장
  - 프로토타입도 자바스크립트 객체다
  - 프로토타입 메서드와 this 바인딩
  - 디폴트 프로토타입은 다른 객체로 변경이 가능하다
  - 객체의 프로퍼티 읽기나 메서드를 실행할 때만 프로토타입 체이닝이 동작한다.



## 4.1 함수 정의

- 함수를 생성하는 3가지 방법
  - 함수 선언문 (function statement)
  - 함수 표현식 (function expression)
  - Function() 생성자 함수



- 함수 리터럴

  - 자바스크립트에서는 함수도 일반 객체처럼 값으로 취급된다.

  - 때문에 객체 리터럴 방식으로 일반 객체를 생성할 수 있는 것처럼, 자바스크립트에서는 **함수 리터럴**을 이용해 함수를 생성할 수 있다.

  - 실제로 함수 선언문이나 함수 표현식 방법 모두 이런 함수 리터럴 방식으로 함수를 생성한다.

  - **[예시]** 함수 리터럴을 통한 add() 함수 정의

    ```javascript
    function add(x, y) {
    	return x + y;
    }
    ```

    - 함수명은 선택 사항이다. 자바스크립트에서는 함수명이 없는 함수를 익명 함수라고 한다.
    - 자바스크립트에서는 매개변수 타입을 기술하지 않는다.

    

- 함수 선언문 방식으로 함수 생성하기

  - 함수 선언문 방식은 앞에서 설명한 함수 리터럴 형태와 같다.

  - 주의할 점은 함수 선언문 방식으로 정의된 함수의 경우는 **반드시 함수명이 정의되어 있어야 한다**는 것이다.

  - **[예제 4-1]** add() 함수 생성 (함수 선언문 방식)

    ```javascript
    // add() 함수 선언문
    function add(x, y) {
    	return x + y;
    }
    
    console.log(add(3, 4));  // (출력값) 7
    ```

    

- 함수 표현식 방식으로 함수 생성하기

  - 자바스크립트에서는 함수도 하나의 값처럼 취급된다.

    - 따라서 함수도 숫자나 문자열처럼 변수에 할당되는 것이 가능하다.

  - 이런 방식으로 함수 리터럴로 하나의 함수를 만들고, 여기서 생성된 함수를 변수에 할당하여 함수를 생성하는 것을 **함수 표현식**이라고 말한다.

    

  - **[예제 4-2]** add() 함수 생성 (함수 표현식 방식)

    ```javascript
    // add() 함수 표현식
    var add = function (x, y) {
    	return x + y;
    };
    
    var plus = add;
    
    console.log(add(3,4));
    console.log(plus(5,6));
    ```

    - 여기서 함수 리터럴로 생성한 함수는 함수명이 없으므로 익명 함수이다.
    - 위 코드에서 알 수 있듯이 함수 표현식은 함수 선언문 문법과 거의 유사하다. 유일한 차이점은 함수 표현식 방법에서는 함수 이름이 선택 사항이며, 보통 사용하지 않는다는 것이다.

    - 위 방식은 **익명 함수를 이용한 함수 표현식 방법(익명 함수 표현식)**이다.

    - 이러한 익명 함수의 호출은 앞 예제와 같이 함수 변수에 함수 호출 연산자인 ()를 붙여서 기술하는 것으로 가능하다.

      

  - **[예제 4-3]** 기명 함수 표현식의 함수 호출 방법

    ```java
    var add = function sum(x, y) {
        return x + y;
    };
    
    console.log(add(3, 4)); // (출력값) 7
    console.log(sum(3, 4)); // ReferenceError: sum is not defined
    ```

    - 위와 같이 함수 이름이 포함된 함수 표현식을 **기명 함수 표현식**이라고 한다.

    - sum(3,4) statement는 에러가 발생하는데, 이것은 함수 표현식에서 사용된 함수명이 외부 코드에서 접근이 불가능하기 때문이다.

      - 함수 표현식에 사용된 함수명은 정의된 함수 내부에서 해당 함수를 재귀적으로 호출하거나, 디버거 등에서 함수를 구분할 때 사용된다.

        

  - 예제 4-1에서 함수 표현식이 아닌 함수 선언문으로 정의한 add() 함수는 어떻게 함수명으로 함수 외부에서 호출이 가능할까?

    - 함수 선언문 형식으로 정의된 add() 함수는 자바스크립트 엔진에 의해 다음과 같은 함수 표현식 형태로 변경되기 때문이다.

      ```javascript
      var add = function add(x, y) {
      	return x + y;
      };
      ```

    - 함수명과 함수 변수의 이름이 add로 같으므로, 함수명으로 함수가 호출되는 것처럼 보이지만, 실제로는 add 함수 변수로 함수 외부에서 호출이 가능하게 된 것이다.

    

  - **[예제 4-4]** 함수 표현식 방식으로 구현한 팩토리얼 함수

    ```javascript
    var factorialVar = function factorial(n) {
        if (n <= 1) {
            return 1;
        }
        return n * factorial(n - 1);
    };
    
    console.log(factorialVar(5)); // (출력값) 120
    console.log(factorial(3)); // ReferenceError: factorial is not defined
    ```

    

