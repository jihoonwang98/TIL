# [모던 JavaScript 튜토리얼 - 코어 자바스크립트] 2. 자바스크립트 기본

> https://ko.javascript.info/first-steps



**목표**

- 자바스크립트 기본 문법에 대해 배워봅시다.



## 2.1 Hello, world!

>  https://ko.javascript.info/hello-world

**도입**

- 여러분이 읽고 있는 이 파트는 실행 환경에 독립적인 코어 자바스크립트(core JavaScript)를 다룹니다.
  - 코어 자바스크립트를 다루고 있긴 하지만, 학습을 위해선 스크립트를 실행할 수 있는 환경이 필요합니다. 
- 본 튜토리얼은 온라인으로 제공되기 때문에 실행환경으로 브라우저를 사용하도록 하겠습니다. 
- Node.js와 같이 브라우저 이외의 환경에 주력하는 학습자를 위해, 브라우저 한정 명령어(`alert` 등)는 최소한으로 사용하도록 하겠습니다. 
  - 이런 명령어를 학습하는 데 시간을 보내지 않도록 말이죠. 
  - 브라우저 환경에서의 자바스크립트는 [다음 파트](https://ko.javascript.info/ui)에서 다루도록 하겠습니다.
- 먼저, <u>**웹 페이지에 스크립트를 삽입하는 방법**</u>에 대해 알아봅시다. 
- 참고로 Node.js와 같은 서버 사이드 환경에서 스크립트를 실행하고 싶다면 `'node my.js'`와 같은 명령어를 사용하면 됩니다.



### 'script' 태그

- `<script>` 태그를 이용하면 자바스크립트 프로그램을 HTML 문서 대부분의 위치에 삽입할 수 있습니다.

  - 예제

    ```html
    <!DOCTYPE HTML>
    <html>
    <body>
      <p>스크립트 전</p>
      <script>
        alert( 'Hello, world!' );
      </script>
      <p>스크립트 후</p>
    </body>
    </html>
    ```

  - `<script> ` 태그엔 자바스크립트 코드가 들어갑니다. 브라우저는 이 태그를 만나면 안의 코드를 자동으로 처리합니다.



### 모던 마크업

- `<script>` 태그엔 몇 가지 속성(attribute)이 있습니다. 요즘엔 잘 사용하진 않지만, 오래된 코드에서 종종 이 속성을 발견할 수 있습니다.
  - `type` 속성: `<script type=...>`
    - HTML4에선 스크립트에 `type`을 명시하는 것이 필수였습니다. 
      - 따라서 `type="text/javascript"` 속성이 붙은 스크립트를 어렵지 않게 찾을 수 있었습니다. 
    - 이젠 타입 명시가 필수가 아닙니다. 게다가 모던 HTML 표준에선 이 속성의 의미가 바뀌었습니다. 
    - 이제 이 속성은 자바스크립트 모듈에 사용할 수 있습니다. 모듈은 심화 내용이기 때문에 다른 파트에서 다시 이야기하도록 하겠습니다.
  - `language` 속성: `<script language=...>`
    - 이 속성은 현재 사용하고 있는 스크립트 언어를 나타냅니다. 
    - 지금은 자바스크립트가 기본 언어이므로 속성의 의미가 퇴색된 상황입니다. 더는 사용할 필요가 없어졌죠.



### 외부 스크립트

- 자바스크립트 코드의 양이 많은 경우엔, 파일로 소분하여 저장할 수 있습니다.

  - 이렇게 분해해 놓은 각 파일은 `src` 속성을 사용해 HTML에 삽입합니다.

    ```html
    <script src="/path/to/script.js"></script>
    ```

    - 여기서 `/path/to/script.js`는 사이트의 루트에서부터 파일이 위치한 <u>절대 경로</u>를 나타냅니다. 

    - 현재 페이지에서의 <u>상대 경로</u>를 사용하는 것도 가능합니다. 같은 폴더 내에 있는 파일인 `"script.js"`를 `src="script.js"`로 참조하는 것처럼 말이죠.

    - 물론 아래와 같이 <u>URL</u> 전체를 속성으로 사용할 수도 있습니다.

      `<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"></script>`

- 복수의 스크립트를 HTML에 삽입하고 싶다면 스크립트 태그를 여러 개 사용하면 됩니다.

  ```html
  <script src="/js/script1.js"></script>
  <script src="/js/script2.js"></script>
  …
  ```

  

> **주의**
>
> - HTML 안에 직접 스크립트를 작성하는 방식은 대개 스크립트가 아주 간단할 때만 사용합니다. 
>   - 스크립트가 길어지면 별개의 분리된 파일로 만들어 저장하는 것이 좋습니다.
> - 스크립트를 별도의 파일에 작성하면 브라우저가 스크립트를 다운받아 [캐시(cache)](https://en.wikipedia.org/wiki/Web_cache)에 저장하기 때문에, 성능상의 이점이 있습니다.
> - 여러 페이지에서 동일한 스크립트를 사용하는 경우, 브라우저는 페이지가 바뀔 때마다 스크립트를 새로 다운받지 않고 캐시로부터 스크립트를 가져와 사용합니다. 스크립트 파일을 한 번만 다운받으면 되죠.
>   - 이를 통해 트래픽이 절약되고 웹 페이지의 실제 속도가 빨라집니다.



> **`src` 속성이 있으면 태그 내부의 코드는 무시됩니다.**
>
> - `<script>` 태그는 src 속성과 내부 코드를 동시에 가지지 못합니다.
> - 다음 코드는 실행되지 않습니다.
>
> ```html
> <script src="file.js">
>   alert(1); // src 속성이 사용되었으므로 이 코드는 무시됩니다.
> </script>
> ```
>
> - 따라서 `<script src="…">`로 외부 파일을 연결할지 아니면 `<script>` 태그 내에 코드를 작성할지를 선택해야 합니다.
> - 위의 예시는 스크립트 두 개로 분리하면 정상적으로 실행됩니다.
>
> ```html
> <script src="file.js"></script>
> <script>
>   alert(1);
> </script>
> ```



### 요약

- 웹 페이지에 자바스크립트 코드를 추가하기 위해 `<script>` 태그를 사용합니다.
- `type` 과 `language` 속성은 필수가 아닙니다.
- 외부 스크립트 파일은 `<script src="path/to/script.js"></script>`와 같이 삽입합니다.





## 2.2 코드 구조

> https://ko.javascript.info/structure

**도입**

- 처음으로 배울 것은 코드 블록을 만드는 방법입니다.



### Statement

- 문(statement)은 어떤 작업을 수행하는 문법 구조(syntax structure)와 명령어(command)를 의미합니다.

  - 앞서 ‘Hello, world!’ 메시지를 보여주는 `alert('Hello, world!')` 문을 확인한 바 있습니다.

- 코드엔 원하는 만큼 문을 작성할 수 있습니다. 이때, 서로 다른 문은 세미콜론으로 구분합니다.

  - 아래 코드는 'Hello World’를 두 개의 alert 문으로 나눈 예시입니다.

    ```js
    alert('Hello');
    alert('World');
    ```

    

### 세미콜론

- 줄 바꿈이 있다면 세미콜론(semicolon)을 생략할 수 있습니다.

  - 아래 코드는 에러 없이 동작합니다.

    ```js
    alert('Hello')
    alert('World')
    ```

- 자바스크립트는 줄 바꿈이 있으면 이를 ‘암시적’ 세미콜론으로 해석합니다. 이런 동작 방식을 [세미콜론 자동 삽입(automatic semicolon insertion)](https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion)이라 부릅니다.

- **대부분의 경우, 줄 바꿈은 세미콜론을 의미합니다. 하지만 '대부분의 경우’가 '항상’을 의미하진 않습니다.**

  - 아래와 같이 줄 바꿈이 세미콜론을 의미하지 않는 경우도 있습니다.

    ```js
    alert(3 +
    1
    + 2);
    ```

  - 세미콜론 자동 삽입이 일어나지 않았기 때문에 `6`이 출력됩니다. 어떤 줄이 `"+"` 로 끝나면, 그 줄은 '불완전한 표현식’이므로 세미콜론이 필요하지 않다는 걸 직감하실 겁니다. 위 코드도 이런 의도로 동작합니다.

- **반면, 세미콜론이 정말로 필요하지만 자바스크립트가 이를 추정하지 ‘못하는’ 상황도 존재합니다.**

  - 예제

    ```js
    [1, 2].forEach(alert)
    ```

    - 지금은 대괄호 `[]`와 `forEach`는 아직 배우지 않았으므로, 깊이 생각하지 말고 코드를 살펴봅시다. 이들에 대해선 추후에 학습할 예정입니다. 코드를 실행하면 결과가 `1`과 `2`가 출력된다는 사실만 기억하세요.
    - 이제 위에서 작성한 코드 앞쪽에 *세미콜론을 붙이지 않은 채* `alert`를 추가해 봅시다.

    ```js
    alert("에러가 발생합니다.")
    
    [1, 2].forEach(alert)
    ```

    - 예제를 실행해 보면 새롭게 추가한 `alert`만 제대로 출력되고 에러가 발생하는 걸 확인할 수 있습니다.
    - `alert` 끝에 세미콜론을 추가해 다시 실행하면 코드는 잘 작동합니다.

    ```js
    alert("제대로 동작합니다.");
    
    [1, 2].forEach(alert)
    ```

    - “제대로 동작합니다.” 메시지 다음에 `1`과 `2`가 나타나는 것을 확인할 수 있죠.
    - 세미콜론이 없을 때 에러가 발생했던 이유는 **<u>자바스크립트가 대괄호 `[...]`앞에는 세미콜론이 있다고 가정하지 않기 때문</u>**입니다.
    - 따라서 세미콜론 자동 삽입이 일어나지 않고 첫 번째 예제는 단일 문으로 처리됩니다. 자바스크립트 엔진이 보게 될 코드는 다음과 같아지죠.

    ```js
    alert("에러가 발생합니다.")[1, 2].forEach(alert)
    ```

    - 하지만 원래 이 코드는 단일 문이 아닌 두 개의 서로 다른 문이었습니다. 문이 잘못 합쳐지면서 에러가 발생한 것이죠. 이 예제 외에도 이런 상황이 발생할 여지는 언제나 있습니다.

- **<u>줄 바꿈으로 문을 나눴더라도, 문 사이엔 세미콜론을 넣는 것이 좋습니다.</u>** 
  - 자바스크립트 커뮤니티에서도 이를 규칙으로 정해 권장하고 있습니다. 





### 주석

- 시간이 흐름에 따라 자바스크립트 프로그램은 더욱더 복잡해졌습니다. 
  - 이로 인해 무슨 일이 왜 벌어지고 있는지를 설명해주는 *주석(comment)* 의 필요성이 요구되었습니다.
- 주석은 스크립트의 어느 곳에나 작성할 수 있습니다. 
  - 자바스크립트 엔진은 주석을 무시하기 때문에 주석의 위치는 실행에 영향을 주지 않습니다.



- **한 줄짜리 주석은 두 개의 슬래시 `//`로 시작됩니다.**
- **여러 줄의 주석은 슬래시와 별표 `/*`로 시작해 별표와 슬래시 `*/`로 끝납니다.**





## 2.3 엄격 모드

> https://ko.javascript.info/strict-mode

**도입**

- 자바스크립트는 꽤 오랫동안 호환성 이슈 없이 발전해왔습니다. 기존의 기능을 변경하지 않으면서 새로운 기능이 추가되었죠.
- 덕분에 기존에 작성한 코드는 절대 망가지지 않는다는 장점이 있었습니다. 하지만 자바스크립트 창시자들이 했던 실수나 불완전한 결정이 언어 안에 영원히 박제된다는 단점도 생겼습니다.
  - 이런 상황은 ECMAScript5(ES5)가 등장하기 전인 2009년까지 지속되었습니다. 
- 그런데 <u>새롭게 제정된 ES5에서는 새로운 기능이 추가되고 기존 기능 중 일부가 변경되었습니다.</u> 
  - 기존 기능을 변경하였기 때문에 하위 호환성 문제가 생길 수 있겠죠? 그래서 변경사항 대부분은 ES5의 기본 모드에선 활성화되지 않도록 설계되었습니다. 
  - 대신 `use strict`라는 특별한 지시자를 사용해 엄격 모드(strict mode)를 활성화 했을 때만 이 변경사항이 활성화되게 해놓았습니다.



### use strict

- 지시자 `"use strict"`, 혹은 `'use strict'`는 단순한 문자열처럼 생겼습니다. 

  - 하지만 **<u>이 지시자가 스크립트 최상단에 오면 스크립트 전체가 “모던한” 방식으로 동작합니다.</u>**

    ```js
    "use strict";
    
    // 이 코드는 모던한 방식으로 실행됩니다.
    ...
    ```

- 명령어를 그룹화하는 방식인 함수에 대해선 곧 학습하도록 하겠습니다. 

- 함수에 대해 학습하기 전에, **<u>`"use strict"`는 스크립트 최상단이 아닌 함수 본문 맨 앞에 올 수도 있다</u>**는 점을 알아두시기 바랍니다. 

  - 이렇게 하면 <u>오직 해당 함수만 엄격 모드로 실행</u>됩니다. 
  - 엄격 모드는 대개 스크립트 전체에 적용하지만 말이죠.



> **[주의] "use strict"는 반드시 최상단에 위치시키세요.**
>
> - `"use strict"`는 스크립트 최상단에 있어야 한다는 점을 잊지 마세요. 그렇지 않으면 엄격 모드가 활성화되지 않을 수도 있습니다.
>
> - 다음 코드에서는 엄격 모드가 활성화되지 않습니다.
>
>   ```js
>   alert("some code");
>   // 하단에 위치한 "use strict"는 스크립트 상단에 위치하지 않으므로 무시됩니다.
>   
>   "use strict";
>   
>   // 엄격 모드가 활성화되지 않습니다.
>   ```
>
> - `"use strict"`의 위에는 주석만 사용할 수 있습니다.



> **[주의] `use strict`를 취소할 방법은 없습니다.**
>
> - 자바스크립트 엔진을 이전 방식으로 되돌리는 `"no use strict"`같은 지시자는 존재하지 않습니다.
> - 일단 엄격 모드가 적용되면 돌이킬 방법은 없습니다.



### 브라우저 콘솔

- 개발한 기능을 테스트하기 위해 [브라우저 콘솔](https://ko.javascript.info/devtools)을 사용하는 경우, 기본적으로 `use strict`가 적용되어있지 않는다는 점에 주의하셔야 합니다.

  - `use strict`에 영향을 받는 경우라면 개발자는 기대하지 않았던 결과를 얻을 수 있기 때문입니다.

- 그렇다면 어떻게 해야 콘솔에서 `use strict`를 사용할 수 있을까요?

  - 'use strict’를 입력한 후, `Shift+Enter키`를 눌러 줄 바꿈 해 원하는 스크립트를 입력하면 됩니다. 아래와 같이 말이죠.

    ```js
    'use strict'; <Shift+Enter를 눌러 줄 바꿈 함>
    //  ...테스트하려는 코드 입력
    <Enter를 눌러 실행>
    ```

  - 이 기능은 Firefox와 Chrome 같은 유명한 브라우저에서 대부분 사용 가능합니다.

- 브라우저가 오래 되어서 콘솔 창에 `use strict`를 입력하는 게 불가능하다면, `use strict`를 적용하는 가장 확실한 방법은 아래와 같이 코드를 래퍼로 감싸면 됩니다.

  ```js
  (function() {
    'use strict';
  
    // ...테스트하려는 코드...
  })()
  ```

  

### 'use strict'를 꼭 사용해야 하나요

- "당연히 사용해야 하는 거 아니야?"라는 생각이 드시겠지만, 꼭 그렇지만은 않습니다.
- 누군가는 스크립트 맨 윗줄엔 `"use strict"`를 넣는 게 좋다고 권유할 수 있습니다. 그런데 그거 아세요?
  - 모던 자바스크립트는 '클래스’와 '모듈’이라 불리는 진일보한 구조를 제공합니다(클래스와 모듈에 대해선 당연히 뒤에서 학습할 예정입니다). 
  - **<u>이 둘을 사용하면 `use strict`가 자동으로 적용되죠.</u>** 
  - 따라서 이 둘을 사용하고 있다면 스크립트에 `"use strict"`를 붙일 필요가 없습니다.
- 결론은 이렇습니다. **코드를 클래스와 모듈을 사용해 구성한다면 `"use strict"`를 생략해도 됩니다. 그런데 아직은 이 둘을 배우지 않았으니 `"use strict"`를 귀한 손님처럼 모시도록 하겠습니다.**
- 그리고 특별한 언급이 없는 한 이 튜토리얼에 등장하는 모든 예시엔 엄격 모드를 적용할 예정입니다.





## 2.4 변수와 상수

> https://ko.javascript.info/variables

### 변수

- [변수(variable)](https://en.wikipedia.org/wiki/Variable_(computer_science))는 데이터를 저장할 때 쓰이는 ‘이름이 붙은 저장소’ 입니다. 

- 자바스크립트에선 `let` 키워드를 사용해 변수를 생성합니다.

  - 아래 문(statement)은 'message’라는 이름을 가진 변수를 생성(*선언*)합니다.

    ```js
    let message;
    ```

  - 이제 할당 연산자 `=`를 사용해 변수 안에 데이터를 저장해 봅시다.

    ```js
    let message;
    
    message = 'Hello'; // 문자열을 저장합니다.
    ```

  - 문자열이 변수와 연결된 메모리 영역에 저장되었기 때문에, 변수명을 이용해 문자열에 접근할 수 있게 되었습니다.

    ```js
    let message;
    message = 'Hello!';
    
    alert(message); // 변수에 저장된 값을 보여줍니다.
    ```

  - 아래와 같이 변수 선언과 값 할당을 한 줄에 작성할 수도 있습니다.

    ```js
    let message = 'Hello!'; // 변수를 정의하고 값을 할당합니다.
    
    alert(message); // Hello!
    ```

  - 한 줄에 여러 변수를 선언하는 것도 가능합니다.

    ```js
    let user = 'John', age = 25, message = 'Hello';
    ```



> **`let` 대신 `var`**
>
> - 만들어진 지 오래된 스크립트에서 `let` 대신 `var`라는 키워드를 발견하는 경우가 있습니다.
>
> ```javascript
> var message = 'Hello';
> ```
>
> - `var`는 `let`과 *거의* 동일하게 동작합니다. `var`도 `let`처럼 변수를 선언하는 데 쓰이죠. 다만 `var`는 ‘오래된’ 방식입니다.
>
> - `let`과 `var`의 미묘한 차이점에 대해선 추후 [오래된 'var'](https://ko.javascript.info/var) 에서 자세히 다루도록 하겠습니다. 지금 시점에선 이 차이점이 중요하지 않기 때문에 넘어가도록 합시다.



### 변수 명명 규칙

- 자바스크립트에선 변수 명명 시 두 가지 제약 사항이 있습니다.
  1. 변수명에는 오직 문자와 숫자, 그리고 기호 `$`와 `_`만 들어갈 수 있습니다.
  2. 첫 글자는 숫자가 될 수 없습니다.



> **`use strict` 없이 할당하기**
>
> - 변수는 대개 정의되어 있어야 사용할 수 있습니다. 
> - 그러나 **<u>예전에는 `let` 없이도 단순하게 값을 할당해 변수를 생성하는 것이 가능했습니다.</u>** 
> - `use strict`를 쓰지 않으면 과거 스크립트와의 호환성을 유지할 수 있기 때문에 여전히 이 방식을 사용할 수 있습니다.
>
> ```javascript
> // 참고: 이 예제에는 "use strict"가 없습니다.
> 
> num = 5; // 변수 'num'이 정의되어있지 않더라도, 단순 할당만으로 변수가 생성됩니다.
> 
> alert(num); // 5
> ```
>
> 이렇게 변수를 생성하는 것은 나쁜 관습입니다. 엄격 모드에서 에러를 발생시키기 때문이죠.
>
> ```javascript
> "use strict";
> 
> num = 5; // error: num is not defined
> ```



### 상수

- 변화하지 않는 변수를 선언할 땐, `let` 대신 `const`를 사용합니다.

  ```js
  const myBirthday = '18.04.1982';
  ```

- 이렇게 `const`로 선언한 변수를 '상수(constant)'라고 부릅니다. 상수는 재할당할 수 없으므로 상수를 변경하려고 하면 에러가 발생합니다.

  ```js
  const myBirthday = '18.04.1982';
  
  myBirthday = '01.01.2001'; // error, can't reassign the constant!
  ```



#### 대문자 상수

- 기억하기 힘든 값을 변수에 할당해 별칭으로 사용하는 것은 널리 사용되는 관습입니다.

  - 이런 상수는 <u>대문자와 밑줄</u>로 구성된 이름으로 명명합니다.

- 예시로 웹에서 사용하는 색상 표기법인 16진수 컬러 코드에 대한 상수를 한번 만들어보겠습니다.

  ```js
  const COLOR_RED = "#F00";
  const COLOR_GREEN = "#0F0";
  const COLOR_BLUE = "#00F";
  const COLOR_ORANGE = "#FF7F00";
  
  // 색상을 고르고 싶을 때 별칭을 사용할 수 있게 되었습니다.
  let color = COLOR_ORANGE;
  alert(color); // #FF7F00
  ```



### 요약

- `var`, `let`, `const`를 사용해 변수를 선언할 수 있습니다. 선언된 변수엔 데이터를 저장할 수 있죠.
  - `let` – 모던한 변수 선언 키워드입니다.
  - `var` – 오래된 변수 선언 키워드입니다. 잘 사용하지 않습니다. `let`과의 미묘한 차이점은 [오래된 'var'](https://ko.javascript.info/var) 챕터에서 다루도록 하겠습니다.
  - `const` – `let`과 비슷하지만, 변수의 값을 변경할 수 없습니다.





## 2.5 자료형

> https://ko.javascript.info/types



**도입**

- 자바스크립트에서 <u>값은 항상 문자열이나 숫자형 같은 특정한 자료형에 속합니다</u>.

  - 자바스크립트에는 **<u>여덟 가지 기본 자료형</u>**이 있습니다. 

- 이번 챕터에선 이 자료형 모두를 개괄적으로 다루도록 하겠습니다. 각 자료형에 대한 세부 사항들은 이어지는 챕터에서 다룰 예정입니다.

- 자바스크립트의 변수는 자료형에 관계없이 모든 데이터일 수 있습니다. 

  - 따라서 <u>변수는 어떤 순간에 문자열일 수 있고 다른 순간엔 숫자가 될 수도 있습니다.</u>

    ```js
    // no error
    let message = "hello";
    message = 123456;
    ```

- 이처럼 자료의 타입은 있지만 변수에 저장되는 값의 타입은 언제든지 바꿀 수 있는 언어를 ‘동적 타입(dynamically typed)’ 언어라고 부릅니다.



### 숫자형

```js
let n = 123;
n = 12.345;
```

- ***숫자형(number type)*** 은 정수 및 부동소수점 숫자(floating point number)를 나타냅니다.

- 숫자형과 관련된 연산

  - 곱셈 `*`, 나눗셈 `/`, 덧셈 `+`, 뺄셈 `-` 등이 대표적입니다.

- 특수 숫자 값 (special numeric value)

  - `Infinity` : 어떤 숫자보다 더 큰 특수 값, [무한대(∞)](https://en.wikipedia.org/wiki/Infinity)를 나타냅니다.

    - 어느 숫자든 0으로 나누면 무한대를 얻을 수 있습니다.

      ```js
      alert( 1 / 0 ); // 무한대
      ```

    - `Infinity`를 직접 참조할 수도 있습니다.

      ```js
      alert( Infinity ); // 무한대
      ```

  - `-Infinity` : 어떤 숫자보다 더 작은 특수 값

  - `NaN` : 계산 중에 에러가 발생했다는 것을 나타내주는 값

    - 부정확하거나 정의되지 않은 수학 연산을 사용하면 계산 중에 에러가 발생하는데, 이때 `NaN`이 반환됩니다.

      ```js
      alert( "숫자가 아님" / 2 ); // NaN, 문자열을 숫자로 나누면 오류가 발생합니다.
      ```

> **수학 연산은 안전합니다.**
>
> - 자바스크립트에서 행해지는 수학 연산은 '안전’하다고 볼 수 있습니다. 
>   - 0으로 나눈다거나 숫자가 아닌 문자열을 숫자로 취급하는 등의 이례적인 연산이 자바스크립트에선 가능합니다.
> - 말이 안 되는 수학 연산을 하더라도 스크립트는 치명적인 에러를 내뿜으며 죽지 않습니다.
>   - `NaN`을 반환하며 연산이 종료될 뿐입니다.

- 현실에선 특수 숫자 값을 숫자로 취급하진 않습니다. 
  - 하지만 자바스크립트에선 특수 숫자 값을 숫자형으로 분류합니다.
- 숫자를 다루는 방법에 대해선 [숫자형](https://ko.javascript.info/number) 챕터에서 자세히 알아보도록 하겠습니다.



### BigInt

- 내부 표현 방식 때문에 자바스크립트에선 `(2^53-1)`(`9007199254740991`) 보다 큰 값 혹은 `-(2^53-1)` 보다 작은 **<u>정수</u>**는 '숫자형’을 사용해 나타낼 수 없습니다.

- 사실 대부분의 상황에서 이런 제약사항은 문제가 되지 않습니다. 

- 그렇지만 암호 관련 작업같이 <u>아주 큰 숫자가 필요한 상황이거나 아주 높은 정밀도로 작업을 해야 할 때</u>는 이런 큰 숫자가 필요합니다.

- `BigInt`형은 표준으로 채택된 지 얼마 안 된 자료형으로, 길이에 상관없이 정수를 나타낼 수 있습니다.

- **<u>`BigInt`형 값은 정수 리터럴 끝에 `n`을 붙이면 만들 수 있습니다.</u>**

  ```js
  // 끝에 'n'이 붙으면 BigInt형 자료입니다.
  const bigInt = 1234567890123456789012345678901234567890n;
  ```

- `BigInt`형 숫자는 자주 쓰이지 않기 때문에 여기서 자세히 다루지 않고 별도의 챕터, [BigInt](https://ko.javascript.info/bigint)에서 설명드리겠습니다. 아주 큰 숫자를 사용해야하는 경우라면 해당 챕터를 참고해 주시기바랍니다.



### 문자형

- 자바스크립트에선 문자열(string)을 따옴표로 묶습니다.

  ```js
  let str = "Hello";
  let str2 = 'Single quotes are ok too';
  let phrase = `can embed another ${str}`;
  ```

- 따옴표는 <u>세 종류</u>가 있습니다.

  1. 큰따옴표: `"Hello"`
  2. 작은따옴표: `'Hello'`
  3. 역 따옴표(백틱, backtick): ``Hello``

- 큰따옴표와 작은따옴표는 ‘기본적인’ 따옴표로, 자바스크립트에서는 이 둘에 차이를 두지 않습니다.

- 역 따옴표로 변수나 표현식을 감싼 후 `${…}`안에 넣어주면, 아래와 같이 원하는 변수나 표현식을 문자열 중간에 손쉽게 넣을 수 있습니다.

  ```js
  let name = "John";
  
  // 변수를 문자열 중간에 삽입
  alert( `Hello, ${name}!` ); // Hello, John!
  
  // 표현식을 문자열 중간에 삽입
  alert( `the result is ${1 + 2}` ); // the result is 3
  ```

  - `${…}` 안에는 `name` 같은 변수나 `1 + 2` 같은 수학 관련 표현식을 넣을 수 있습니다. 물론 더 복잡한 표현식도 넣을 수 있죠. 무엇이든 들어갈 수 있습니다. 
  - 이렇게 문자열 중간에 들어간 변수나 표현식은 평가가 끝난 후 문자열의 일부가 됩니다.

- 문자열은 [문자열](https://ko.javascript.info/string)챕터에서 더 자세히 다루도록 하겠습니다.



> ***글자형*은 없습니다.**
>
> - 일부 언어는 글자 하나를 저장할 때 쓰이는 자료형, '글자(character)'형을 따로 지원합니다. 
>   - C 언어와 Java의 `char`가 대표적인 예입니다.
> - 자바스크립트는 글자형을 지원하지 않습니다. `문자형`만 있을 뿐입니다. 
>   - 여기엔 글자가 하나 혹은 여러 개 들어갈 수 있습니다.



### Boolean형

- 불린형(논리 타입)은 `true`와 `false` 두 가지 값밖에 없는 자료형입니다.

- 불린형은 긍정(yes)이나 부정(no)을 나타내는 값을 저장할 때 사용합니다. `true`는 긍정, `false`는 부정을 의미합니다.

  ```js
  let nameFieldChecked = true; // 네, name field가 확인되었습니다(checked).
  let ageFieldChecked = false; // 아니요, age field를 확인하지 않았습니다(not checked)
  ```



### null 값

- `null` 값은 지금까지 소개한 자료형 중 어느 자료형에도 속하지 않는 값입니다.

- `null` 값은 오로지 `null` 값만 포함하는 별도의 자료형을 만듭니다.

  ```js
  let age = null;
  ```

- 자바스크립트의 `null`은 자바스크립트 이외 언어의 `null`과 성격이 다릅니다. 

  - 다른 언어에선 `null`을 '존재하지 않는 객체에 대한 참조’나 '널 포인터(null pointer)'를 나타낼 때 사용합니다.
  - 하지만 **<u>자바스크립트에선 `null`을 ‘존재하지 않는(nothing)’ 값, ‘비어 있는(empty)’ 값, ‘알 수 없는(unknown)’ 값을 나타내는 데 사용합니다.</u>**
  - `let age = null;`은 `나이(age)`를 알 수 없거나 그 값이 비어있음을 보여줍니다.



### undefined 값

- `undefined` 값도 `null` 값처럼 자신만의 자료형을 형성합니다.

- `undefined`는 '값이 할당되지 않은 상태’를 나타낼 때 사용합니다.

- 변수는 선언했지만, 값을 할당하지 않았다면 해당 변수에 `undefined`가 자동으로 할당됩니다.

  ```js
  let age;
  
  alert(age); // 'undefined'가 출력됩니다.
  ```

- 개발자가 변수에 `undefined`를 명시적으로 할당하는 것도 가능하긴 합니다.

  ```js
  let age = 100;
  
  // 값을 undefined로 바꿉니다.
  age = undefined;
  
  alert(age); // "undefined"
  ```

  - **<u>하지만 이렇게 `undefined`를 직접 할당하는 걸 권장하진 않습니다.</u>** 
  - 변수가 ‘비어있거나’ ‘알 수 없는’ 상태라는 걸 나타내려면 `null`을 사용하세요.
  - `undefined`는 값이 할당되지 않은 변수의 초기값을 위해 예약어로 남겨둡시다.



### 객체와 심볼

- `객체(object)`형은 특수한 자료형입니다.
- 객체형을 제외한 다른 자료형은 문자열이든 숫자든 <u>한 가지만 표현할 수 있기 때문에</u> **원시(primitive) 자료형**이라 부릅니다. 
- 반면 객체는 데이터 컬렉션이나 복잡한 개체(entity)를 표현할 수 있습니다.
  - 이런 특징 때문에 자바스크립트에서 객체는 좀 더 특별한 취급을 받습니다. 
  - 자세한 내용은 원시형을 배우고 난 후 [객체](https://ko.javascript.info/object)에서 다루도록 하겠습니다.
- `심볼(symbol)`형은 객체의 고유한 식별자(unique identifier)를 만들 때 사용됩니다. 심볼형에 대해선 객체를 학습하고 난 이후에 자세히 알아보겠습니다.





### typeof 연산자

- `typeof` 연산자는 인수의 자료형을 반환합니다. 

  - 자료형에 따라 처리 방식을 다르게 하고 싶거나 변수의 자료형을 빠르게 알아내고자 할 때 유용합니다.

- `typeof` 연산자는 두 가지 형태의 문법을 지원합니다.

  - 연산자: `typeof x`
  - 함수: `typeof(x)`
  - 괄호가 있든 없든 결과가 동일합니다.

- `typeof x`를 호출하면 인수의 자료형을 나타내는 문자열을 반환합니다.

  ```js
  typeof undefined // "undefined"
  typeof 0 // "number"
  typeof 10n // "bigint"
  typeof true // "boolean"
  typeof "foo" // "string"
  typeof Symbol("id") // "symbol"
  typeof Math // "object"  (1)
  typeof null // "object"  (2)
  typeof alert // "function"  (3)
  ```

  - (1): `Math`는 수학 연산을 제공하는 내장 객체이므로 `"object"`가 출력됩니다.

    `Math`에 대해선 [숫자형](https://ko.javascript.info/number) 챕터에서 학습하도록 하겠습니다.

  - (2): `typeof null`의 결과는 `"object"`입니다.

    `null`은 별도의 고유한 자료형을 가지는 특수 값으로 객체가 아니지만, 하위 호환성을 유지하기 위해 이런 오류를 수정하지 않고 남겨둔 상황입니다. 

    **<u>언어 자체의 오류이므로 `null`이 객체가 아님에 유의하시기 바랍니다.</u>**

  - (3): `typeof`는 피연산자가 함수면 `"function"`을 반환합니다. 

    그러므로 `typeof alert`는 `"function"`을 출력해줍니다. 

    그런데 '함수’형은 따로 없습니다. 함수는 객체형에 속합니다. 

    이런 동작 방식이 형식적으론 잘못되긴 했지만, 아주 오래전에 만들어진 규칙이었기 때문에 하위 호완성 유지를 위해 남겨진 상태입니다. 

    한편, 실무에선 이런 특징이 매우 유용하게 사용되기도 합니다.



### 요약

자바스크립트에는 여덟 가지 기본 자료형이 있습니다.

- `숫자형` – 정수, 부동 소수점 숫자 등의 숫자를 나타낼 때 사용합니다. 정수의 한계는 ±253 입니다.
- `bigint` – 길이 제약 없이 정수를 나타낼 수 있습니다.
- `문자형` – 빈 문자열이나 글자들로 이뤄진 문자열을 나타낼 때 사용합니다. 단일 문자를 나타내는 별도의 자료형은 없습니다.
- `불린형` – `true`, `false`를 나타낼 때 사용합니다.
- `null` – `null` 값만을 위한 독립 자료형입니다. `null`은 알 수 없는 값을 나타냅니다.
- `undefined` – `undefined` 값만을 위한 독립 자료형입니다. `undefined`는 할당되지 않은 값을 나타냅니다.
- `객체형` – 복잡한 데이터 구조를 표현할 때 사용합니다.
- `심볼형` – 객체의 고유 식별자를 만들 때 사용합니다.

`typeof` 연산자는 피연산자의 자료형을 알려줍니다.

- `typeof x` 또는 `typeof(x)` 형태로 사용합니다.
- 피연산자의 자료형을 문자열 형태로 반환합니다.
- `null`의 typeof 연산은 `"object"`인데, 이는 언어상 오류입니다. null은 객체가 아닙니다.



## 2.6 alert, prompt, confirm을 이용한 상호작용

> https://ko.javascript.info/alert-prompt-confirm



**도입**

- 브라우저를 데모 환경으로 사용 중이므로 브라우저 환경에서 사용되는 최소한의 사용자 인터페이스 기능인 `alert`, `prompt`, `confirm`에 대해 알아보겠습니다.



### alert

- `alert` 함수는 앞선 예제에서 살펴본 바 있습니다. 이 함수가 실행되면 사용자가 ‘확인(OK)’ 버튼을 누를 때까지 메시지를 보여주는 창이 계속 떠있게 됩니다.

  ```js
  alert("Hello");
  ```

  - 메시지가 있는 작은 창은 *모달 창(modal window)* 이라고 부릅니다.
  - '모달’이란 단어엔 **<u>페이지의 나머지 부분과 상호 작용이 불가능하다</u>**는 의미가 내포되어 있습니다. 
  - 따라서 사용자는 모달 창 바깥에 있는 버튼을 누른다든가 하는 행동을 할 수 없습니다. 확인 버튼을 누르기 전까지 말이죠.



### **prompt**

- 브라우저에서 제공하는 `prompt` 함수는 두 개의 인수를 받습니다.

  ```js
  result = prompt(title, [default]);
  ```

- 함수가 실행되면 텍스트 메시지와 입력 필드(input field), 확인(OK) 및 취소(Cancel) 버튼이 있는 모달 창을 띄워줍니다.

  - `title`

    사용자에게 보여줄 문자열

  - `default`

    입력 필드의 초깃값(선택값)

- 사용자는 프롬프트 대화상자의 입력 필드에 원하는 값을 입력하고 확인을 누를 수 있습니다. 값을 입력하길 원하지 않는 경우는 취소(Cancel) 버튼을 누르거나 Esc를 눌러 대화상자를 빠져나가면 됩니다.

- `prompt` 함수는 사용자가 입력 필드에 기재한 **<u>문자열</u>**을 반환합니다. 사용자가 입력을 취소한 경우는 `null`이 반환됩니다.

  ```js
  let age = prompt('나이를 입력해주세요.', 100);
  
  alert(`당신의 나이는 ${age}살 입니다.`); // 당신의 나이는 100살입니다.
  ```



### confirm

- 문법

  ```js
  result = confirm(question);
  ```

- `confirm` 함수는 매개변수로 받은 `question(질문)`과 확인 및 취소 버튼이 있는 모달 창을 보여줍니다.

  - 사용자가 확인버튼를 누르면 `true`, 그 외의 경우는 `false`를 반환합니다.

  ```js
  let isBoss = confirm("당신이 주인인가요?");
  
  alert( isBoss ); // 확인 버튼을 눌렀다면 true가 출력됩니다.
  ```





## 2.7 형 변환

> https://ko.javascript.info/type-conversions



**도입**

- 함수와 연산자에 전달되는 값은 대부분 적절한 자료형으로 자동 변환됩니다. 

  - 이런 과정을 "형 변환(type conversion)"이라고 합니다.

- `alert`가 전달받은 값의 자료형과 관계없이 이를 문자열로 자동 변환하여 보여주는 것이나, 

  수학 관련 연산자가 전달받은 값을 숫자로 변환하는 경우가 형 변환의 대표적인 예시입니다.

- 이 외에, 전달받은 값을 의도를 갖고 원하는 타입으로 변환(명시적 변환)해 주는 경우도 형 변환이라고 할 수 있습니다.



> **객체의 형변환은 나중에 다룹니다.**
>
> - 이 챕터에선 객체는 다루지 않겠습니다. 여기선 원시형의 형변환에 대해서만 다룰 예정입니다.
> - 객체의 형 변환이 어떻게 이뤄지는지 [객체를 원시형으로 변환하기](https://ko.javascript.info/object-toprimitive)에 대해선 객체에 대한 학습이 끝난 후 알아보겠습니다.



### 문자형으로 변환

- 문자형으로의 형 변환은 문자형의 값이 필요할 때 일어납니다.

- `alert`메서드는 매개변수로 문자형을 받기 때문에, `alert(value)`에서 value는 문자형이어야 합니다. 

  - 만약, 다른 형의 값을 전달받으면 이 값은 문자형으로 자동 변환됩니다.

  - `String(value)` 함수를 호출해 전달받은 값을 문자열로 변환 할 수도 있습니다.

    ```js
    let value = true;
    alert(typeof value); // boolean
    
    value = String(value); // 변수 value엔 문자열 "true"가 저장됩니다.
    alert(typeof value); // string
    ```

- `false`는 문자열 `"false"`로, `null`은 문자열 `"null"`로 변환되는 것과 같이, 문자형으로의 변환은 대부분 예측 가능한 방식으로 일어납니다.



### 숫자형으로 변환

- 숫자형으로의 변환은 수학과 관련된 함수와 표현식에서 자동으로 일어납니다.

  숫자형이 아닌 값에 나누기 `/`를 적용한 경우와 같이 말이죠.

  ```js
  alert( "6" / "2" ); // 3, 문자열이 숫자형으로 자동변환된 후 연산이 수행됩니다.
  ```

- `Number(value)` 함수를 사용하면 주어진 값(`value`)을 숫자형으로 명시해서 변환할 수 있습니다.

  ```js
  let str = "123";
  alert(typeof str); // string
  
  let num = Number(str); // 문자열 "123"이 숫자 123으로 변환됩니다.
  
  alert(typeof num); // number
  ```



- 숫자형 값를 사용해 무언가를 하려고 하는데 그 <u>값을 문자 기반 폼(form)을 통해 입력받는 경우</u>엔, 이런 명시적 형 변환이 필수입니다.

- 한편, 숫자 이외의 글자가 들어가 있는 문자열을 숫자형으로 변환하려고 하면, 그 결과는 `NaN`이 됩니다.

  ```js
  let age = Number("임의의 문자열 123");
  
  alert(age); // NaN, 형 변환이 실패합니다.
  ```



아래는 숫자형으로 변환 시 적용되는 규칙입니다.

| 전달받은 값      | 형 변환 후                                                   |
| :--------------- | :----------------------------------------------------------- |
| `undefined`      | `NaN`                                                        |
| `null`           | `0`                                                          |
| `true and false` | `1` 과 `0`                                                   |
| `string`         | 문자열의 처음과 끝 공백이 제거됩니다. 공백 제거 후 남아있는 문자열이 없다면 `0`, 그렇지 않다면 문자열에서 숫자를 읽습니다. 변환에 실패하면 `NaN`이 됩니다. |

- 예시

  ```js
  alert( Number("   123   ") ); // 123
  alert( Number("123z") );      // NaN ("z"를 숫자로 변환하는 데 실패함)
  alert( Number(true) );        // 1
  alert( Number(false) );       // 0
  ```

  - `null`과 `undefined`은 숫자형으로 변환 시 결과가 다르다는 점에 유의하시기 바랍니다. `null`은 `0`이 되고 `undefined`는 `NaN`이 됩니다.



### 불린형으로 변환

- 불린형으로의 변환은 아주 간단합니다.

- 이 형 변환은 논리 연산을 수행할 때 발생합니다(논리 연산에 관한 내용은 뒤 챕터에서 다루고 있습니다).

- `Boolean(value)`를 호출하면 명시적으로 불리언으로의 형 변환을 수행할 수 있습니다.

- 불린형으로 변환 시 적용되는 규칙은 다음과 같습니다.

  - 숫자 `0`, 빈 문자열, `null`, `undefined`, `NaN`과 같이 직관적으로도 “비어있다고” 느껴지는 값들은 `false`가 됩니다.
  - 그 외의 값은 `true`로 변환됩니다.

  ```js
  alert( Boolean(1) ); // 숫자 1(true)
  alert( Boolean(0) ); // 숫자 0(false)
  
  alert( Boolean("hello") ); // 문자열(true)
  alert( Boolean("") ); // 빈 문자열(false)
  ```

> **주의: 문자열 `"0"`은 `true`입니다.**
>
> - PHP 등의 일부 언어에선 문자열 `"0"`을 `false`로 취급합니다. 
> - 그러나 자바스크립트에선 비어 있지 않은 문자열은 언제나 `true`입니다.
>
> ```javascript
> alert( Boolean("0") ); // true
> alert( Boolean(" ") ); // 공백이 있는 문자열도 비어있지 않은 문자열이기 때문에 true로 변환됩니다.
> ```



## 2.8 기본 연산자와 수학

> https://ko.javascript.info/operators



**도입**

- 덧셈 `+`, 곱셈 `*`, 뺄셈 `-`과 같은 연산은 학교에서 배워서 이미 알고 계실 겁니다.
- 이번 챕터에서는 이런 기본 연산자를 시작으로 학교에선 다루지 않았던 자바스크립트에서만 제공하는 연산자에 대해 배워보겠습니다.



### 수학

자바스크립트에서 지원하는 수학 연산자는 다음과 같습니다.

- 덧셈 연산자 `+`,
- 뺄셈 연산자 `-`,
- 곱셈 연산자 `*`,
- 나눗셈 연산자 `/`,
- 나머지 연산자 `%`,
- 거듭제곱 연산자 `**`



### 나머지 연산자 %

- 나머지 연산자(remainder operator)는 `%` 기호로 나타내지만, 비율을 나타내는 퍼센트와 관련이 없습니다.
- 나머지 연산자를 사용한 표현식 `a % b`는 `a`를 `b`로 나눈 후 그 나머지([remainder](https://en.wikipedia.org/wiki/Remainder))를 정수로 반환해줍니다.



### 거듭제곱 연산자 **

- 거듭제곱 연산자(exponentiation operator)를 사용한 `a ** b`를 평가하면 `a`를 `b`번 곱한 값이 반환됩니다.

- 예제

  ```js
  alert( 2 ** 2 ); // 4  (2 * 2)
  alert( 2 ** 3 ); // 8  (2 * 2 * 2)
  alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)
  alert( 4 ** (1/2) ); // 2 (1/2 거듭제곱은 제곱근)
  alert( 8 ** (1/3) ); // 2 (1/3 거듭제곱은 세제곱근)
  ```

  

### 이항 연산자 '+'와 문자열 연결

- 덧셈 연산자 `+`는 대개 숫자를 더한 결과를 반환합니다.

- 그런데 **<u>이항 연산자 `+`의 피연산자로 문자열이 전달되면 덧셈 연산자는 덧셈이 아닌 문자열을 병합(연결)합니다.</u>**

  ```js
  let s = "my" + "string";
  alert(s); // mystring
  ```

- 따라서 이항 연산자 `+`를 사용할 때는 **<u>피연산자 중 하나가 문자열이면 다른 하나도 문자열로 변환된다</u>**는 점에 주의해야 합니다.

  ```js
  alert( '1' + 2 ); // "12"
  alert( 2 + '1' ); // "21"
  ```

  - 첫 번째 피연산자가 문자열인지, 두 번째 피연산자가 문자열인지는 중요하지 않습니다. 피연산자 중 어느 하나가 문자열이면 다른 하나도 문자열로 변환됩니다.

- 좀 더 복잡한 예시

  ```js
  alert(2 + 2 + '1' ); // '221'이 아니라 '41'이 출력됩니다.
  ```

  - 연산은 왼쪽에서 오른쪽으로 순차적으로 진행되기 때문에 이런 결과가 나왔습니다. 
    - 두 개의 숫자 뒤에 문자열이 오는 경우, 숫자가 먼저 더해지고, 그 후 더해진 숫자와 문자열과의 병합이 일어납니다.

- 이처럼 이항 덧셈 연산자 `+`는 문자열 연결과 변환이라는 특별한 기능을 제공합니다. 

  - 다른 산술 연산자가 오직 숫자형의 피연산자만 다루고, 피연산자가 숫자형이 아닌 경우에 그 형을 숫자형으로 바꾸는 것과는 대조적입니다.

  - 아래는 뺄셈 `-`과 나눗셈 `/` 연산자가 어떻게 문자형 피연산자를 다루는지를 보여줍니다.

    ```js
    alert( 6 - '2' ); // 4, '2'를 숫자로 바꾼 후 연산이 진행됩니다.
    alert( '6' / '2' ); // 3, 두 피연산자가 숫자로 바뀐 후 연산이 진행됩니다.
    ```



### 단항 연산자 +와 숫자형으로의 변환

- 덧셈 연산자 `+`는 이항 연산자뿐만 아니라 단항 연산자로도 사용할 수 있습니다.

- 숫자에 단항 덧셈 연산자를 붙이면 이 연산자는 아무런 동작도 하지 않습니다. 

- 그러나 **<u>피연산자가 숫자가 아닌 경우엔 숫자형으로의 변환이 일어납니다.</u>**

  ```js
  // 숫자에는 아무런 영향을 미치지 않습니다.
  let x = 1;
  alert( +x ); // 1
  
  let y = -2;
  alert( +y ); // -2
  
  // 숫자형이 아닌 피연산자는 숫자형으로 변화합니다.
  alert( +true ); // 1
  alert( +"" );   // 0
  ```

- 단항 덧셈 연산자는 짧은 문법으로도 `Number(...)`와 동일한 일을 할 수 있게 해줍니다.

- 개발을 하다 보면 문자열을 숫자로 변환해야 하는 경우가 자주 생깁니다. 

  - HTML 폼(form) 필드에서 값을 가져왔는데 그 값이 문자형일 때 같이 말이죠. 

  - 실제로 폼에서 가지고 온 값은 대개 문자열 형태입니다.

  - 이항 덧셈 연산자를 사용하면 아래와 같이 값이 문자열로 변해서 연결될 겁니다.

    ```js
    let apples = "2";
    let oranges = "3";
    
    alert( apples + oranges ); // 23, 이항 덧셈 연산자는 문자열을 연결합니다.
    ```

  - 원하는 대로 값을 더해주려면, 단항 덧셈 연산자를 사용해 피연산자를 숫자형으로 변화시키면 됩니다.

    ```js
    let apples = "2";
    let oranges = "3";
    
    // 이항 덧셈 연산자가 적용되기 전에, 두 피연산자는 숫자형으로 변화합니다.
    alert( +apples + +oranges ); // 5
    
    // `Number(...)`를 사용해서 같은 동작을 하는 코드를 작성할 수 있지만, 더 기네요.
    // alert( Number(apples) + Number(oranges) ); // 5
    ```

    - 위 식은 우리가 의도한 대로 단항 덧셈 연산자가 먼저 문자열을 숫자로 변환시키고, 이항 덧셈 연산자가 그 결과들을 더해주고 있습니다.



### 연산자 우선순위

- 하나의 표현식에 둘 이상의 연산자가 있는 경우, 실행 순서는 연산자의 *우선순위(precedence)* 에 의해 결정됩니다.



### 할당 연산자

- 무언가를 할당할 때 쓰이는 `=`도 연산자입니다. 

  - 이 연산자는 할당(assignment) 연산자라고 불리는데, 우선순위는 `3`으로 아주 낮습니다.

- `x = 2 * 2 + 1`과 같은 표현식에서 계산이 먼저 이뤄지고, 그 결과가 `x`에 할당되는 이유가 바로 이 때문입니다.

  ```js
  let x = 2 * 2 + 1;
  
  alert( x ); // 5
  ```

  

#### 값을 반환하는 할당 연산자

- `=`는 연산자이기 때문에 흥미로운 함축성을 내포하고 있습니다.

- 자바스크립트에서 대부분의 연산자들은 값을 반환합니다. `+`와 `-`뿐만 아니라 `=` 역시 값을 반환하죠.

  - `x = value`을 호출하면 `value`가 `x`에 쓰여지고, 이에 더하여 *`value`가 반환됩니다*.

  - 할당 연산자의 이런 특징을 이용한 복잡한 표현식을 살펴봅시다.

    ```js
    let a = 1;
    let b = 2;
    
    let c = 3 - (a = b + 1);
    
    alert( a ); // 3
    alert( c ); // 0
    ```

    - 위 예제에서 표현식 `(a = b + 1)`은 `a`에 값을 할당하고, 그 값인 `3`을 반환합니다. 그리고 반환 값은 이어지는 표현식에 사용됩니다.



#### 할당 연산자 체이닝

- 할당 연산자는 아래와 같이 여러 개를 연결할 수도 있습니다(체이닝).

  ```js
  let a, b, c;
  
  a = b = c = 2 + 2;
  
  alert( a ); // 4
  alert( b ); // 4
  alert( c ); // 4
  ```

  - 이렇게 할당 연산자를 여러 개 연결한 경우, 평가는 우측부터 진행됩니다. 
  - 먼저 가장 우측의 `2 + 2`가 평가되고, 그 결과가 좌측의 `c`, `b`, `a`에 순차적으로 할당됩니다. 모든 변수가 단일 값을 공유하게 되죠.



### 복합 할당 연산자

- 프로그램을 짜다 보면, 변수에 연산자를 적용하고 그 결과를 같은 변수에 저장해야 하는 경우가 종종 생깁니다.

  아래와 같이 말이죠.

  ```js
  let n = 2;
  n = n + 5;
  n = n * 2;
  ```

  이때, `+=`와 `*=`연산자를 사용하면 짧은 문법으로 동일한 연산을 수행할 수 있습니다.

  ```js
  let n = 2;
  n += 5; // n은 7이 됩니다(n = n + 5와 동일).
  n *= 2; // n은 14가 됩니다(n = n * 2와 동일).
  
  alert( n ); // 14
  ```

- 복합 할당 연산자의 우선순위는 할당 연산자와 동일합니다. 따라서 대부분 다른 연산자가 실행된 후에 복합 할당 연산자가 실행됩니다.

  ```js
  let n = 2;
  
  n *= 3 + 5;
  
  alert( n ); // 16  (*=의 우측이 먼저 평가되므로, 위 식은 n *= 8과 동일합니다.)
  ```

  

### 증가&middot;감소 연산자

- 숫자를 하나 늘리거나 줄이는 것은 자주 사용되는 연산입니다. 자바스크립트에서는 이런 연산을 해주는 연산자를 제공합니다.

  - **증가(increment) 연산자** `++`는 변수를 1 증가시킵니다.

    ```javascript
    let counter = 2;
    counter++;      // counter = counter + 1과 동일하게 동작합니다. 하지만 식은 더 짧습니다.
    alert( counter ); // 3
    ```

  - **감소(decrement) 연산자** `--`는 변수를 1 감소시킵니다.

    ```javascript
    let counter = 2;
    counter--;      // counter = counter - 1과 동일하게 동작합니다. 하지만 식은 더 짧습니다.
    alert( counter ); // 1
    ```



- `++`와`--` 연산자는 변수 앞이나 뒤에 올 수 있습니다.

  - `counter++`와 같이 피연산자 뒤에 올 때는, '후위형(postfix form)'이라고 부릅니다.
  - `++counter`와 같이 피연산자 앞에 올 때는, '전위형(prefix form)'이라고 부릅니다.

- 후위형과 전위형은 피연산자인 `counter`를 `1`만큼 증가시켜 준다는 점에서 동일한 일을 합니다.

  - **<u>두 형의 차이는 `++/--`의 반환 값을 사용할 때 드러납니다.</u>**

  - 이미 배운 바와 같이 모든 연산자는 값을 반환합니다. 

    증가/감소 연산자도 마찬가지입니다. 

  - **전위형**은 증가/감소 후의 새로운 값을 반환하는 반면, **후위형**은 증가/감소 전의 기존 값을 반환합니다.

    ```js
    let counter = 1;
    let a = ++counter; // 전위형: 연산 후의 값을 반환
    
    alert(a); // 2
    
    ------------------
    
    let counter = 1;
    let a = counter++; // 후위형: 연산 전의 기존값을 반환
    
    alert(a); // 1
    ```

- 정리

  - 
    반환 값을 사용하지 않는 경우라면, 전위형과 후위형엔 차이가 없습니다.

    ```javascript
    let counter = 0;
    counter++;
    ++counter;
    alert( counter ); // 2, 위 두 라인은 동일한 연산을 수행합니다.
    ```

  - 값을 증가시키고 난 후, 증가한 값을 바로 사용하려면 전위형 증가 연산자를 사용하면 됩니다.

    ```javascript
    let counter = 0;
    alert( ++counter ); // 1
    ```

  - 값을 증가시키지만, 증가 전의 기존값을 사용하려면 후위형 증가 연산자를 사용하면 됩니다.

    ```javascript
    let counter = 0;
    alert( counter++ ); // 0
    ```



### 비트 연산자

- 비트 연산자(bitwise operator)는 인수를 32비트 정수로 변환하여 이진 연산을 수행합니다.
- 이런 비트 조작 관련 연산자는 자바스크립트뿐만 아니라 대부분의 프로그래밍 언어에서 지원합니다.
- 아래는 비트 연산 시 쓰이는 연산자 목록입니다.
  - 비트 AND ( `&` )
  - 비트 OR ( `|` )
  - 비트 XOR ( `^` )
  - 비트 NOT ( `~` )
  - 왼쪽 시프트(LEFT SHIFT) ( `<<` )
  - 오른쪽 시프트(RIGHT SHIFT) ( `>>` )
  - 부호 없는 오른쪽 시프트(ZERO-FILL RIGHT SHIFT) ( `>>>` )

- 비트 연산자는 저수준(2진 표현)에서 숫자를 다뤄야 할 때 쓰이므로 흔하게 쓰이진 않습니다. 

  웹 개발 시엔 이런 일이 자주 일어나지 않기 때문에 비트 연산자를 만날 일은 거의 없죠. 

  그렇긴 해도 암호를 다뤄야 할 땐 비트 연산자가 유용하기 때문에 때가 되면 MDN의 [비트 연산자](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) 문서를 보시는 걸 추천합니다.



### 쉼표 연산자

- 쉼표 연산자(comma operator) `,`는 좀처럼 보기 힘들고, 특이한 연산자 중 하나입니다. 

  코드를 짧게 쓰려는 의도로 가끔 사용됩니다. 

- 이런 코드를 만났을 때, 어떤 연산 결과가 도출되는지 알아야 하므로 쉼표 연산자에 대해 알아보도록 합시다.

- 쉼표 연산자 `,`는 **<u>여러 표현식을 코드 한 줄에서 평가할 수 있게 해줍니다.</u>** 이때 표현식 각각이 모두 평가되지만, <u>마지막 표현식의 평가 결과만 반환</u>되는 점에 유의해야 합니다

  ```js
  let a = (1 + 2, 3 + 4);
  
  alert( a ); // 7 (3 + 4의 결과)
  ```

  - 위 예시에서 첫 번째 표현식 `1 + 2`은 평가가 되지만 그 결과는 버려집니다. `3 + 4`만 평가되어 `a`에 할당되죠.



> **쉼표의 우선순위는 매우 낮습니다.**
>
> - 쉼표 연산자의 연산자 우선순위는 매우 낮습니다. 할당 연산자 `=` 보다 더 낮죠. 
>
>   - 따라서 위 예시에선 괄호가 중요한 역할을 합니다.
>
> - 괄호가 없으면 `a = 1 + 2, 3 + 4`에서 `+`가 먼저 수행되어 `a = 3, 7`이 됩니다. 
>
>   할당 연산자 `=`는 쉼표 연산자보다 우선순위가 높기 때문에 `a = 3`이 먼저 실행되고, 나머지(`7`)는 무시되죠. 
>
>   `(a = 1 + 2), 3 + 4`를 연산한 것처럼 될 겁니다.



- 이렇게 마지막 표현식을 제외한 모든 것을 버리는 연산자는 어디서 사용되는 걸까요?

  - 여러 동작을 하나의 줄에서 처리하려는 복잡한 구조에서 이를 사용합니다.

  - 아래와 같이 말이죠.

    ```js
    // 한 줄에서 세 개의 연산이 수행됨
    for (a = 1, b = 3, c = a * b; a < 10; a++) {
     ...
    }
    ```

    



## 2.9 비교 연산자

> https://ko.javascript.info/comparison



**도입**

- 우리는 수학 시간에 아래와 같은 다양한 비교 연산자에 대해 학습한 바 있습니다.
- 자바스크립트에서 기본 수학 연산은 아래와 같은 문법을 사용해 표현할 수 있습니다.
  - 보다 큼·작음: `a > b`, `a < b`
  - 보다 크거나·작거나 같음: `a >= b`, `a <= b`
  - 같음(동등): `a == b`. 등호 `=`가 두 개 연달아 오는 것에 유의하세요. `a = b`와 같이 등호가 하나일 때는 할당을 의미합니다.
  - 같지 않음(부등): 같지 않음을 나타내는 수학 기호 `≠`는 자바스크립트에선 `a != b`로 나타냅니다. 할당연산자 `=` 앞에 느낌표 `!`를 붙여서 표시합니다.
- 이번 글에선 비교 시 일어나는 기이한 현상을 포함하여 다양한 자료형을 대상으로 자바스크립트가 어떻게 비교를 하는지에 대해 다룰 예정입니다.
- 글 말미에는 자바스크립트에서만 일어나는 ‘기이한’ 현상을 어떻게 예방할 수 있는지에 대해서 언급해두었습니다.



### 불린형 반환

- 다른 연산자와 마찬가지로 비교 연산자 역시 값을 반환합니다. 반환 값은 불린형입니다.

  - `true`가 반환되면, ‘긍정’, ‘참’, '사실’을 의미합니다.

  - `false`가 반환되면, ‘부정’, ‘거짓’, '사실이 아님’을 의미합니다.

    ```js
    alert( 2 > 1 );  // true
    alert( 2 == 1 ); // false
    alert( 2 != 1 ); // true
    ```

    

### 문자열 비교

- 자바스크립트는 '사전’순으로 문자열을 비교합니다. 

  - '사전편집(lexicographical)'순 이라고 불리기도 하는 이 기준을 적용하면 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단됩니다.

- 실제 단어를 사전에 실을 때 단어를 구성하는 문자 하나하나를 비교하여 등재 순서를 정하는 것과 같이 자바스크립트도 문자열을 구성하는 문자 하나하나를 비교해가며 문자열을 비교합니다.

  ```js
  alert( 'Z' > 'A' ); // true
  alert( 'Glow' > 'Glee' ); // true
  alert( 'Bee' > 'Be' ); // true
  ```

  

> **정확히는 사전순이 아니라 유니코드 순입니다.**
>
> - 자바스크립트의 문자열 비교 알고리즘은 사전이나 전화번호부에서 사용되는 정렬 알고리즘과 아주 유사하지만, 완전히 같진 않습니다.
>
> - 차이점 중 하나는 자바스크립트는 대·소문자를 따진다는 것입니다. 
>   - 대문자 `'A'`와 소문자 `'a'`를 비교했을 때 소문자 `'a'`가 더 큽니다. 
>   - 자바스크립트 내부에서 사용되는 인코딩 표인 유니코드에선 소문자가 대문자보다 더 큰 인덱스를 갖기 때문이죠. 
>   - 이와 관련한 자세한 내용은 [문자열](https://ko.javascript.info/string) 챕터에서 다루도록 하겠습니다.



### 다른 형을 가진 값 간의 비교

- **<u>비교하려는 값의 자료형이 다르면 자바스크립트는 이 값들을 숫자형으로 바꿉니다.</u>**

  ```js
  alert( '2' > 1 ); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행됩니다.
  alert( '01' == 1 ); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행됩니다.
  ```

- 불린값의 경우 `true`는 `1`, `false`는 `0`으로 변환된 후 비교가 이뤄집니다.

  ```js
  alert( true == 1 ); // true
  alert( false == 0 ); // true
  ```



> **흥미로운 상황**
>
> - 동시에 일어나지 않을 법한 두 상황이 동시에 일어나는 경우도 있습니다.
>   - 동등 비교(`==`) 시 true를 반환함
>   - 논리 평가 시 값 하나는 `true`, 다른 값 하나는 `false`를 반환함
>
> 예시:
>
> ```javascript
> let a = 0;
> alert( Boolean(a) ); // false
> 
> let b = "0";
> alert( Boolean(b) ); // true
> 
> alert(a == b); // true!
> ```
>
> - 두 값(a와 b)을 비교하면 참이 반환되는데, 값을 논리 평가한 후 비교하면 하나는 참, 하나는 거짓이 반환된다는 점에 고개를 갸우뚱할 수도 있습니다. 
> - 그런데 자바스크립트 관점에선 이런 결과가 아주 자연스럽습니다. 
>   - 동등 비교 연산자 `==`는 (예시에서 문자열 `"0"`을 숫자 `0`으로 변환시킨 것처럼) 피연산자를 숫자형으로 바꾸지만, 'Boolean’을 사용한 명시적 변환에는 다른 규칙이 사용되기 때문입니다.



### 일치 연산자

- 동등 연산자(equality operator) `==`은 `0`과 `false`를 구별하지 못합니다.

  ```js
  alert( 0 == false ); // true
  ```

- 피연산자가 빈 문자열일 때도 같은 문제가 발생하죠.

  ```js
  alert( '' == false ); // true
  ```

- 이런 문제는 **<u>동등 연산자 `==`가 형이 다른 피연산자를 비교할 때 피연산자를 숫자형으로 바꾸기 때문에 발생</u>**합니다. 

  - 빈 문자열과 `false`는 숫자형으로 변환하면 0이 되죠.
  - 그렇다면 `0`과 `false`는 어떻게 구별할 수 있을까요?

- **일치 연산자(strict equality operator) `===`를 사용하면 형 변환 없이 값을 비교할 수 있습니다.**

  - 일치 연산자는 엄격한(strict) 동등 연산자입니다.

  - 자료형의 동등 여부까지 검사하기 때문에 피연산자 `a`와 `b`의 형이 다를 경우 `a === b`는 즉시 `false`를 반환합니다.

    ```js
    alert( 0 === false ); // false, 피연산자의 형이 다르기 때문입니다.
    ```

- 일치 연산자 `===`가 동등 연산자 `==`의 엄격한 버전인 것처럼 ‘불일치’ 연산자 `!==`는 부등 연산자 `!=`의 엄격한 버전입니다.

  - 일치 연산자는 동등 연산자보다 한 글자 더 길긴 하지만 비교 결과가 명확하기 때문에 에러가 발생할 확률을 줄여줍니다.



### null이나 undefined와 비교하기

- `null`이나 `undefined`를 다른 값과 비교할 땐 예상치 않은 일들이 발생합니다. 

  - 일단 몇 가지 규칙을 먼저 살펴본 후, 어떤 예상치 않은 일들이 일어나는지 구체적인 예시를 통해 살펴보도록 하겠습니다.

- **일치 연산자 `===`를 사용하여 `null`과 `undefined`를 비교**

  두 값의 자료형이 다르기 때문에 일치 비교 시 거짓이 반환됩니다.

  ```js
  alert( null === undefined ); // false
  ```

- **동등 연산자** `==`**를 사용하여** `null`**과** `undefined`**를 비교**

  동등 연산자를 사용해 `null`과 `undefined`를 비교하면 특별한 규칙이 적용돼 `true`가 반환됩니다. 

  동등 연산자는 `null`과 `undefined`를 '각별한 커플’처럼 취급합니다. 

  두 값은 자기들끼리는 잘 어울리지만 다른 값들과는 잘 어울리지 못합니다.

  ```js
  alert( null == undefined ); // true
  ```

- **산술 연산자나 기타 비교 연산자** `<`**,** `>`**,** `<=`**,** `>=`**를 사용하여** `null`**과** `undefined`**를 비교**

  - `null`과 `undefined`는 숫자형으로 변환됩니다. `null`은 `0`, `undefined`는 `NaN`으로 변합니다.



- 이제 위에서 살펴본 세 가지 규칙들이 어떤 흥미로운 에지 케이스(edge case)를 만들어내는지 알아봅시다. 
- 이후, 어떻게 하면 에지 케이스가 만들어내는 함정에 빠지지 않을 수 있을지에 대해 알아보겠습니다.



### null vs 0

- `null`과 0를 비교해 봅시다.

  ```js
  alert( null > 0 );  // (1) false
  alert( null == 0 ); // (2) false
  alert( null >= 0 ); // (3) true
  ```

  - 위 비교 결과는 논리에 맞지 않아 보입니다. (3)에서 `null`은 `0`보다 크거나 같다고 했기 때문에, (1)이나 (2) 중 하나는 참이어야 하는데 둘 다 거짓을 반환하고 있네요.
  - 이런 결과가 나타나는 이유는 동등 연산자 `==`와 기타 비교 연산자 `<`, `>`, `<=`, `>=`의 동작 방식이 다르기 때문입니다. 
    - (1)에서 `null > 0`이 거짓을, (3)에서 `null >= 0`이 참을 반환하는 이유는 (기타 비교 연산자의 동작 원리에 따라) `null`이 숫자형으로 변환돼 `0`이 되기 때문입니다.
  - 그런데 동등 연산자 `==`는 피연산자가 `undefined`나 `null`일 때 형 변환을 하지 않습니다. `undefined`와 `null`을 비교하는 경우에만 `true`를 반환하고, 그 이외의 경우(`null`이나 `undefined`를 다른 값과 비교할 때)는 무조건 `false`를 반환합니다. 이런 이유 때문에 (2)는 거짓을 반환합니다.



### 비교가 불가능한 undefined

- `undefined`를 다른 값과 비교해서는 안 됩니다.

  ```js
  alert( undefined > 0 ); // false (1)
  alert( undefined < 0 ); // false (2)
  alert( undefined == 0 ); // false (3)
  ```

  - 위 예시를 보면 `undefined`는 0을 매우 싫어하는 것처럼 보입니다. 항상 `false`를 반환하고 있네요.

    이런 결과는 아래와 같은 이유 때문에 발생합니다.

    - `(1)`과`(2)`에선 `undefined`가 `NaN`으로 변환되는데(숫자형으로의 변환), `NaN`이 피연산자인 경우 비교 연산자는 항상 `false`를 반환합니다.
    - `undefined`는 `null`이나 `undefined`와 같고, 그 이외의 값과는 같지 않기 때문에 `(3)`은 `false`를 반환합니다.



### 함정 피하기

- 위와 같은 에지 케이스를 왜 살펴보았을까요? 이런 예외적인 경우를 꼭 기억해 놓고 있어야만 할까요? 
  - 그렇지는 않습니다. 
  - 개발을 하다 보면 자연스레 이런 경우를 만나고 점차 익숙해지기 때문에 지금 당장 암기해야 할 필요는 없습니다. 
- 하지만 아래와 같은 방법을 사용해 이런 예외 상황을 미리 예방할 수 있다는 점은 알아두시길 바랍니다.
  - **<u>일치 연산자 `===`를 제외한 비교 연산자의 피연산자에 `undefined`나 `null`이 오지 않도록 특별히 주의하시기 바랍니다.</u>**
  - 또한, **<u>`undefined`나 `null`이 될 가능성이 있는 변수가 `<`, `>`, `<=`, `>=`의 피연산자가 되지 않도록 주의하시기 바랍니다.</u>** 
    - 명확한 의도를 갖고 있지 않은 이상 말이죠. 
    - 만약 변수가 `undefined`나 `null`이 될 가능성이 있다고 판단되면, 이를 따로 처리하는 코드를 추가하시기 바랍니다



<u>**꼭 기억할 것: `undefined`와 `null`이 비교 연산자의 피연산자가 되지 않게 하라**</u>



## 2.10 if와 '?'를 사용한 조건 처리

> https://ko.javascript.info/ifelse



**도입**

- 조건에 따라 다른 행동을 취해야 할 때가 있습니다.

  - 이럴 땐, `if`문과 ‘물음표’ 연산자라고도 불리는 조건부 연산자 `?`를 사용하면 됩니다.

  

### 'if' 문

- `if(...)`문은 괄호 안에 들어가는 조건을 평가하는데, 그 결과가 `true`이면 코드 블록이 실행됩니다.

- 조건이 `true`일 때 복수의 문을 실행하고 싶다면 중괄호로 코드 블록을 감싸야 합니다.

  ```js
  if (year == 2015) {
    alert( "정답입니다!" );
    alert( "아주 똑똑하시네요!" );
  }
  ```

  

### 불린형으로의 변환

- `if (…)` 문은 괄호 안의 표현식을 평가하고 그 결과를 불린값으로 변환합니다.
- [형 변환](https://ko.javascript.info/type-conversions) 챕터에서 배운 형 변환 규칙을 잠시 상기해 봅시다.
  - 숫자 `0`, 빈 문자열`""`, `null`, `undefined`, `NaN`은 불린형으로 변환 시 모두 `false`가 됩니다. 이런 값들은 ‘falsy(거짓 같은)’ 값이라고 부릅니다.
  - 이 외의 값은 불린형으로 변환시 `true`가 되므로 ‘truthy(참 같은)’ 값이라고 부릅니다.



### 'else' 절

- `if`문엔 `else` 절을 붙일 수 있습니다. `else` 뒤에 이어지는 코드 블록은 조건이 거짓일 때 실행됩니다.



### 'else if'로 복수 조건 처리하기

- 유사하지만 약간씩 차이가 있는 조건 여러 개를 처리해야 할 때가 있습니다. 이때 `else if`를 사용할 수 있습니다.



### 조건부 연산자 '?'

- 조건에 따라 다른 값을 변수에 할당해줘야 할 때가 있습니다.

  ```js
  let accessAllowed;
  let age = prompt('나이를 입력해 주세요.', '');
  
  if (age > 18) {
    accessAllowed = true;
  } else {
    accessAllowed = false;
  }
  
  alert(accessAllowed);
  ```

  - '물음표(question mark) 연산자’라고도 불리는 '조건부(conditional) 연산자’를 사용하면 위 예시를 더 짧고 간결하게 변형할 수 있습니다.

  - 조건부 연산자는 물음표`?`로 표시합니다. 

    - 피연산자가 세 개이기 때문에 조건부 연산자를 '삼항(ternary) 연산자’라고 부르는 사람도 있습니다. 

    - 참고로, 자바스크립트에서 피연산자가 3개나 받는 연산자는 조건부 연산자가 유일합니다.

      ```js
      // 연산자 우선순위 규칙에 따라, 비교 연산 'age > 18'이 먼저 실행됩니다.
      // (조건문을 괄호로 감쌀 필요가 없습니다.)
      let accessAllowed = age > 18 ? true : false;
      ```

      

### 다중 '?'

- 물음표 연산자`?`를 여러 개 연결하면 복수의 조건을 처리할 수 있습니다.

  ```js
  let age = prompt('나이를 입력해주세요.', 18);
  
  let message = (age < 3) ? '아기야 안녕?' :
    (age < 18) ? '안녕!' :
    (age < 100) ? '환영합니다!' :
    '나이가 아주 많으시거나, 나이가 아닌 값을 입력 하셨군요!';
  
  alert( message );
  ```



## 2.11 논리 연산자

> https://ko.javascript.info/logical-operators



**도입**

- 자바스크립트엔 세 종류의 논리 연산자 `||`(OR), `&&`(AND), `!`(NOT)이 있습니다.
- 연산자에 '논리’라는 수식어가 붙긴 하지만 논리 연산자는 피연산자로 불린형뿐만 아니라 모든 타입의 값을 받을 수 있습니다. 
  - 연산 결과 역시 모든 타입이 될 수 있습니다.



### || (OR)

- ‘OR’ 연산자는 두 개의 수직선 기호로 만들 수 있습니다.

  ```javascript
  result = a || b;
  ```

- 전통적인 프로그래밍에서 OR 연산자는 불린값을 조작하는 데 쓰입니다. 인수 중 하나라도 `true`이면 `true`를 반환하고, 그렇지 않으면 `false`를 반환하죠.

- OR 연산자는 이항 연산자이므로 아래와 같이 네 가지 조합이 가능합니다.

  ```js
  alert( true || true );   // true
  alert( false || true );  // true
  alert( true || false );  // true
  alert( false || false ); // false
  ```

- 피연산자가 모두 `false`인 경우를 제외하고 연산 결과는 항상 `true`입니다.

  피연산자가 불린형이 아니면, 평가를 위해 불린형으로 변환됩니다.

  예를 들어, 연산 과정에서 숫자 `1`은 `true`로, 숫자 `0`은 `false`로 바뀌죠.

  ```js
  if (1 || 0) { // if( true || false ) 와 동일하게 동작합니다.
    alert( 'truthy!' );
  }
  ```

  

### 첫 번째 truthy를 찾는 OR 연산자 '||'

- 지금까진 피연산자가 불린형인 경우만을 다뤘습니다. 전통적인 방식이죠. 

- 이제 자바스크립트에서만 제공하는 논리연산자 OR의 '추가’기능에 대해 알아보겠습니다.

  - 추가 기능은 아래와 같은 알고리즘으로 동작합니다.

  - OR 연산자와 피연산자가 여러 개인 경우:

    ```js
    result = value1 || value2 || value3;
    ```

  - 이때, OR `||`연산자는 다음 순서에 따라 연산을 수행합니다.

    - 가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가합니다.
    - 각 피연산자를 불린형으로 변환합니다. 변환 후 그 값이 `true`이면 연산을 멈추고 해당 피연산자의 **변환 전** 원래 값을 반환합니다.
    - 피연산자 모두를 평가한 경우(모든 피연산자가 `false`로 평가되는 경우)엔 마지막 피연산자를 반환합니다.

  - 여기서 **<u>핵심은 반환 값이 형 변환을 하지 않은 원래 값이라는 것</u>**입니다.

- 정리해 보자면 이렇습니다. 

  - OR `"||"` 연산자를 여러 개 체이닝(chaining) 하면 첫 번째 truthy를 반환합니다. 

  - 피연산자에 truthy가 하나도 없다면 마지막 피연산자를 반환합니다.

    ```js
    alert( 1 || 0 ); // 1 (1은 truthy임)
    
    alert( null || 1 ); // 1 (1은 truthy임)
    alert( null || 0 || 1 ); // 1 (1은 truthy임)
    
    alert( undefined || null || 0 ); // 0 (모두 falsy이므로, 마지막 값을 반환함)
    ```

- 이런 OR 연산자의 추가 기능을 이용하면 여러 용도로 OR 연산자를 활용할 수 있습니다.

  1. **변수 또는 표현식으로 구성된 목록에서 첫 번째 truthy 얻기**

  - `firstName`, `lastName`, `nickName`이란 변수가 있는데 이 값들은 모두 옵션 값이라고 해봅시다.

  - OR `||`을 사용하면 실제 값이 들어있는 변수를 찾고, 그 값을 보여줄 수 있습니다. 변수 모두에 값이 없는 경우엔 `익명`를 보여줍시다.

    ```js
    let firstName = "";
    let lastName = "";
    let nickName = "바이올렛";
    
    alert( firstName || lastName || nickName || "익명"); // 바이올렛
    ```

    - 모든 변수가 falsy이면 `"익명"`이 출력되었을 겁니다.

      

  2. **단락 평가**

  - OR 연산자 `||`가 제공하는 또 다른 기능은 '**단락 평가(short circuit evaluation)**'입니다.

  - 위에서 설명해 드린 바와 같이 OR`||`은 왼쪽부터 시작해서 오른쪽으로 평가를 진행하는데, truthy를 만나면 <u>나머지 값들은 건드리지 않은 채 평가를 멈춥니다.</u> 

    - 이런 프로세스를 '단락 평가’라고 합니다.

  - 단락 평가의 동작 방식은 두 번째 피연산자가 변수 할당과 같은 부수적인 효과(side effect)를 가지는 표현식 일 때 명확히 볼 수 있습니다.

    ```js
    true || alert("not printed");
    false || alert("printed");
    ```

    - 첫 번째 줄의 `||` 연산자는 `true`를 만나자마자 평가를 멈추기 때문에 `alert`가 실행되지 않습니다.
    - 단락 평가는 연산자 왼쪽 조건이 falsy일 때만 명령어를 실행하고자 할 때 자주 쓰입니다.



### && (AND)

- 두 개의 앰퍼샌드를 연달아 쓰면 AND 연산자 `&&`를 만들 수 있습니다.

- 전통적인 프로그래밍에서 AND 연산자는 두 피연산자가 모두가 참일 때 `true`를 반환합니다. 그 외의 경우는 `false`를 반환하죠.

  ```js
  alert( true && true );   // true
  alert( false && true );  // false
  alert( true && false );  // false
  alert( false && false ); // false
  ```

- OR 연산자와 마찬가지로 AND 연산자의 피연산자도 타입에 제약이 없습니다.

  ```js
  if (1 && 0) { // 피연산자가 숫자형이지만 논리형으로 바뀌어 true && false가 됩니다.
    alert( "if 문 안에 falsy가 들어가 있으므로 alert창은 실행되지 않습니다." );
  }
  ```

  



### 첫 번째 falsy를 찾는 AND 연산자 '&&'

- AND 연산자와 피연산자가 여러 개인 경우를 살펴봅시다.

  ```js
  result = value1 && value2 && value3;
  ```

- AND 연산자 `&&`는 아래와 같은 순서로 동작합니다.

  - 가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가합니다.
  - 각 피연산자는 불린형으로 변환됩니다. 변환 후 값이 `false`이면 평가를 멈추고 해당 피연산자의 **변환 전** 원래 값을 반환합니다.
  - 피연산자 모두가 평가되는 경우(모든 피연산자가 `true`로 평가되는 경우)엔 마지막 피연산자가 반환됩니다.

- 정리해 보자면 이렇습니다. 

  - AND 연산자는 첫 번째 falsy를 반환합니다. 
  - 피연산자에 falsy가 없다면 마지막 값을 반환합니다.

- 위 알고리즘은 OR 연산자의 알고리즘과 유사합니다. 

  - 차이점은 AND 연산자가 첫 번째 *falsy*를 반환하는 반면, 
  - OR은 첫 번째 *truthy*를 반환한다는 것입니다.

  ```js
  // 첫 번째 피연산자가 truthy이면,
  // AND는 두 번째 피연산자를 반환합니다.
  alert( 1 && 0 ); // 0
  alert( 1 && 5 ); // 5
  
  // 첫 번째 피연산자가 falsy이면,
  // AND는 첫 번째 피연산자를 반환하고, 두 번째 피연산자는 무시합니다.
  alert( null && 5 ); // null
  alert( 0 && "아무거나 와도 상관없습니다." ); // 0
  ```

- AND 연산자에도 피연산자 여러 개를 연속해서 전달할 수 있습니다. 

  - 첫 번째 falsy가 어떻게 반환되는지 예시를 통해 살펴봅시다.

    ```js
    alert( 1 && 2 && null && 3 ); // null
    ```

  - 아래 예시에선 AND 연산자의 피연산자가 모두 truthy이기 때문에 마지막 피연산자가 반환됩니다.

    ```js
    alert( 1 && 2 && 3 ); // 마지막 값, 3
    ```

    

### ! (NOT)

- 논리 연산자 NOT은 느낌표 `!`를 써서 만들 수 있습니다.

- NOT 연산자의 문법은 매우 간단합니다.

  ```js
  result = !value;
  ```

- NOT 연산자는 인수를 하나만 받고, 다음 순서대로 연산을 수행합니다.

  1. 피연산자를 불린형(`true / false`)으로 변환합니다.
  2. 1에서 변환된 값의 역을 반환합니다.

  ```js
  alert( !true ); // false
  alert( !0 ); // true
  ```

- NOT을 두 개 연달아 사용(`!!`)하면 값을 불린형으로 변환할 수 있습니다.

  ```js
  alert( !!"non-empty string" ); // true
  alert( !!null ); // false
  ```

  - 이때, 첫 번째 NOT 연산자는 피연산자로 받은 값을 불린형으로 변환한 후 이 값의 역을 반환하고, 
  - 두 번째 NOT 연산자는 첫 번째 NOT 연산자가 반환한 값의 역을 반환합니다. 
  - 이렇게 NOT을 연달아 사용하면 특정 값을 불린형으로 변환할 수 있습니다.

- 참고로, 내장 함수 `Boolean`을 사용하면 `!!`을 사용한 것과 같은 결과를 도출할 수 있습니다.

  ```js
  alert( Boolean("non-empty string") ); // true
  alert( Boolean(null) ); // false
  ```

- `NOT` 연산자의 우선순위는 모든 논리 연산자 중에서 가장 높기 때문에 항상 `&&`나 `||` 보다 먼저 실행됩니다.





## 2.12 null 병합 연산자 '??'

> https://ko.javascript.info/nullish-coalescing-operator

> **[주의] 최근에 추가됨**
>
> 스펙에 추가된 지 얼마 안 된 문법입니다. 구식 브라우저는 폴리필이 필요합니다.



**도입**

- null 병합 연산자(nullish coalescing operator) `??`를 사용하면 짧은 문법으로 여러 피연산자 중 그 값이 ‘확정되어있는’ 변수를 찾을 수 있습니다.

  - `a ?? b`의 평가 결과는 다음과 같습니다.
    - `a`가 `null`도 아니고 `undefined`도 아니면 `a`
    - 그 외의 경우는 `b`

  - null 병합 연산자 `??`없이 `x = a ?? b`와 동일한 동작을 하는 코드를 작성하면 다음과 같습니다.

    ```js
    x = (a !== null && a !== undefined) ? a : b;
    ```

    - 비교 연산자와 논리 연산자만으로 null 병합 연산자와 같은 기능을 하는 코드를 작성하니 코드 길이가 길어지네요.

- 또 다른 예시를 살펴봅시다. 

- `firstName`, `lastName`, `nickName`이란 변수에 사용자 이름이나 별명을 저장하는데, 사용자가 아무런 정보도 입력하지 않는 케이스도 허용한다고 해보겠습니다.

  - 화면엔 세 변수 중 실제 값이 있는 변수의 값을 출력하는데, 세 변수 모두 값이 없다면 '익명의 사용자’가 출력되도록 해보죠.

  - 이럴 때 null 병합 연산자 `??`를 사용하면 값이 정해진 변수를 간편하게 찾아낼 수 있습니다.

    ```js
    let firstName = null;
    let lastName = null;
    let nickName = "바이올렛";
    
    // null이나 undefined가 아닌 첫 번째 피연산자
    alert(firstName ?? lastName ?? nickName ?? "익명의 사용자"); // 바이올렛
    ```



### '??'와 '||'의 차이

- null 병합 연산자는 OR 연산자 `||`와 상당히 유사해 보입니다. 

- 실제로 위 예시에서 `??`를 `||`로 바꿔도 그 결과는 동일하기까지 하죠. 관련 내용은 [이전 챕터](https://ko.javascript.info/logical-operators#or-finds-the-first-truthy-value)에서 살펴본 바 있습니다.

- 그런데 두 연산자 사이에는 중요한 차이점이 있습니다.

  - `||`는 첫 번째 *truthy* 값을 반환합니다.
  - `??`는 첫 번째 *정의된(defined)* 값을 반환합니다.
  - `null`과 `undefined`, 숫자 `0`을 구분 지어 다뤄야 할 때 이 차이점은 매우 중요한 역할을 합니다.

- 예시

  ```js
  height = height ?? 100;
  ```

  - `height`에 값이 정의되지 않은경우 `height`엔 `100`이 할당됩니다.

    

  이제 `??`와 `||`을 비교해봅시다.

  ```js
  let height = 0;
  
  alert(height || 100); // 100
  alert(height ?? 100); // 0
  ```

  - `height || 100`은 `height`에 `0`을 할당했지만 `0`을 falsy 한 값으로 취급했기 때문에 `null`이나 `undefined`를 할당한 것과 동일하게 처리합니다. 
  - 따라서 `height || 100`의 평가 결과는 `100`입니다.
  - 반면 `height ?? 100`의 평가 결과는 `height`가 정확하게 `null`이나 `undefined`일 경우에만 `100`이 됩니다. 예시에선 `height`에 `0`이라는 값을 할당했기 때문에 얼럿창엔 `0`이 출력됩니다.
  - 이런 특징 때문에 **<u>높이처럼 `0`이 할당될 수 있는 변수를 사용해 기능을 개발할 땐 `||`보다 `??`가 적합합니다.</u>**



### 연산자 우선순위

- [`??`의 연산자 우선순위](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table)는 `5`로 꽤 낮습니다.

- 따라서 `??`는 `=`와 `?` 보다는 먼저, 대부분의 연산자보다는 나중에 평가됩니다.

- 그렇기 때문에 복잡한 표현식 안에서 `??`를 사용해 값을 하나 선택할 땐 괄호를 추가하는 게 좋습니다.

  ```js
  let height = null;
  let width = null;
  
  // 괄호를 추가!
  let area = (height ?? 100) * (width ?? 50);
  
  alert(area); // 5000
  ```

  - 그렇지 않으면 `*`가 `??`보다 우선순위가 높기 때문에 `*`가 먼저 실행됩니다.

  

- `??`엔 자바스크립트 언어에서 규정한 또 다른 제약사항이 있습니다.

  - **안정성 관련 이슈 때문에 `??`는 `&&`나 `||`와 함께 사용하지 못합니다.**

    ```js
    let x = 1 && 2 ?? 3; // SyntaxError: Unexpected token '??'
    ```

  - 이 제약에 대해선 아직 논쟁이 많긴 하지만 사람들이 `||`를 `??`로 바꾸기 시작하면서 만드는 실수를 방지하고자 명세서에 제약이 추가된 상황입니다.

    - 제약을 피하려면 괄호를 사용해주세요.

      ```js
      let x = (1 && 2) ?? 3; // 제대로 동작합니다.
      
      alert(x); // 2
      ```

      



### 요약

- null 병합 연산자 `??`를 사용하면 피연산자 중 ‘값이 할당된’ 변수를 빠르게 찾을 수 있습니다.

  `??`는 변수에 기본값을 할당하는 용도로 사용할 수 있습니다.

  ```javascript
  // height가 null이나 undefined인 경우, 100을 할당
  height = height ?? 100;
  ```

- `??`의 연산자 우선순위는 대다수의 연산자보다 낮고 `?`와 `=` 보다는 높습니다.

- 괄호 없이 `??`를 `||`나 `&&`와 함께 사용하는 것은 금지되어있습니다.





## 2.13 while과 for 반복문

> https://ko.javascript.info/while-for



### 'while' 반복문

- 문법

  ```js
  while (condition) {
    // 코드
    // '반복문 본문(body)'이라 불림
  }
  ```

  - `condition`(조건)이 truthy 이면 반복문 본문의 `코드`가 실행됩니다.

- 반복문 조건엔 비교뿐만 아니라 모든 종류의 표현식, 변수가 올 수 있습니다. 

  - 조건은 `while`에 의해 평가되고, 평가 후엔 불린값으로 변경됩니다.

  - 아래 예시에선 `while (i != 0)`을 짧게 줄여 `while (i)`로 만들어보았습니다.

    ```js
    let i = 3;
    while (i) { // i가 0이 되면 조건이 falsy가 되므로 반복문이 멈춥니다.
      alert( i );
      i--;
    }
    ```



### 'do...while' 반복문

- `do..while` 문법을 사용하면 `condition`을 반복문 본문 *아래*로 옮길 수 있습니다.

  ```js
  do {
    // 반복문 본문
  } while (condition);
  ```

  - 이때 본문이 먼저 실행되고, 조건을 확인한 후 조건이 truthy인 동안엔 본문이 계속 실행됩니다.

  ```js
  let i = 0;
  do {
    alert( i );
    i++;
  } while (i < 3);
  ```



### 'for' 반복문

- `for` 반복문은 `while` 반복문보다는 복잡하지만 가장 많이 쓰이는 반복문입니다.

- 문법

  ```js
  for (begin; condition; step) {
    // ... 반복문 본문 ...
  }
  ```

- 예시

  ```js
  for (let i = 0; i < 3; i++) { // 0, 1, 2가 출력됩니다.
    alert(i);
  }
  ```

- `for`문의 구성 요소

  | 구성 요소 |            |                                                              |
  | :-------- | :--------- | :----------------------------------------------------------- |
  | begin     | `i = 0`    | 반복문에 진입할 때 단 한 번 실행됩니다.                      |
  | condition | `i < 3`    | 반복마다 해당 조건이 확인됩니다. false이면 반복문을 멈춥니다. |
  | body      | `alert(i)` | condition이 truthy일 동안 계속해서 실행됩니다.               |
  | step      | `i++`      | 각 반복의 body가 실행된 이후에 실행됩니다.                   |



> **인라인 변수 선언**
> 지금까진 ‘카운터’ 변수 `i`를 반복문 안에서 선언하였습니다. 이런 방식을 ‘인라인’ 변수 선언이라고 부릅니다. 이렇게 선언한 변수는 반복문 안에서만 접근할 수 있습니다.
>
> ```javascript
> for (let i = 0; i < 3; i++) {
>   alert(i); // 0, 1, 2
> }
> alert(i); // Error: i is not defined
> ```
>
> 인라인 변수 선언 대신, 정의되어있는 변수를 사용할 수도 있습니다.
>
> ```javascript
> let i = 0;
> 
> for (i = 0; i < 3; i++) { // 기존에 정의된 변수 사용
>   alert(i); // 0, 1, 2
> }
> 
> alert(i); // 3, 반복문 밖에서 선언한 변수이므로 사용할 수 있음
> ```



### 구성 요소 생략하기

- `for`문의 구성 요소를 생략하는 것도 가능합니다.
- 반복문이 시작될 때 아무것도 할 필요가 없으면 `begin`을 생략하는 것이 가능하죠.



### 반복문 빠져나오기

- 대개는 반복문의 조건이 falsy가 되면 반복문이 종료됩니다.
- 그런데 특별한 지시자인 `break`를 사용하면 언제든 원하는 때에 반복문을 빠져나올 수 있습니다.



### 다음 반복으로 넘어가기

- `continue` 지시자는 `break`의 '가벼운 버전’입니다. 
- `continue`는 전체 반복문을 멈추지 않습니다. 
  - 대신에 현재 실행 중인 이터레이션을 멈추고 반복문이 다음 이터레이션을 강제로 실행시키도록 합니다(조건을 통과할 때).
  - `continue`는 현재 반복을 종료시키고 다음 반복으로 넘어가고 싶을 때 사용할 수 있습니다.





## 2.14 switch문

- 복수의 `if` 조건문은 `switch`문으로 바꿀 수 있습니다.
- `switch`문을 사용한 비교법은 특정 변수를 다양한 상황에서 **<u>비교</u>**할 수 있게 해줍니다. 코드 자체가 비교 상황을 잘 설명한다는 장점도 있습니다.



### 문법

- `switch`문은 하나 이상의 `case`문으로 구성됩니다. 대개 `default`문도 있지만, 이는 필수는 아닙니다.

  ```js
  switch(x) {
    case 'value1':  // if (x === 'value1')
      ...
      [break]
  
    case 'value2':  // if (x === 'value2')
      ...
      [break]
  
    default:
      ...
      [break]
  }
  ```

  - 변수 `x`의 값과 첫 번째 `case`문의 값 `'value1'`를 일치 비교한 후, 두 번째 `case`문의 값 `'value2'`와 비교합니다. 이런 과정은 계속 이어집니다.
  - `case`문에서 변수 `x`의 값과 일치하는 값을 찾으면 해당 `case` 문의 아래의 코드가 실행됩니다. 이때, `break`문을 만나거나 `switch` 문이 끝나면 코드의 실행은 멈춥니다.
  - 값과 일치하는 `case`문이 없다면, `default`문 아래의 코드가 실행됩니다(`default` 문이 있는 경우).



### 예시

- 실제 실행 가능한 `switch`문 예시를 살펴봅시다.

  ```js
  let a = 2 + 2;
  
  switch (a) {
    case 3:
      alert( '비교하려는 값보다 작습니다.' );
      break;
    case 4:
      alert( '비교하려는 값과 일치합니다.' );
      break;
    case 5:
      alert( '비교하려는 값보다 큽니다.' );
      break;
    default:
      alert( "어떤 값인지 파악이 되지 않습니다." );
  }
  ```

  - `switch`문은 a의 값인 4와 첫 번째 `case`문의 값인 3을 비교합니다. 두 값은 같지 않기 때문에 다음 `case`문으로 넘어갑니다.
  - a와 그다음 `case`문의 값인 4는 일치합니다. 따라서 `break`문을 만날 때까지 `case 4` 아래의 코드가 실행됩니다.

- **`case`문 안에 `break`문이 없으면 조건에 부합하는지 여부를 따지지 않고 이어지는 `case`문을 실행합니다.**

  ```js
  let a = 2 + 2;
  
  switch (a) {
    case 3:
      alert( '비교하려는 값보다 작습니다.' );
    case 4:
      alert( '비교하려는 값과 일치합니다.' );
    case 5:
      alert( '비교하려는 값보다 큽니다.' );
    default:
      alert( "어떤 값인지 파악이 되지 않습니다." );
  }
  
  [결과]
  위 예시를 실행하면 아래 3개의 alert문이 실행됩니다.
  
  alert( '비교하려는 값과 일치합니다.' );
  alert( '비교하려는 값보다 큽니다.' );
  alert( "어떤 값인지 파악이 되지 않습니다." );
  ```

  

> **[정보]** `switch/case`**문의 인수엔 어떤 표현식이든 올 수 있습니다.**
>
> - `switch`문과 `case`문은 모든 형태의 표현식을 인수로 받습니다.
>
> ```js
> let a = "1";
> let b = 0;
> 
> switch (+a) {
>   case b + 1:
>     alert("표현식 +a는 1, 표현식 b+1는 1이므로 이 코드가 실행됩니다.");
>     break;
> 
>   default:
>     alert("이 코드는 실행되지 않습니다.");
> }
> ```
>
> - 표현식 +a를 평가하면 1이 됩니다. 
> - 이 값은 첫 번째 `case`문의 표현식 `b + 1`을 평가한 값(1)과 일치하죠. 
>   - 따라서 첫 번째 `case`문 아래의 코드가 실행됩니다.



### 여러 개의 "case"문 묶기

- 코드가 같은 `case`문은 한데 묶을 수 있습니다.

- `case 3`과 `case 5`에서 실행하려는 코드가 같은 경우에 대한 예시를 살펴봅시다.

  ```js
  let a = 3;
  
  switch (a) {
    case 4:
      alert('계산이 맞습니다!');
      break;
  
    case 3: // (*) 두 case문을 묶음
    case 5:
      alert('계산이 틀립니다!');
      alert("수학 수업을 다시 들어보는걸 권유 드립니다.");
      break;
  
    default:
      alert('계산 결과가 이상하네요.');
  }
  ```

  - `case 3`과 `case 5`는 동일한 메시지를 보여줍니다.



### 자료형의 중요성

- switch문은 **<u>일치 비교</u>**로 조건을 확인합니다. 

- 비교하려는 값과 `case`문의 값의 **<u>형과 값이 같아야</u>** 해당 `case`문이 실행됩니다.

  ```js
  let arg = prompt("값을 입력해주세요.");
  switch (arg) {
    case '0':
    case '1':
      alert( '0이나 1을 입력하셨습니다.' );
      break;
  
    case '2':
      alert( '2를 입력하셨습니다.' );
      break;
  
    case 3:
      alert( '이 코드는 절대 실행되지 않습니다!' );
      break;
    default:
      alert( '알 수 없는 값을 입력하셨습니다.' );
  }
  ```

  - `3`을 입력하였더라도 세 번째 `alert`문은 실행되지 않습니다. 
  - 앞서 배운 바와 같이 `prompt` 함수는 사용자가 입력 필드에 기재한 값을 **<u>문자열</u>**로 변환해 반환하기 때문에 숫자 `3`을 입력하더라도 `prompt` 함수는 문자열 `'3'`을 반환합니다. 
  - 그런데 세 번째 `case`문에선 사용자가 입력한 값과 숫자형 3을 비교하므로, 형 자체가 다르기 때문에 `case 3` 아래의 코드는 절대 실행되지 않습니다. 대신 `default`문이 실행됩니다.



## 2.15 함수

>https://ko.javascript.info/function-basics

**도입**

- 함수는 프로그램을 구성하는 주요 '구성 요소(building block)'입니다. 
- 함수를 이용하면 중복 없이 유사한 동작을 하는 코드를 여러 번 호출할 수 있습니다.
- 이번 챕터에선 함수를 직접 만드는 방법에 대해 알아보겠습니다.



### 함수 선언

- ***함수 선언(function declaration)* 방식**을 이용하면 함수를 만들 수 있습니다 (함수 선언 방식은 **함수 선언문**이라고 부르기도 합니다 – 옮긴이).

- 함수 선언 방식은 아래와 같이 작성할 수 있습니다.

  ```js
  function showMessage() {
    alert( '안녕하세요!' );
  }
  ```

- 문법

  ```js
  function 함수명(파라미터들) {
    ...함수 본문...
  }
  ```

  - `function` 키워드, *함수 이름*, 괄호로 둘러싼 매개변수를 차례로 써주면 함수를 선언할 수 있습니다. 
  - 위 예시의 함수에는 매개변수가 없는데, 만약 매개변수가 여러 개 있다면 각 매개변수를 콤마로 구분해줍니다.
  - 이어서 함수를 구성하는 코드의 모임인 '함수 본문(body)'을 중괄호로 감싸 붙여줍시다.

- 함수 호출

  - 새롭게 정의한 함수는 함수 이름 옆에 괄호를 붙여 호출할 수 있습니다. `showMessage()`같이 말이죠.

    ```js
    function showMessage() {
      alert( '안녕하세요!' );
    }
    
    showMessage();
    showMessage();
    ```



### 지역 변수

- 함수 내에서 선언한 변수인 지역 변수(local variable)는 함수 안에서만 접근할 수 있습니다.

  ```js
  function showMessage() {
    let message = "안녕하세요!"; // 지역 변수
  
    alert( message );
  }
  
  showMessage(); // 안녕하세요!
  
  alert( message ); // ReferenceError: message is not defined (message는 함수 내 지역 변수이기 때문에 에러가 발생합니다.)
  ```

  

### 외부 변수

- 함수 내부에서 함수 외부의 변수인 외부 변수(outer variable)에 접근할 수 있습니다.

  ```js
  let userName = 'John';
  
  function showMessage() {
    let message = 'Hello, ' + userName;
    alert(message);
  }
  
  showMessage(); // Hello, John
  ```

- 함수에선 외부 변수에 접근하는 것뿐만 아니라, 수정도 할 수 있습니다.

  ```js
  let userName = 'John';
  
  function showMessage() {
    userName = "Bob"; // (1) 외부 변수를 수정함
  
    let message = 'Hello, ' + userName;
    alert(message);
  }
  
  alert( userName ); // 함수 호출 전이므로 John 이 출력됨
  
  showMessage();
  
  alert( userName ); // 함수에 의해 Bob 으로 값이 바뀜
  ```

- 외부 변수는 지역 변수가 없는 경우에만 사용할 수 있습니다.

  - 함수 내부에 외부 변수와 동일한 이름을 가진 변수가 선언되었다면, 내부 변수는 외부 변수를 *가립니다*. 

  - 예시를 살펴봅시다.

    ```js
    let userName = 'John';
    
    function showMessage() {
      let userName = "Bob"; // 같은 이름을 가진 지역 변수를 선언합니다.
    
      let message = 'Hello, ' + userName; // Bob
      alert(message);
    }
    
    // 함수는 내부 변수인 userName만 사용합니다,
    showMessage();
    
    alert( userName ); // 함수는 외부 변수에 접근하지 않습니다. 따라서 값이 변경되지 않고, John이 출력됩니다.
    ```

    - 함수 내부에 외부 변수와 동일한 이름을 가진 지역 변수 `userName`가 선언되어 있습니다. 외부 변수는 내부 변수에 가려져 값이 수정되지 않았습니다.



> **전역 변수**
>
> - 위 예시의 `userName`처럼, <u>함수 외부에 선언된 변수</u>는 ***전역 변수(global variable)*** 라고 부릅니다.
>
> - 전역 변수는 같은 이름을 가진 지역 변수에 의해 가려지지만 않는다면 모든 함수에서 접근할 수 있습니다.
>
> - 변수는 연관되는 함수 내에 선언하고, <u>전역 변수는 되도록 사용하지 않는 것이 좋습니다</u>.
> - 비교적 근래에 작성된 코드들은 대부분 전역변수를 사용하지 않거나 최소한으로만 사용합니다. 
> - 다만 <u>프로젝트 전반에서 사용되는 데이터는 전역 변수에 저장하는 것이 유용한 경우도 있으니</u> 이 점을 알아두시기 바랍니다.



### 매개변수

- 매개변수(parameter)를 이용하면 임의의 데이터를 함수 안에 전달할 수 있습니다. 

- 아래 예시에서 함수 showMessage는 매개변수 `from` 과 `text`를 가집니다.

  ```js
  function showMessage(from, text) { // 인수: from, text
    alert(from + ': ' + text);
  }
  
  showMessage('Ann', 'Hello!'); // Ann: Hello! (*)
  showMessage('Ann', "What's up?"); // Ann: What's up? (**)
  ```

  - `(*)`, `(**)`로 표시한 줄에서 함수를 호출하면, 함수에 전달된 인자는 지역변수 `from`과 `text`에 복사됩니다. 그 후 <u>함수는 지역변수에 복사된 값을 사용</u>합니다.

- 예시 하나를 더 살펴봅시다. 전역 변수 `from`이 있고, 이 변수를 함수에 전달하였습니다. 

  - 함수가 `from`을 변경하지만, 변경 사항은 외부 변수 `from`에 반영되지 않았습니다. 

  - <u>함수는 언제나 복사된 값을 사용하기 때문입니다.</u>

    ```js
    function showMessage(from, text) {
    
      from = '*' + from + '*'; // "from"을 좀 더 멋지게 꾸며줍니다.
    
      alert( from + ': ' + text );
    }
    
    let from = "Ann";
    
    showMessage(from, "Hello"); // *Ann*: Hello
    
    // 함수는 복사된 값을 사용하기 때문에 바깥의 "from"은 값이 변경되지 않습니다.
    alert( from ); // Ann
    ```



### 기본값

- 매개변수에 값을 전달하지 않으면 그 값은 `undefined`가 됩니다.

- 예시를 통해 이에 대해 알아봅시다. 

  위에서 정의한 함수 `showMessage(from, text)`는 매개변수가 2개지만, 아래와 같이 인수를 하나만 넣어서 호출할 수 있습니다.

  ```js
  showMessage("Ann");
  ```

  - 이렇게 코드를 작성해도 에러가 발생하지 않습니다. 두 번째 매개변수에 값을 전달하지 않았기 때문에 `text`엔 `undefiend`가 할당될 뿐입니다. 따라서 에러 없이 `"Ann: undefined"`가 출력됩니다.

- 매개변수에 값을 전달하지 않아도 그 값이 `undefined`가 되지 않게 하려면 '기본값(default value)'을 설정해주면 됩니다. 

  - 매개변수 오른쪽에 `=`을 붙이고 `undefined` 대신 설정하고자 하는 기본값을 써주면 되죠.

    ```js
    function showMessage(from, text = "no text given") {
      alert( from + ": " + text );
    }
    
    showMessage("Ann"); // Ann: no text given
    ```

    - 이젠 `text`가 값을 전달받지 못해도 `undefined`대신 기본값 `"no text given"`이 할당됩니다.

- 위 예시에선 문자열 `"no text given"`을 기본값으로 설정했습니다. 

  - 하지만 아래와 같이 복잡한 <u>표현식도 기본값으로 설정할 수도 있습니다</u>.

    ```js
    function showMessage(from, text = anotherFunction()) {
      // anotherFunction()은 text값이 없을 때만 호출됨
      // anotherFunction()의 반환 값이 text의 값이 됨
    }
    ```

    

> **매개변수 기본값 평가 시점**
>
> - 자바스크립트에선 함수를 호출할 때마다 매개변수 기본값을 평가합니다. 
>   - 물론 해당하는 매개변수가 없을 때만 기본값을 평가하죠.
> - 위 예시에선 매개변수 `text`에 값이 없는 경우 `showMessage()`를 호출할 때마다 `anotherFunction()`이 호출됩니다.



### 매개변수 기본값을 설정할 수 있는 또 다른 방법

- 가끔은 함수 선언부에서 매개변수 기본값을 설정하는 것 대신 함수가 실행되는 도중에 기본값을 설정하는 게 논리에 맞는 경우가 생기기도 합니다.

  - 이런 경우엔 일단 매개변수를 `undefined`와 비교하여 함수 호출 시 매개변수가 생략되었는지를 확인합니다.

    ```js
    function showMessage(text) {
      if (text === undefined) {
        text = '빈 문자열';
      }
    
      alert(text);
    }
    
    showMessage(); // 빈 문자열
    ```

  - 이렇게 `if`문을 쓰는 것 대신 논리 연산자 `||`를 사용할 수도 있습니다.

    ```js
    // 매개변수가 생략되었거나 빈 문자열("")이 넘어오면 변수에 '빈 문자열'이 할당됩니다.
    function showMessage(text) {
      text = text || '빈 문자열';
      ...
    }
    ```

  - 이 외에도 모던 자바스크립트 엔진이 지원하는 [null 병합 연산자(nullish coalescing operator)](https://ko.javascript.info/nullish-coalescing-operator) `??`를 사용하면 `0`처럼 falsy로 평가되는 값들을 일반 값처럼 처리할 수 있어서 좋습니다.

    ```js
    // 매개변수 'count'가 넘어오지 않으면 'unknown'을 출력해주는 함수
    function showCount(count) {
      alert(count ?? "unknown");
    }
    
    showCount(0); // 0
    showCount(null); // unknown
    showCount(); // unknown
    ```

    

### 반환 값

- 함수를 호출했을 때 함수를 호출한 그곳에 특정 값을 반환하게 할 수 있습니다. 

  - 이때 이 특정 값을 반환 값(return value)이라고 부릅니다.

- 인수로 받은 두 값을 더해주는 간단한 함수를 만들어 반환 값에 대해 알아보도록 하겠습니다.

  ```js
  function sum(a, b) {
    return a + b;
  }
  
  let result = sum(1, 2);
  alert( result ); // 3
  ```

  - 지시자 `return`은 함수 내 어디서든 사용할 수 있습니다. 
  - 실행 흐름이 지시자 `return`을 만나면 함수 실행은 즉시 중단되고 함수를 호출한 곳에 값을 반환합니다. 
  - 위 예시에선 반환 값을 `result`에 할당하였습니다.



> **`return`문이 없거나 `return` 지시자만 있는 함수는 `undefined`를 반환합니다.**
>
> - `return`문이 없는 함수도 무언가를 반환합니다. `undefined`를 반환하죠.
>
> ```javascript
> function doNothing() { /* empty */ }
> 
> alert( doNothing() === undefined ); // true
> ```
>
> - `return` 지시자만 있는 경우도 `undefined`를 반환합니다. `return`은 `return undefined`와 동일하게 동작하죠.
>
> ```javascript
> function doNothing() {
>   return;
> }
> 
> alert( doNothing() === undefined ); // true
> ```



> **`return`과 값 사이에 절대 줄을 삽입하지 마세요.**
>
> - 반환하려는 값이 긴 표현식인 경우, 아래와 같이 지시자 `return`과 반환하려는 값 사이에 새 줄을 넣어 코드를 작성하고 싶을 수도 있습니다.
>
> ```javascript
> return
>  (some + long + expression + or + whatever * f(a) + f(b))
> ```
>
> - 자바스크립트는 <u>return문 끝에 세미콜론을 자동으로 넣기 때문에</u> 이렇게 `return`문을 작성하면 안 됩니다. 위 코드는 아래 코드처럼 동작합니다.
>
> ```javascript
> return;
>  (some + long + expression + or + whatever * f(a) + f(b))
> ```
>
> - 따라서 반환하고자 했던 표현식을 반환하지 못하고 아무것도 반환하지 않는 것처럼 되어버립니다.
>
> - 표현식을 여러 줄에 걸쳐 작성하고 싶다면 표현식이 `return` 지시자가 있는 줄에서 시작하도록 작성해야 합니다. 
>   - 또는 아래와 같이 여는 괄호를 `return` 지시자와 같은 줄에 써줘도 괜찮습니다.
>
> ```javascript
> return (
>   some + long + expression
>   + or +
>   whatever * f(a) + f(b)
>   )
> ```
>
> - 이렇게 하면 의도한 대로 표현식을 반환할 수 있습니다.



### 요약

- 함수 선언 방식으로 함수를 만들 수 있습니다.

```javascript
function 함수이름(복수의, 매개변수는, 콤마로, 구분합니다) {
  /* 함수 본문 */
}
```

- 함수에 전달된 매개변수는 복사된 후 함수의 지역변수가 됩니다.
- 함수는 외부 변수에 접근할 수 있습니다. 하지만 함수 바깥에서 함수 내부의 지역변수에 접근하는 건 불가능합니다.
- 함수는 값을 반환할 수 있습니다. 값을 반환하지 않는 경우는 반환 값이 `undefined`가 됩니다.

깔끔하고 이해하기 쉬운 코드를 작성하려면 함수 내부에서 외부 변수를 사용하는 방법 대신 지역 변수와 매개변수를 활용하는 게 좋습니다.

개발자는 매개변수를 받아서 그 변수를 가지고 반환 값을 만들어 내는 함수를 더 쉽게 이해할 수 있습니다. 매개변수 없이 함수 내부에서 외부 변수를 수정해 반환 값을 만들어 내는 함수는 쉽게 이해하기 힘듭니다.

함수 이름을 지을 땐 아래와 같은 규칙을 따르는 것이 좋습니다.

- 함수 이름은 함수가 어떤 동작을 하는지 설명할 수 있어야 합니다. 이렇게 이름을 지으면 함수 호출 코드만 보아도 해당 함수가 무엇을 하고 어떤 값을 반환할지 바로 알 수 있습니다.
- 함수는 동작을 수행하기 때문에 이름이 주로 동사입니다.
- `create…`, `show…`, `get…`, `check…` 등의 잘 알려진 접두어를 사용해 이름을 지을 수 있습니다. 접두어를 사용하면 함수 이름만 보고도 해당 함수가 어떤 동작을 하는지 파악할 수 있습니다.

함수는 스크립트를 구성하는 주요 구성 요소입니다. 지금까진 다룬 내용은 함수의 기본입니다. 여기선 함수를 만드는 방법, 사용하는 방법을 소개했는데 이 내용은 시작일 뿐입니다. 이어지는 챕터에선 지금까지 배운 것을 바탕으로 함수가 제공하는 고급 기능에 대해 학습해 보도록 하겠습니다.



## 2.16 함수 표현식

> https://ko.javascript.info/function-expressions



**도입**

- 자바스크립트는 함수를 특별한 종류의 값으로 취급합니다. 

  - 다른 언어에서처럼 "특별한 동작을 하는 구조"로 취급되지 않습니다.

- 이전 챕터에서 *함수 선언(Function Declaration), 함수 선언문* 방식으로 함수를 만들었습니다. 아래와 같이 말이죠.

  ```js
  function sayHi() {
    alert( "Hello" );
  }
  ```

- 함수 선언 방식 외에 ***함수 표현식(Function Expression)*** 을 사용해서 함수를 만들 수 있습니다.

  - 함수 표현식으로 함수를 생성해보겠습니다.

    ```js
    let sayHi = function() {
      alert( "Hello" );
    };
    ```

    - 함수를 생성하고 변수에 값을 할당하는 것처럼 함수가 변수에 할당되었습니다. 
    - 함수가 어떤 방식으로 만들어졌는지에 관계없이 함수는 값이고, 따라서 변수에 할당할 수 있습니다. 
    - 위 예시에선 함수가 변수 `sayHi`에 저장된 값이 되었습니다.
    - 위 예시를 간단한 말로 풀면 다음과 같습니다: “함수를 만들고 그 함수를 변수 `sayHi`에 할당하기”

  - 함수는 값이기 때문에 `alert`를 이용하여 함수 코드를 출력할 수도 있습니다.

    ```js
    function sayHi() {
      alert( "Hello" );
    }
    
    alert( sayHi ); // 함수 코드가 보임
    /*
    [출력 결과]
    ko.javascript.info 내용:
    function sayHi() {
      alert( "Hello" );
    }
    */
    ```

    - 마지막 줄에서 `sayHi`옆에 괄호가 없기 때문에 함수는 실행되지 않습니다. 
    - 어떤 언어에선 괄호 없이 함수 이름만 언급해도 함수가 실행됩니다. 
      - 하지만 자바스크립트는 괄호가 있어야만 함수가 호출됩니다
    - 자바스크립트에서 함수는 값입니다. 따라서 함수를 값처럼 취급할 수 있습니다. 
      - 위 코드에선 함수 소스 코드가 문자형으로 바뀌어 출력되었습니다.

- 함수는 `sayHi()`처럼 호출할 수 있다는 점 때문에 일반적인 값과는 조금 다릅니다. 특별한 종류의 값이죠.

  - 하지만 그 본질은 값이기 때문에 값에 할 수 있는 일을 함수에도 할 수 있습니다.

  - 변수를 복사해 다른 변수에 할당하는 것처럼 함수를 복사해 다른 변수에 할당할 수도 있습니다.

    ```js
    function sayHi() {   // (1) 함수 생성
      alert( "Hello" );
    }
    
    let func = sayHi;    // (2) 함수 복사
    
    func(); // Hello     // (3) 복사한 함수를 실행(정상적으로 실행됩니다)!
    sayHi(); // Hello    //     본래 함수도 정상적으로 실행됩니다.
    ```

    1. `(1)`에서 함수 선언 방식을 이용해 함수를 생성합니다. 생성한 함수는 `sayHi`라는 변수에 저장됩니다.
    2. `(2)` 에선 `sayHi`를 새로운 변수 `func`에 복사합니다. 이때 `sayHi` 다음에 괄호가 없다는 점에 유의하시기 바랍니다. 괄호가 있었다면 `func = sayHi()` 가 되어 `sayHi` *함수* 그 자체가 아니라, *함수 호출 결과(함수의 반환 값)* 가 `func`에 저장되었을 겁니다.
    3. 이젠 `sayHi()` 와 `func()`로 함수를 호출할 수 있게 되었습니다.

- 함수 `sayHi`는 아래와 같이 함수 표현식을 사용해 정의할 수 있습니다.

  ```js
  let sayHi = function() {
    alert( "Hello" );
  };
  
  let func = sayHi;
  // ...
  ```



> **끝에 세미 콜론은 왜 있나요?**
>
> - 함수 표현식의 끝에 왜 세미 콜론 `;`이 붙는지 의문이 들 수 있습니다. 함수 선언문에는 세미 콜론이 없는데 말이죠.
>
> ```javascript
> function sayHi() {
>   // ...
> }
> 
> let sayHi = function() {
>   // ...
> };
> ```
>
> - 이유는 간단합니다.
>   - `if { ... }`, `for { }`, `function f { }` 같이 중괄호로 만든 코드 블록 끝엔 `;`이 없어도 됩니다.
>   - 함수 표현식은 `let sayHi = ...;`과 같은 구문 안에서 값의 역할을 합니다. 코드 블록이 아니고 값처럼 취급되어 변수에 할당되죠. 모든 구문의 끝엔 세미 콜론 `;`을 붙이는 게 좋습니다. 함수 표현식에 쓰인 세미 콜론은 함수 표현식 때문에 붙여진 게 아니라, 구문의 끝이기 때문에 붙여졌습니다.





### 콜백 함수

- 함수를 값처럼 전달하는 예시, 함수 표현식에 관한 예시를 좀 더 살펴보겠습니다.

- 매개변수가 3개 있는 함수, `ask(question, yes, no)`를 작성해보겠습니다. 

  - 각 매개변수에 대한 설명은 아래와 같습니다.
    - `question`: 질문
    - `yes` : "Yes"라고 답한 경우 실행되는 함수
    - `no`: "No"라고 답한 경우 실행되는 함수
  - 함수는 반드시 `question(질문)`을 해야 하고, 사용자의 답변에 따라 `yes()` 나 `no()`를 호출합니다.

  ```js
  function ask(question, yes, no) {
    if (confirm(question)) yes()
    else no();
  }
  
  function showOk() {
    alert( "동의하셨습니다." );
  }
  
  function showCancel() {
    alert( "취소 버튼을 누르셨습니다." );
  }
  
  // 사용법: 함수 showOk와 showCancel가 ask 함수의 인수로 전달됨
  ask("동의하십니까?", showOk, showCancel);
  ```

  - **함수 `ask`의 인수, `showOk`와 `showCancel`은 <u>콜백 함수</u> 또는 <u>콜백</u>이라고 불립니다.**
  - 함수를 <u>함수의 인수로 전달하고, 필요하다면 인수로 전달한 그 함수를 "나중에 호출(called back)"하는 것</u>이 콜백 함수의 개념입니다.
  - 위 예시에선 사용자가 "yes"라고 대답한 경우 `showOk`가 콜백이 되고, "no"라고 대답한 경우 `showCancel`가 콜백이 됩니다.

- 아래와 같이 함수 표현식을 사용하면 코드 길이가 짧아집니다.

  ```js
  function ask(question, yes, no) {
    if (confirm(question)) yes()
    else no();
  }
  
  ask(
    "동의하십니까?",
    function() { alert("동의하셨습니다."); },
    function() { alert("취소 버튼을 누르셨습니다."); }
  );
  ```

  - `ask(...)` 안에 함수가 선언된 게 보이시나요? 
    - 이렇게 이름 없이 선언한 함수는 *익명 함수(anonymous function)* 라고 부릅니다. 
  - 익명 함수는 (변수에 할당된 게 아니기 때문에) `ask` 바깥에선 접근할 수 없습니다.
    - 위 예시는 의도를 가지고 이렇게 구현하였기 때문에 바깥에서 접근할 수 없어도 문제가 없습니다.

- 자바스크립트를 사용하다 보면 콜백을 활용한 코드를 아주 자연스레 만나게 됩니다. 이런 코드는 자바스크립트의 정신을 대변합니다.



> **함수는 "동작"을 나타내는 값입니다.**
>
> - 문자열이나 숫자 등의 일반적인 값들은 *데이터*를 나타냅니다.
> - 함수는 하나의 *동작(action)*을 나타냅니다.
> - 동작을 대변하는 값인 함수를 변수 간 전달하고, 동작이 필요할 때 이 값을 실행할 수 있습니다.



### 함수 표현식 vs 함수 선언문

- 함수 표현식과 선언문의 차이에 대해 알아봅시다.

- 첫 번째는 **<u>문법</u>**입니다. 코드를 통해 어떤 차이가 있는지 살펴봅시다.

  - ***함수 선언문**:* 함수는 주요 코드 흐름 중간에 독자적인 구문 형태로 존재합니다.

    ```javascript
    // 함수 선언문
    function sum(a, b) {
      return a + b;
    }
    ```

  - ***함수 표현식**:* 함수는 표현식이나 구문 구성(syntax construct) 내부에 생성됩니다. 아래 예시에선 함수가 할당 연산자 `=`를 이용해 만든 “할당 표현식” 우측에 생성되었습니다.

    ```javascript
    // 함수 표현식
    let sum = function(a, b) {
      return a + b;
    };
    ```

- 두 번째는 자바스크립트 엔진이 <u>**언제**</u> 함수를 생성하는지에 있습니다.

  - **<u>함수 표현식</u>은 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성합니다. 따라서 실행 흐름이 함수에 도달했을 때부터 해당 함수를 사용할 수 있습니다.**

  - 위 예시를 이용해 설명해 보도록 하겠습니다. 스크립트가 실행되고, 실행 흐름이 `let sum = function…`의 우측(함수 표현식)에 도달 했을때 함수가 생성됩니다. 

    - 이때 이후부터 해당 함수를 사용(할당, 호출 등)할 수 있습니다.

      

  - 하지만 함수 선언문은 조금 다릅니다.

  - **<u>함수 선언문</u>은 함수 선언문이 정의되기 전에도 호출할 수 있습니다.**

  - 따라서 전역 함수 선언문은 스크립트 어디에 있느냐에 상관없이 어디에서든 사용할 수 있습니다.

  - 이게 가능한 이유는 자바스크립트의 내부 알고리즘 때문입니다. 

    - 자바스크립트는 스크립트를 실행하기 전, 준비단계에서 전역에 선언된 함수 선언문을 찾고, 해당 함수를 생성합니다. 
    - 스크립트가 진짜 실행되기 전 "초기화 단계"에서 함수 선언 방식으로 정의한 함수가 생성되는 것이죠.
    - 스크립트는 함수 선언문이 모두 처리된 이후에서야 실행됩니다. 따라서 스크립트 어디서든 함수 선언문으로 선언한 함수에 접근할 수 있는 것입니다.



- 예시를 살펴봅시다.

  ```js
  sayHi("John"); // Hello, John
  
  function sayHi(name) {
    alert( `Hello, ${name}` );
  }
  ```

  - 함수 선언문, `sayHi`는 스크립트 실행 준비 단계에서 생성되기 때문에, 스크립트 내 어디에서든 접근할 수 있습니다.

  ```js
  sayHi("John"); // error!
  
  let sayHi = function(name) {  // (*) 마술은 일어나지 않습니다.
    alert( `Hello, ${name}` );
  };
  ```

  - 그러나 함수 표현식으로 정의한 함수는 함수가 선언되기 전에 접근하는 게 불가능합니다.
  - 함수 표현식은 실행 흐름이 표현식에 다다랐을 때 만들어집니다. 
    - 위 예시에선 `(*)`로 표시한 줄에 실행 흐름이 도달했을 때 함수가 만들어집니다. 아주 늦죠.



- 세 번째 차이점은, **<u>스코프</u>**입니다.

  - **엄격 모드에서 함수 선언문이 코드 블록 내에 위치하면 해당 함수는 블록 내 어디서든 접근할 수 있습니다. 하지만 블록 밖에서는 함수에 접근하지 못합니다.**

    

  - 예시를 들어 설명해 보겠습니다.

  - 런타임에 그 값을 알 수 있는 변수 `age`가 있고, 이 변수의 값에 따라 함수 `welcome()`을 다르게 정의해야 하는 상황입니다. 그리고 함수 `welcome()`은 나중에 사용해야 하는 상황이라고 가정해 보죠.

    ```js
    let age = prompt("나이를 알려주세요.", 18);
    
    // 조건에 따라 함수를 선언함
    if (age < 18) {
    
      function welcome() {
        alert("안녕!");
      }
    
    } else {
    
      function welcome() {
        alert("안녕하세요!");
      }
    
    }
    
    // 함수를 나중에 호출합니다.
    welcome(); // Error: welcome is not defined
    ```

    - 함수 선언문을 사용하면 의도한 대로 코드가 동작하지 않습니다.

    - 함수 선언문은 함수가 선언된 코드 블록 안에서만 유효하기 때문에 이런 에러가 발생합니다.

      

  - 또 다른 예시를 살펴봅시다.

    ```js
    let age = 16; // 16을 저장했다 가정합시다.
    
    if (age < 18) {
      welcome();               // \   (실행)
                               //  |
      function welcome() {     //  |
        alert("안녕!");         //  |  함수 선언문은 함수가 선언된 블록 내
      }                        //  |  어디에서든 유효합니다
                               //  |
      welcome();               // /   (실행)
    
    } else {
    
      function welcome() {
        alert("안녕하세요!");
      }
    }
    
    // 여기는 중괄호 밖이기 때문에
    // 중괄호 안에서 선언한 함수 선언문은 호출할 수 없습니다.
    
    welcome(); // Error: welcome is not defined
    ```

  - 그럼 `if`문 밖에서 `welcome` 함수를 호출할 방법은 없는 걸까요?

    - 함수 표현식을 사용하면 가능합니다. 
    - `if`문 밖에 선언한 변수 `welcome`에 함수 표현식으로 만든 함수를 할당하면 되죠.

    ```js
    let age = prompt("나이를 알려주세요.", 18);
    
    let welcome;
    
    if (age < 18) {
    
      welcome = function() {
        alert("안녕!");
      };
    
    } else {
    
      welcome = function() {
        alert("안녕하세요!");
      };
    
    }
    
    welcome(); // 제대로 동작합니다.
    ```

    - 이제 코드가 의도한 대로 동작합니다.

  - 물음표 연산자 `?`를 사용하면 위 코드를 좀 더 단순화할 수 있습니다.

    ```js
    let age = prompt("나이를 알려주세요.", 18);
    
    let welcome = (age < 18) ?
      function() { alert("안녕!"); } :
      function() { alert("안녕하세요!"); };
    
    welcome(); // 제대로 동작합니다.
    ```

    

> **함수 선언문과 함수 표현식 중 무엇을 선택해야 하나요?**
>
> - 제 경험에 따르면 <u>함수 선언문을 이용해 함수를 선언하는 걸 먼저 고려</u>하는 게 좋습니다. 
>   - 함수 선언문으로 함수를 정의하면, 함수가 선언되기 전에 호출할 수 있어서 코드 구성을 좀 더 자유롭게 할 수 있습니다.
>
> - 함수 선언문을 사용하면 가독성도 좋아집니다. 
>   - 코드에서 `let f = function(…) {…}`보다 `function f(…) {…}` 을 찾는 게 더 쉽죠. 
>   - 함수 선언 방식이 더 “눈길을 사로잡습니다”.
> - 그러나 어떤 이유로 함수 선언 방식이 적합하지 않거나, (위 예제와 같이) 조건에 따라 함수를 선언해야 한다면 함수 표현식을 사용해야 합니다.



### 요약

- 함수는 값입니다. 따라서 함수도 값처럼 할당, 복사, 선언할 수 있습니다.
- “함수 선언(문)” 방식으로 함수를 생성하면, 함수가 독립된 구문 형태로 존재하게 됩니다.
- “함수 표현식” 방식으로 함수를 생성하면, 함수가 표현식의 일부로 존재하게 됩니다.
- 함수 선언문은 코드 블록이 실행되기도 전에 처리됩니다. 따라서 블록 내 어디서든 활용 가능합니다.
- 함수 표현식은 실행 흐름이 표현식에 다다랐을 때 만들어집니다.





## 2.17 화살표 함수 기본

- 함수 표현식보다 단순하고 간결한 문법으로 함수를 만들 수 있는 방법이 있습니다.

- 바로 **<u>화살표 함수(arrow function)</u>**를 사용하는 것입니다. 

  - 화살표 함수라는 이름은 문법의 생김새를 차용해 지어졌습니다.

- 문법

  ```js
  let func = (arg1, arg2, ...argN) => expression
  ```

  - 이렇게 코드를 작성하면 인자 `arg1..argN`를 받는 함수 `func`이 만들어집니다. 

  - 함수 `func`는 화살표(`=>`) 우측의 `표현식(expression)`을 평가하고, 평가 결과를 반환합니다.

  - 아래 함수의 축약 버전이라고 할 수 있죠.

    ```js
    let func = function(arg1, arg2, ...argN) {
      return expression;
    };
    ```

- 좀 더 구체적인 예시를 살펴봅시다.

  ```js
  let sum = (a, b) => a + b;
  
  /* 위 화살표 함수는 아래 함수의 축약 버전입니다.
  
  let sum = function(a, b) {
    return a + b;
  };
  */
  
  alert( sum(1, 2) ); // 3
  ```

  - 보시는 바와 같이 `(a, b) => a + b`는 인수 `a`와 `b`를 받는 함수입니다. 
  - `(a, b) => a + b`는 실행되는 순간 표현식 `a + b`를 평가하고 그 결과를 반환합니다.

- 인수가 하나밖에 없다면 인수를 감싸는 괄호를 생략할 수 있습니다. 괄호를 생략하면 코드 길이를 더 줄일 수 있습니다.

  예시:

  ```javascript
  let double = n => n * 2;
  // let double = function(n) { return n * 2 }과 거의 동일합니다.
  
  alert( double(3) ); // 6
  ```

  인수가 하나도 없을 땐 괄호를 비워놓으면 됩니다. 다만, 이 때 괄호는 생략할 수 없습니다.

  ```javascript
  let sayHi = () => alert("안녕하세요!");
  
  sayHi();
  ```

- 화살표 함수는 함수 표현식과 같은 방법으로 사용할 수 있습니다.

  - 아래 예시와 같이 함수를 동적으로 만들 수 있습니다.

    ```js
    let age = prompt("나이를 알려주세요.", 18);
    
    let welcome = (age < 18) ?
      () => alert('안녕') :
      () => alert("안녕하세요!");
    
    welcome();
    ```



### 본문이 여러 줄인 화살표 함수

- 위에서 소개해 드린 화살표 함수들은 `=>` 왼쪽에 있는 인수를 이용해 `=>` 오른쪽에 있는 표현식을 평가하는 함수들이었습니다.

- 그런데 평가해야 할 <u>표현식이나 구문이 여러 개인 함수</u>가 있을 수도 있습니다. 

  - 이 경우 역시 화살표 함수 문법을 사용해 함수를 만들 수 있습니다. 

  - 다만, 이때는 <u>중괄호 안에 평가해야 할 코드를 넣어주어야 합니다</u>. 

  - 그리고 `return` 지시자를 사용해 명시적으로 결괏값을 반환해 주어야 합니다.

    ```js
    let sum = (a, b) => {  // 중괄호는 본문 여러 줄로 구성되어 있음을 알려줍니다.
      let result = a + b;
      return result; // 중괄호를 사용했다면, return 지시자로 결괏값을 반환해주어야 합니다.
    };
    
    alert( sum(1, 2) ); // 3
    ```



> **아직 끝나지 않았습니다.**
>
> - 지금까진 간결함이라는 특징을 중심으로 화살표 함수에 대해 알아보았습니다. 하지만 이게 다가 아닙니다!
> - 화살표 함수는 여기서 소개한 기능 이외에도 다른 흥미로운 기능을 지원합니다.
> - 자세한 내용을 배우려면 자바스크립트의 다른 내용들을 더 알아야 합니다. 
>   - 화살표 함수의 깊은 내용을 알기위해 필요한 내용을 배운 후에 [화살표 함수 다시 살펴보기](https://ko.javascript.info/arrow-functions)에서 그 내용들을 다루도록 하겠습니다.
> - 지금까진 본문이 한 줄인 화살표 함수, 화살표 함수가 콜백으로 쓰인 경우에 대해서 알아보았습니다.



### 요약

화살표 함수는 본문이 한 줄인 함수를 작성할 때 유용합니다. 본문이 한 줄이 아니라면 다른 방법으로 화살표 함수를 작성해야 합니다.

1. 중괄호 없이 작성: `(...args) => expression` – 화살표 오른쪽에 표현식을 둡니다. 함수는 이 표현식을 평가하고, 평가 결과를 반환합니다.
2. 중괄호와 함께 작성: `(...args) => { body }` – 본문이 여러 줄로 구성되었다면 중괄호를 사용해야 합니다. 다만, 이 경우는 반드시 `return` 지시자를 사용해 반환 값을 명기해 주어야 합니다.



## 2.18 기본 문법 요약

> https://ko.javascript.info/javascript-specials