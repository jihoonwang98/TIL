## 1. 인덱스 특징과 종류

**인덱스**는 원하는 데이터를 쉽게 찾을 수 있도록 돕는 책의 찾아보기와 유사한 개념이다. 인덱스는 테이블을 기반으로 선택적으로 생성할 수 있는 구조이다. 테이블에 인덱스를 생성하지 않아도 되고 여러 개를 생성해도 된다. **인덱스의 기본적인 목적은 검색 성능의 최적화이다.** 즉, 검색 조건을 만족하는 데이터를 인덱스를 통해 효과적으로 찾을 수 있도록 돕는다. 그렇지만 Insert, Update, Delete 등과 같은 DML 작업은 테이블과 인덱스를 함께 변경해야 하기 때문에 오히려 느려질 수 있다는 단점이 존재한다.





**가. 트리 기반 인덱스**

DBMS에서 가장 일반적인 인덱스는 B-트리 인덱스이다.

![image-20210316170127122](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210316170127122.png)

위 그림과 같이 B-트리 인덱스는 **브랜치 블록**(Branch Block)과 **리프 블록**(Leaf Block)으로 구성된다. 

- **루트 블록**(Root Block): 브랜치 블록 중에서 가장 상위에 있는 블록
- **브랜치 블록**(Branch Block): 분기를 목적으로 하는 블록. 다음 단계의 블록을 가리키는 포인터를 가지고 있다.
- **리프 블록**(Leaf Block): 트리의 가장 아래 단계에 존재한다.



**리프 블록**은 인덱스를 구성하는 칼럼의 **데이터**와 해당 데이터를 가지고 있는 행의 위치를 가리키는 **레코드 식별자**(RID, Record Identifier/Rowid)로 구성되어 있다. 인덱스 데이터는 인덱스를 구성하는 칼럼의 값으로 정렬된다. 만약 인덱스 데이터의 값이 동일하면 레코드 식별자의 순서로 저장된다.

리프 블록은 양방향 링크를 가지고 있다. 이것을 통해 오름차순과 내림차순 검색을 쉽게 할 수 있다. 



![image-20210316170624593](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210316170624593.png)

인덱스를 생성할 때 동일 칼럼으로 구성된 인덱스를 중복해서 생성할 수 없다. 그렇지만 인덱스 구성 칼럼은 동일하지만 칼럼의 순서가 다르면 서로 다른 인덱스로 생성할 수 있다. 예를 들어, JOB+SAL 칼럼 순서의 인덱스와 SAL+JOB 칼럼 순서의 인덱스를 별도의 인덱스로 생성할 수 있다. 인덱스의 칼럼 순서는 질의의 성능에 중요한 영향을 미치는 요소이다.





**나. SQL Server의 클러스터형 인덱스**

SQL Server의 인덱스 종류는 저장 구조에 따라 클러스터형(clustered) 인덱스와 비클러스터형(nonclustered) 인덱스로 나뉜다. 여기서는 클러스터형 인덱스에 대해서만 설명하기로 한다. 클러스터형 인덱스는 두 가지 중요한 특징이 잇다.



첫째, **인덱스의 리프 페이지가 곧 데이터 페이지다.** 따라서 테이블 탐색에 필요한 레코드 식별자가 리프 페이지에 없다(인덱스 키 칼럼과 나머지 칼럼을 리프 페이지에 같이 저장하기 때문에 테이블을 랜덤 액세스할 필요가 없다). 클러스터형 인덱스의 리프 페이지를 탐색하면 해당 테이블의 모든 칼럼 값을 곧바로 얻을 수 있다.

둘째, **리프 페이지의 모든 로우(= 데이터)는 인덱스 키 칼럼 순으로 물리적으로 정렬되어 저장된다.** 테이블 로우는 물리적으로 한 가지 순서로만 정렬될 수 있다. 그러므로 클러스터형 인덱스는 테이블당 한 개만 생성할 수 있다.(전화번호부 한 권을 상호와 인명으로 동시에 정렬할 수 없는 것과 마찬가지다.)



![image-20210316171259929](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210316171259929.png)

위 그림에 표시된 것처럼, 리프 블록에 인덱스 키 칼럼 외에도 테이블의 나머지 칼럼이 모두 함께 있다.







## 2. 전체 테이블 스캔과 인덱스 스캔

**가. 전체 테이블 스캔**

전체 테이블 스캔 방식으로 데이터를 검색한다는 것은 테이블에 존재하는 모든 데이터를 읽어 가면서 조건에 맞으면 결과로서 추출하고 조건에 맞지 않으면 버리는 방식으로 검색한다.



![image-20210316171415330](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210316171415330.png)

Oracle의 경우 위 그림과 같이 검색 조건에 맞는 데이터를 찾기 위해 테이블의 **고수위 마크(HWM, High Water Mark)** 아래의 모든 블록을 읽는다. 고수위 마크는 테이블에 데이터가 쓰여졌던 블록 상의 최상위 위치를 의미한다.

이와 같이 전체 테이블 스캔 방식은 테이블에 존재하는 모든 블록의 데이터를 읽는다. 이렇게 읽은 블록들은 재사용성이 떨어진다. 그래서 전체 테이블 스캔 방식으로 읽은 블록들은 메모리에서 곧 제거될 수 있도록 관리된다.



**옵티마이저가 연산으로서 전체 테이블 스캔 방식을 선택하는 이유는 다음과 같다.**



- **SQL 문에 조건이 존재하지 않는 경우**

  SQL 문에 조건이 존재하지 않는다는 것은 테이블에 존재하는 모든 데이터가 답이 된다는 것이다.

- **SQL 문의 주어진 조건에 사용 가능한 인덱스가 존재하지 않는 경우**

  사용 가능한 인덱스가 존재하지 않는다면 데이터를 액세스할 수 있는 방법은 테이블의 모든 데이터를 읽으면서 주어진 조건을 만족하는지를 검사하는 방법 뿐이다. 또한 주어진 조건에 사용 가능한 <u>인덱스는 존재하나 함수를 사용하여 인덱스 칼럼을 변형한 경우에도 인덱스를 사용할 수 없다.</u>

- **옵티마이저의 취사 선택**

  조건을 만족하는 데이터가 많은 경우, 결과를 추출하기 위해서 테이블의 대부분의 블록을 액세스해야 한다고 옵티마이저가 판단하면 조건에 사용 가능한 인덱스가 존재해도 전체 테이블 스캔 방식으로 읽을 수 있다.

- **그 밖의 경우**

  병렬처리 방식으로 처리하는 경우 또는 전체 테이블 스캔 방식의 힌트를 사용한 경우에 전체 테이블 스캔 방식으로 데이터를 읽을 수 있다.



**나. 인덱스 스캔**

여기서는 DB에서 주로 사용되는 트리 기반 인덱스를 중심으로 설명한다. **인덱스 스캔**은 <u>인덱스를 구성하는 칼럼의 값을 기반으로 데이터를 추출하는 액세스 기법</u>이다. 인덱스의 리프 블록은 인덱스를 구성하는 칼럼과 레코드 식별자로 구성되어 있다. 따라서 검색을 위해 인덱스의 리프 블록을 읽으면 인덱스 구성 칼럼의 값과 테이블의 레코드 식별자를 알 수 있다. 인덱스에 존재하지 않는 칼럼의 값이 필요한 경우에는 현재 읽은 레코드 식별자를 이용하여 테이블을 액세스해야 한다.

그러나 SQL 문에서 필요로 하는 모든 칼럼이 인덱스 구성 칼럼에 포함된 경우 테이블에 대한 액세스는 발생하지 않는다. 인덱스는 인덱스 구성 칼럼의 순서로 정렬되어 있다. 인덱스의 구성 칼럼이 A+B라면 먼저 칼럼 A로 정렬되고 칼럼 A의 값이 동일한 경우에는 칼럼 B로 정렬된다. 그리고 칼럼 B까지 모두 동일하면 레코드 식별자로 정렬된다. 인덱스가 구성 칼럼으로 정렬되어 있기 때문에 인덱스를 경유하여 데이터를 읽으면 그 결과 또한 정렬되어 반환된다.

따라서 인덱스의 순서와 동일한 정렬 순서를 사용자가 원하는 경우에는 정렬 작업을 하지 않을 수 있다. 인덱스 스캔 중에서 자주 사용되는 인덱스 유일 스캔(Index Unique Scan), 인덱스 범위 스캔(Index Range Scan), 인덱스 역순 범위 스캔(Index Range Scan Descending)에 대해 간단히 설명하면 다음과 같다.

- **인덱스 유일 스캔**은 유일 인덱스(Unique Index)를 사용하여 단 하나의 데이터를 추출하는 방식이다. 유일 인덱스는 중복을 허락하지 않는 인덱스이다. 유익 인덱스 구성 칼럼에 모두 '='로 값이 주어지면 결과는 최대 1건이 된다. 인덱스 유일 스캔은 유일 인덱스 구성 칼럼에 대해 모두 '='로 값이 주어진 경우에만 가능한 인덱스 스캔 방식이다.
- **인덱스 범위 스캔**은 인덱스를 이용하여 한 건 이상의 데이터를 추출하는 방식이다. 유일 인덱스의 구성 칼럼 모두에 대해 '='로 값이 주어지지 않은 경우와 비유일 인덱스(Non-Unique Index)를 이용하는 모든 액세스 방식은 인덱스 범위 스캔 방식으로 데이터를 액세스 하는 것이다.



**다. 전체 테이블 스캔과 인덱스 스캔 방식의 비교**



데이터를 액세스 하는 방법은 크게 두 가지로 나눌 수 있다. 

- 인덱스를 경유해서 읽는 **인덱스 스캔 방식**과
- 테이블의 전체 데이터를 모두 읽으면서 데이터를 추출하는 **전체 테이블 스캔 방식**이다.



**인덱스 스캔 방식**은 사용 가능한 적절한 인덱스가 존재할 때만 이용할 수 있는 스캔 방식이지만

**전체 테이블 스캔 방식**은 인덱스의 존재 유무와 상관없이 항상 이용가능한 스캔 방식이다.

앞에서 설명한 것처럼 옵티마이저는 인덱스가 존재하더라도 전체 테이블 스캔 방식을 취사 선택할 수 있다.



아래 그림은 전체 테이블 스캔과 인덱스 스캔에 대한 SQL 처리 흐름도 표현의 예이다.



![image-20210316173013766](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210316173013766.png)



인덱스 스캔은 인덱스에 존재하는 레코드 식별자를 이용해서 검색하는 데이터의 정확한 위치를 알고서 데이터를 읽는다. 그렇기 때문에 **인덱스 스캔 방식에서는 불필요하게 다른 블록을 더 읽을 필요가 없다. 따라서 한 번의 I/O 요청에 한 블록씩 데이터를 읽는다**. 그러나 **전체 테이블 스캔은 데이터를 읽을 때 한 번의 I/O 요청으로 여러 블록을 한꺼번에 읽는다.** 어차피 테이블의 모든 데이터를 읽을 것이라면 한 번 읽기 작업을 할 때 여러 블록을 함께 읽는 것이 효율적이다.



**대용량 데이터 중에서 극히 일부의 데이터를 찾을 때**, 인덱스 스캔 방식은 인덱스를 이용해 몇 번의 I/O만으로 원하는 데이터를 쉽게 찾을 수 있다. 그러나 전체 테이블 스캔은 테이블의 모든 데이터를 읽으면서 원하는 데이터를 찾아야 하기 때문에 비효율적인 검색을 하게 된다. 

그러나 반대로 **테이블의 대부분의 데이터를 찾을 때**는, 한 블록씩 읽는 인덱스 스캔 방식보다는 어차피 대부분의 데이터를 읽을 거라면 한 번에 여러 블록씩 읽는 전체 테이블 스캔 방식이 유리할 수 있다.

