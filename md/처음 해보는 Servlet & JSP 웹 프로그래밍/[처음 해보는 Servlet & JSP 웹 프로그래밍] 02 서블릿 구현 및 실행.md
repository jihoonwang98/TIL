## 02 서블릿 구현 및 실행



### 2.1 웹 애플리케이션

서블릿을 만드는 목적은 클라이언트에 서비스하기 위해서이다. 이번 절에서는 웹서버에 서블릿이 어떤 구조로 있어야 하며, 클라이언트가 서블릿에 접근하는 방법을 알아보겠다.



#### 2.1.1 웹 애플리케이션 접근

클라이언트는 웹서버에 서비스를 요청할 때 URL 정보를 보낸다. 만약 클라이언트가 서버에 다음과 같은 URL 정보를 보냈다면, 클라이언트가 요청한 문서를 찾아가고자 URL의 정보를 다음과 같은 용도로 사용한다.



`http://70.12.220.93:8080/edu/index.jsp`



**1)** IP가 70.12.220.93인 컴퓨터를 찾아감

**2)** 8080 포트를 사용하고 있는 서버를 찾아감

**3)** edu라는 이름의 웹 애플리케이션을 찾아감

**4)** /index.jsp 파일을 찾아감



클라이언트가 URL의 컴퓨터 주소와 포트 번호를 이용해 웹서버까지 찾았다면 다음 목적지는 웹 애플리케이션입니다.  웹서버가 클라이언트에 서비스하는 단위는 웹 애플리케이션입니다. 그래서 개발할 때 먼저 웹 애플리케이션을 생성한 후, 그 안에 서비스하고자 하는 파일들을 작성합니다. 그리고 작성된 파일을 실행하려면 파일이 포함된 웹 애플리케이션을 웹서버에 올린(deploy) 후 서비스를 요청합니다.



위에서 예로 든 URL을 좀 더 자세하게 살펴보겠습니다.

1) 70.12.220.93: 웹 애플리케이션을 서비스하는 웹서버가 설치된 컴퓨터 주소입니다. 컴퓨터 주소는 아이피 주소 또는 도메인 이름으로 지정합니다. 

2) :8080: 포트 번호로 서버를 찾아가기 위한 정보입니다. 컴퓨터 주소를 이용해 컴퓨터를 찾았다면 이제 해당 컴퓨터에서 서비스하는 서버 중 웹서버를 찾을 차례입니다. 웹서버가 사용하는 포트는 80번으로 예약되어 있으며 포트 번호를 생략하면 80으로 자동 인식합니다. 포트 번호가 80이 아닐 때는 반드시 명시해주어야 합니다. 

3) /edu: 애플리케이션 이름입니다. 포트 번호로 웹서버를 찾았다면 이제 웹서버에서 서비스하는 애플리케이션을 찾아야 합니다. 웹서버는 애플리케이션 단위로 서비스하기 때문입니다.

4) /index.jsp: 클라이언트가 요청한 최종 문서정보입니다. 애플리케이션을 찾은 다음에는 해당 애플리케이션에서 서비스하는 문서를 찾아야 합니다. 찾으려는 웹 문서의 경로는 파일시스템의 디렉터리 구조 형태로 지정합니다. 즉, 루트 디렉터리(/)로 시작하여 하위 디렉터리로 내려가면서 파일을 찾는 경로를 지정합니다.





#### 2.1.2 웹 애플리케이션 위치

서비스는 서버에서 애플리케이션 단위로 이루어집니다. 웹서버마다 시작될 때 자동으로 애플리케이션으로 인식하여 서비스를 올려주는 디렉터리가 있습니다. 아파치 톰캣(Tomcat)의 경우 톰캣을 설치한 디렉터리 하위의 webapps 디렉터리에 애플리케이션들이 있습니다. 

**webapps 디렉터리에 있는 하위 디렉터리 또는 디렉터리가 압축된 war 파일은 하나의 애플리케이션으로 인식합니다.**

**이클립스에서 실제 애플리케이션의 루트 디렉터리는 "WebContent"입니다.** 이 디렉터리가 톰캣의 webapps의 하위 디렉터리에 해당합니다. 어차피 애플리케이션의 루트 디렉터리는 URL에서 "/"라는 기호로 접근하므로 디렉터리 이름이 무엇인지는 상관없습니다.





#### 2.1.3 웹 애플리케이션 구조

웹 애플리케이션은 디렉터리나 디렉터리가 압축된 형태로 웹서버에 올려서 서비스합니다.

웹 애플리케이션은 하나의 디렉터리입니다. 이 디렉터리 안에 서비스하려는 문서들을 만들어 놓으면 웹에서 서비스되는 것입니다. 그런데 반드시 모든 웹 애플리케이션이 공통으로 가져야 하는 디렉터리와 파일이 있습니다. 그것은 웹 애플리케이션 루트 디렉터리 바로 하위에 **WEB-INF 디렉터리**이며, WEB-INF 디렉터리에는 **web.xml 파일**이 있어야 합니다.

또한, 현재 웹 애플리케이션에서 서비스하려는 클래스 파일이 있다면 WEB-INF/classes 디렉터리 하위에 있어야 합니다. 그리고 클래스 파일들이 jar로 압축되어 있다면 WEB-INF/lib 디렉터리에 있어야 합니다. 왜냐하면, 클래스 파일들이 WEB-INF/classes 또는 WEB-INF/lib에 있어야만 WAS를 구성하는 애플리케이션 서버들이 자동으로 인식할 수 있기 때문입니다. web.xml 파일과 클래스 파일을 제외한 다른 파일들은 웹 애플리케이션 루트 디렉터리 하위의 어느 곳에 있어도 상관 없습니다.





#### 2.1.4 환경설정 파일: web.xml

웹서버가 서비스를 시작하기 위해 구동할 때 서버에서 많은 일이 일어납니다. 그중의 하나가 클라이언트에 서비스하기 위한 웹 애플리케이션을 준비하는 작업입니다. 이때 웹서버는 각 웹 애플리케이션의 web.xml 파일을 읽습니다. **web.xml은 웹 애플리케이션의 서비스 처리에 관한 내용이 정의된 파일**입니다. 웹서버는 web.xml에 정의된 내용대로 웹 애플리케이션을 실행하기 위한 설정을 수행합니다.

정리하자면, web.xml은 웹 애플리케이션 실행에 관해 정의하는 <u>환경설정 파일</u>이며, 웹 애플리케이션 서비스 시작 시 웹서버가 읽어서 사용하는 파일입니다.



만약 web.xml 파일에 정의한 내용이 논리적으로나 문법적으로 잘못되었다면, 웹서버가 웹 애플리케이션을 서비스하는 데 필요한 준비 설정을 올바르게 할 수 없습니다. 웹서버는 웹 애플리케이션 단위로 서비스한다고 했습니다. 따라서 잘못 작성한 web.xml 파일 때문에 서비스에 실패한다면, 웹 애플리케이션 안에 있는 모든 파일은 서비스되지 않습니다.





#### 2.1.5 서블릿 디렉터리

서블릿 디렉터리란, 서블릿이 공식적으로 존재하는 디렉터리로서 (서블릿 컨테이너를 내장한) 모든 WAS의 구조가 같습니다. 서블릿 프로그램 실행에 관련된 클래스 파일들은 이 디렉터리에 있어야만 서블릿 컨테이너가 인식하여 실행합니다. **서블릿 디렉터리는 웹 애플리케이션의 루트 디렉터리 하위의 WEB-INF/classes입니다.**



이클립스에서 서블릿을 개발할 때는 소스 폴더에 자바 소스를 작성하면 자동으로 컴파일되어 클래스 파일이 생성됩니다. 





---

### 2.2 서블릿 구현

웹 브라우저에서 클라이언트의 요청에 따라 서버가 실행할 수 있는 자바 프로그램은 서블릿뿐입니다. 이 말은 오직 서블릿만이 웹에서 동작하는 특별한 조건을 가지고 있다는 뜻일 텐데요. 이러한 조건은 이미 서블릿 API를 통해 제공하고 있어서 우리가 직접 만들지 않아도 됩니다. 따라서 서블릿을 구현할 때 해당 API만 상속하면 웹에서 동작하는 기본 조건을 갖출 수 있습니다. 이번 절에서는 **서블릿 객체의 상속 구조와 생명주기**에 관해 알아보겠습니다.





#### 2.2.1 서블릿 API 문서

서블릿을 구현할 때 필요한 객체들을 굳이 따로 만들 필요 없이 WAS에서 제공하는 서블릿 API를 가져다 사용하면 됩니다. 즉, 이미 구현되어 있는 서블릿 API를 상속받거나 필요한 메소드를 재정의해야 하는데요. WAS에서 제공하는 서블릿 API를 제대로 활용하려면 해당 문서를 참고해야 합니다. 서블릿 API 문서는 웹사이트에서 쉽게 찾을 수 있습니다. 





#### 2.2.2 서블릿 클래스 간의 관계

서블릿을 구현할 때 반드시 상속받아야 하는 클래스가 있는데요. 바로 **javax.servlet.http 패키지에 있는 HttpServlet 클래스**입니다. HttpServlet에는 웹상에서 클라이언트 요청이 있을 때 해당 서블릿을 실행하는 모든 조건이 포함되어 있습니다. 그래서 모든 서블릿은 반드시 HttpServlet을 상속받아야 합니다. HttpServlet를 상속받지 않은 클래스는 서블릿이라 할 수 없고, 따라서 클라이언트가 실행을 요청하여도 실행되지 않습니다.



모든 서블릿의 상위에 있는 HttpServlet, GenericServlet, Servlet에 대해 간단하게 정리해보겠습니다.



**Servlet 인터페이스**

Servlet은 서블릿 프로그램을 개발할 때 반드시 구현해야 하는 메소드를 선언하고 있는 인터페이스입니다. init(), service(), destroy(), getServletConfig(), getServletInfo() 등 5개의 메소드를 선언하고 있는데요. 이는 서블릿 프로그램 실행의 생명주기와 연관된 메소드들입니다.



**GenericServlet 클래스**

GenericServlet은 Servlet 인터페이스를 상속하여 클라이언트-서버 환경에서 서버단의 애플리케이션으로서 필요한 기능을 구현한 추상 클래스입니다. service() 메소드를 제외한 모든 메소드를 재정의하여 적절한 기능으로 구현하였습니다. GenericServlet 클래스를 상속하면 애플리케이션의 프로토콜에 따라 메소드 재정의 구문을 적용해야 합니다.



**HttpServlet 클래스**

HttpServlet 클래스는 GenericServlet 클래스를 상속하여 service() 메소드를 재정의함으로써 HTTP 프로토콜에 알맞은 동작을 수행하도록 구현한 클래스입니다. 즉, HTTP 프로토콜 기반으로 브라우저로부터 요청을 전달받아서 처리하도록 하는 클래스입니다. service() 메소드에는 요청방식에 따라 doGet(), doPost() 등 정해진 사양의 메소드가 호출되도록 구현되어 있습니다.

HttpServlet 클래스를 상속하여 웹서버 기반의 서블릿 프로그램을 구현할 때 반드시 재정의해야 하는 메소드는 없으며, 어떠한 요청방식을 지원하는 서블릿인지에 따라서 필요한 메소드를 재정의하여 구현합니다.



#### 2.2.3 서블릿 작성

첫 번째 서블릿을 구현해 봅시다. 일단 프로젝트 생성은 아래 링크를 참조합시다.

> https://velog.io/@ruddms936/IntelliJ%EB%A1%9C-JSP-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%83%9D%EC%84%B1
>
> [IntelliJ JSP 프로젝트 생성하는 법]



**(1):** **src** 폴더에서 마우스 우클릭 후 **[New] -> [Package]** 후 **com.tistory.kgvovc** 패키지 생성

**(2):** **com.tistory.kgvovc**에 우클릭 후 **[New] -> [Create New Servlet]** 선택 후 이름에 **FirstServlet** 입력. Create Java EE 6 annotated class는 체크 해제함.



새 Servlet 파일이 생성되었으면 아래와 같은 코드가 자동으로 생성된다.

```java
// FirstServlet.java

package com.tistory.kgvovc;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class FirstServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }
}
```

***모든 서블릿 클래스는 HttpServlet을 상속 받아야 한다.**





#### 2.2.4 서블릿 실행 순서

서블릿의 실행 순서를 이해하려면 **IoC**라는 개념을 알아야 합니다. Java SE 프로그램은 개발자가 main() 메소드 안에 구현한 순서대로 실행됩니다. 즉, 프로그램이 실행되는 순서를 개발자가 제어합니다. 그러나 **Java EE 기반 프로그램**은 실행의 흐름을 개발자가 제어하는 것이 아니라 **컨테이너가 제어**합니다. 



이처럼 개발자가 아닌 제3자가 프로그램의 실행 흐름을 제어하는 것을 **IoC(Inversion of Control)**, 우리말로 번역하면 "제어의 역전"이라고 합니다. 우리가 개발할 서블릿도 여기에 속합니다. 따라서 Java EE 기반 프로그램을 개발할 때는 먼저 애플리케이션 컨테이너들이 프로그램을 어떤 순서로 동작시키는지 알고 해당 순서에 맞게 개발해야 합니다.

![99C3483E5C6C89451E](C:\Users\user\Pictures\99C3483E5C6C89451E.png)

다음은 서블릿의 실행 순서와 설명입니다.



**1) 클라이언트로부터 처리 요청 받음**: 클라이언트가 웹 브라우저를 통해 요청을 보내면 웹서버는 이를 받아서 요청정보의 헤더 안에 있는 URI를 분석합니다. 이때, 요청받은 페이지가 서블릿이면 서블릿 컨테이너에 처리를 넘깁니다. 서블릿 컨테이너는 요청받은 서블릿을 WEB-INF/classes나 WEB-INF/lib에서 찾아서 실행 준비를 합니다.



**2) 최초의 요청 여부 판단**: 서블릿 컨테이너는 현재 실행할 서블릿이 최초의 요청인지를 판단합니다. 실행할 서블릿 객체가 메모리에 없으면 최초의 요청이고, 이미 있으면 최초의 요청이 아닌 것으로 판단합니다.



**3) 서블릿 객체 생성**: 서블릿 컨테이너는 요청받은 서블릿이 최초의 요청이라면 해당 서블릿을 메모리에 로딩하고 객체를 생성합니다. 일반 자바 객체는 new 명령문으로 여러 개의 객체를 언제든지 직접 생성할 수 있지만, **서블릿은 최초 요청이 들어왔을 때 한 번만 객체를 생성하고 이때 생성된 객체를 계속 사용**합니다.



**4) init() 메소드 실행**: init()는 서블릿 객체가 생성된 다음에 호출되는 메소드로서, Servlet 인터페이스에 선언되어 있고, 기능은 GenericServlet 클래스에 구현되어 있습니다. init() 메소드는 처음 요청 시 서블릿 객체가 생성된 다음 호출되므로 주로 **서블릿 객체의 초기화** 작업이 구현되어 있습니다. GenericServlet 클래스에 구현된 내용을 바꾸고 싶다면 init() 메소드를 재정의하여 원하는 내용으로 변경하면 됩니다.



**5) service() 메소드 실행**: service() 메소드는 실행하는 서블릿의 요청 순서에 상관없이 클라이언트의 요청이 있을 때마다 실행됩니다. 따라서 service() 메소드에는 실제 서블릿에서 처리해야 하는 내용이 구현되어 있습니다. service() 메소드는 Servlet 인터페이스에 선언되어 있고, GenericServlet 클래스에 abstract 메소드로 선언되어 있으므로, HttpServlet 클래스에 메소드 몸체가 구현되어 있습니다. HttpServlet 클래스에 구현된 내용을 변경하고 싶다면 service() 메소드를 재정의하여 원하는 내용으로 변경하면 됩니다.





service() 메소드가 끝나면 서버에서의 실행은 끝납니다. 서버 프로그램 실행이 완료된 후에는 서블릿 컨테이너가 실행결과를 웹서버에 전달하고, 웹서버는 서비스를 요청한 클라이언트에 응답합니다. 이로써 웹에서 하나의 요청에 대한 처리가 완료됩니다.



앞에서 설명한 **init()와 service()** 메서드를 **Override**하여 서블릿 파일을 완성해보겠습니다.



```java
// FirstServlet.java

package com.tistory.kgvovc;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class FirstServlet extends HttpServlet {
    
    @Override
    public void init(ServletConfig config) throws ServletException {
        System.out.println("init() 실행됨!");
    }

    @Override
    public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException {
        System.out.println("service() 실행됨!");
    }
}

```





#### 2.2.5 콜백 메소드와 서블릿 객체의 생명주기

이 책에서 말하는 **콜백 메소드(callback method)**란, **어떤 객체에서 어떤 상황이 발생하면 컨테이너가 자동으로 호출하여 실행되는 메소드**를 의미합니다. 이러한 콜백 메소드들이 서블릿을 실행합니다. 바로 앞에서 설명했던 HttpServlet 클래스를 상속받은 다음 재정의한 init(), service()가 콜백 메소드에 속합니다. 이 메소드들은 서블릿 객체에 어떤 상황(이벤트)이 발생하면 호출됩니다.



그런데 init()와 service() 메소드 말고 서블릿의 콜백 메소드가 또 하나 있습니다. GenericServlet 클래스에 선언되어 있는 destroy() 메소드입니다. destroy()는 메모리에서 서블릿 객체가 삭제될 때 호출되는 메소드입니다. 객체가 삭제될 때 호출되므로 자원을 해제하는 작업을 수행합니다.



다음은 서블릿의 콜백 메소드에 대한 설명을 표로 정리한 것입니다.

| 메소드 이름   | 메소드가 실행되는 시점                                       | 실행 횟수 | 기능 구현                        |
| ------------- | ------------------------------------------------------------ | --------- | -------------------------------- |
| **init()**    | 클라이언트로부터 최초로 서블릿 요청이 있을 때 실행           | 1         | 초기화 작업                      |
| **service()** | 클라이언트로부터 요청이 있을 때마다 실행                     | n         | 실제 서블릿이 처리해야 하는 작업 |
| **destroy()** | 서블릿 객체가 메모리에서 삭제될 때 실행(서비스나 서버 중지 시) | 1         | 자원 해제 작업                   |



**서블릿 객체의 생성**

**서블릿 객체가 메모리에 생성되는 시점**은 서버 입장에서 클라이언트로부터 최초로 서블릿 실행 요청이 있을 때입니다. <u>클라이언트 입장이 아니고 서버 입장입니다.</u> 어떤 클라이언트가 최초로 요청했는지는 중요하지 않습니다.

서버 입장에서 최초로 서블릿 요청이 있을 때, 서블릿 컨테이너는 해당 서블릿 객체를 메모리에 생성한 다음, init() -> service() 순으로 실행합니다. 이후에 같은 서블릿 실행 요청이 있으면 최초 요청 시 생성한 서블릿 객체의 service() 메소드를 실행합니다. 

사실 클라이언트로부터 서블릿 요청이 있을 때마다 **요청이 최초인지를 판단하는 기준**은 **객체 생성 여부**입니다. 중요한 사실은 요청이 있을 때마다 서블릿 객체를 생성하는 것이 아니고, 최초 요청 때 생성한 서블릿 객체를 계속 사용한다는 것입니다. 서블릿은 한 번 생성한 객체를 재사용해 처리속도, 메모리 부분에서 효율적인 장점이 있습니다.



**서블릿 객체의 삭제**

최초 요청 시 생성된 **서블릿 객체가 삭제되는 시점**은 서버를 중지시켜 **웹 애플리케이션 서비스를 중지할 때**입니다. 웹서버에서는 전체 서비스를 중지할 수도 있고 일부 서비스만 중지할 수도 있습니다. 어떤 상황이든지 서블릿 객체가 삭제되는 시점은 웹서버에서 웹 애플리케이션 서비스가 중지되는 시점입니다. 이때 destroy() 메소드가 호출되어 실행됩니다. 그래서 destroy() 메소드에는 자원 해제하는 내용을 구현하면 알맞습니다.





### 2.3 서블릿 실행





































 