**서브쿼리**(Subquery)란 하나의 SQL 문 안에 포함되어 있는 또 다른 SQL문을 말한다. 서브 쿼리는 알려지지 않은 기준을 이용한 검색을 위해 사용한다.



조인은 조인에 참여하는 모든 테이블이 대등한 관계에 있기 때문에 조인에 참여하는 모든 테이블의 칼럼을 어느 위치에서라도 자유롭게 사용할 수 있다. 그러나 서브쿼리는 메인쿼리의 칼럼을 모두 사용할 수 있지만 메인쿼리는 서브쿼리의 칼럼을 사용할 수 없다.



질의 결과에 서브쿼리 칼럼을 표시해야 한다면 조인 방식으로 변환하거나 함수, 스칼라 서브쿼리(Scalar Subquery) 등을 사용해야 한다. <u>조인</u>은 집합간의 곱(Product)의 관계이다. 예를 들어, 조직(1)과 사원(M) 테이블을 조인하면 결과는 사원 레벨(M)의 집합이 생성된다. 그러나 **서브쿼리는 서브쿼리 레벨과는 상관없이 항상 메인쿼리 레벨로 결과 집합이 생성된다**.  예를 들어, 메인쿼리로 조직(1), 서브쿼리로 사원(M) 테이블을 사용하면 결과 집합은 조직(1) 레벨이 된다.





**서브쿼리 사용 주의점**

**1)** 서브쿼리는 단일 행 또는 복수 행 비교 연산자와 함께 사용 가능하다. 단일 행 비교 연산자는 서브쿼리의 결과가 반드시 1건 이하여야 하고, 복수 행 비교 연산자는 서브쿼리의 결과 건수와 상관 없다.

**2)** 서브쿼리에서는 ORDER BY를 사용하지 못한다. ORDER BY 절은 SELECT 절에서 오직 한 개만 올 수 있다.





**서브쿼리가 SQL문에서 사용 가능한 곳**

- SELECT 절
- FROM 절
- WHERE 절
- HAVING 절
- ORDER BY 절
- INSERT 문의 VALUES 절
- UPDATE 문의 SET 절





**동작하는 방식에 따른 서브쿼리 분류**

- Un-Correlated(비연관) 서브쿼리: 서브쿼리가 메인쿼리 칼럼을 가지고 있지 않는 형태의 서브쿼리이다. 메인쿼리에 값(서브쿼리가 실행된 결과)을 제공하기 위한 목적으로 주로 사용한다.
- Correlated(연관) 서브쿼리: 서브쿼리가 메인쿼리 칼럼을 가지고 있는 형태의 서브쿼리이다. 일반적으로 메인쿼리가 먼저 수행되어 읽혀진 데이터를 서브쿼리에서 조건이 맞는지 확인하고자 할 때 주로 사용된다.



서브쿼리는 메인쿼리 안에 포함된 종속적인 관계이기 때문에 논리적인 실행순서는 항상 메인쿼리에서 읽혀진 데이터에 대해 서브쿼리에서 해당 조건이 만족하는지를 확인하는 방식으로 수행되어야 한다. 그러나 실제 서브쿼리의 실행순서는 상황에 따라 달라질 수 있다. <u>반환되는 데이터의 형태에 따라 서브쿼리는 다음과 같이 세 가지로 분류된다</u>.



**반환되는 데이터의 형태에 따른 서브쿼리 분류**

- **단일 행 서브쿼리**: 서브쿼리의 실행 결과가 항상 1건 이하인 서브쿼리를 의미한다. 단일 행 비교 연산자에는 =, <, <=, >, >=, <>이 있다.
- **다중 행 서브쿼리**: 서브쿼리의 실행 결과가 여러 건인 서브쿼리를 의미한다. 다중 행 서브쿼리는 다중 행 비교 연산자와 함께 사용된다. 다중 행 비교 연산자에는 IN, ALL, ANY, SOME, EXISTS가 있다.
- **다중 칼럼 서브쿼리**: 서브쿼리의 실행 결과로 여러 칼럼을 반환한다. 메인쿼리의 조건절에 여러 칼럼을 동시에 비교할 수 있다.









## 1. 단일 행 서브 쿼리

```sql
SELECT name, position, back_no
FROM player
WHERE team_id = (SELECT team_id
				 FROM player
				 WHERE player_name = '정남일');
-- 정남일이 두 명 이상이면 에러남
```







## 2. 다중 행 서브쿼리

**다중 행 비교 연산자**

| 다중 행 연산자             | 설명                                                         |
| -------------------------- | ------------------------------------------------------------ |
| IN (서브쿼리)              | 서브쿼리의 결과에 존재하는 임의의 값과 동일한 조건을 의미한다. |
| 비교 연산자 ALL (서브쿼리) | 서브쿼리의 결과에 존재하는 모든 값을 만족하는 조건을 의미한다. |
| 비교 연산자 ANY (서브쿼리) | 서브쿼리의 결과에 존재하는 어느 하나의 값이라도 만족하는 조건을 의미한다. |
| EXISTS (서브쿼리)          | 서브쿼리의 결과를 만족하는 값이 존재하는지 여부를 확인하는 조건을 의미한다. |





## 3. 다중 칼럼 서브쿼리



## 4. 연관 서브쿼리



## 5. 그 밖에 위치에서 사용하는 서브쿼리



**가. SELECT 절에 서브쿼리 사용하기**

SELECT 절에서 사용하는 서브쿼리인 **스칼라 서브쿼리**(Scalar Subquery)에 대해서 알아보자. 스칼라 서브쿼리는 한 행, 한 칼럼(1 Row 1 Column) 만을 반환하는 서브쿼리를 말한다. 



**나. FROM 절에서 서브쿼리 사용하기**

FROM 절에서 사용되는 서브쿼리를 **인라인 뷰**(Inline View)라고 한다. FROM 절에는 테이블 명이 오도록 되어 있다. 그런데 서브쿼리가 FROM 절에 사용되면 어떻게 될까? 서브쿼리의 결과가 마치 실행 시에 동적으로 생성된 테이블인 것처럼 사용할 수 있다. 인라인 뷰는 SQL문이 실행될 때만 임시적으로 생성되는 동적인 뷰이기 때문에 DB에 해당 정보가 저장되지 않는다. 그래서 일반적인 뷰를 정적 뷰라고 하고 **인라인 뷰를 동적 뷰(Dynamic View)라고 한다.**



**인라인 뷰에서는 ORDER BY 절을 사용할 수 있다**. 인라인 뷰에 먼저 정렬을 수행하고 정렬된 결과 중에서 일부 데이터를 추출하는 것을 TOP-N 쿼리라고 한다. TOP-N 쿼리를 수행하기 위해서는 정렬 작업과 정렬 결과 중에서 일부 데이터만을 추출할 수 있는 방법이 필요하다. Oracle에서는 ROWNUM이라는 연산자를 통해서 결과로 추출하고자 하는 데이터 건수를 제약할 수 있다.

```sql
SELECT player_name, position, back_no, height
FROM (SELECT player_name, position, back_no, height
	  FROM player
	  WHERE height IS NOT NULL
	  ORDER BY height DESC)
WHERE ROWNUM <= 5;
```



**다. HAVING 절에서 서브쿼리 사용하기**

HAVING 절은 그룹함수와 함께 사용될 때 그룹핑된 결과에 대해 부가적인 조건을 주기 위해서 사용한다.

```sql
SELECT p.team_id, t.team_name, AVG(p.height)
FROM player p, team t
WHERE p.team_id = t.team_id
GROUP BY p.team_id, t.team_name
HAVING AVG(p.height) < (SELECT AVG(height)
                        FROM player
                        WHERE team_id = 'K02');
```





**라. UPDATE 문의 SET 절에서 사용하기**

```sql
UPDATE team a
SET a.stadium_name = (SELECT x.stadium_name
                      FROM stadium x
                      WHERE x.stadium_id = a.stadium_id);
```



**마. INSERT 문의 VALUES 절에서 사용하기**

```sql
INSERT INTO player(player_id, player_name, team_id)
VALUES(  (SELECT TO_CHAR( MAX(TO_NUMBER(player_id)) + 1) FROM PLAYER), '홍길동', 'K06');
```





## 6. 뷰(View)

테이블은 실제로 데이터를 가지고 있는 반면, 뷰(View)는 실제 데이터를 가지고 있지 않다. 뷰는 단지 뷰 정의(View Definition)만을 가지고 있다. 질의에서 뷰가 사용되면 뷰 정의를 참조해서 DBMS 내부적으로 질의를 재작성(Rewrite)하여 질의를 수행한다.

뷰는 실제 데이터를 가지고 있지 않지만 테이블이 수행하는 역할을 수행하기 때문에 가상 테이블(Virtual Table)이라고도 한다.

















