# [모던 JavaScript 튜토리얼 - 코어 자바스크립트] 5. 자료구조와 자료형

> https://ko.javascript.info/data-types

**목표**

- 자바스크립트에서 제공해주는 다양한 자료구조에 대해 알아봅시다.
- 여기에 더하여 자료형을 좀 더 깊이 학습해봅시다.



## 5.1 원시값의 메서드

> https://ko.javascript.info/primitives-methods

**도입**

- 자바스크립트는 원시값(문자열, 숫자 등)을 마치 객체처럼 다룰 수 있게 해줍니다. 
  - 원시값에도 객체에서처럼 메서드를 호출할 수 있죠. 
  - 원시값의 메서드에 대해선 곧 학습할 예정인데 그 전에, <u>원시값은 객체가 아니란 것</u>을 상기하도록 합시다.
- 원시값과 객체는 다음과 같은 차이점이 있습니다.
  - 원시값:
    - 원시형 값입니다.
    - 원시형의 종류는 `문자(string)`, `숫자(number)`, `bigint`, `불린(boolean)`, `심볼(symbol)`, `null`, `undefined`형으로 총 일곱 가지 입니다.
  - 객체:
    - 프로퍼티에 다양한 종류의 값을 저장할 수 있습니다.
    - `{name : "John", age : 30}`와 같이 대괄호 `{}`를 사용해 만들 수 있습니다. 
    - 자바스크립트에는 여러 종류의 객체가 있는데, 함수도 객체의 일종입니다.

- 객체의 장점 중 하나는 함수를 프로퍼티로 저장할 수 있다는 것입니다.

  ```js
  let john = {
    name: "John",
    sayHi: function() {
      alert("친구야 반갑다!");
    }
  };
  
  john.sayHi(); // 친구야 반갑다!
  ```

  - 객체 `john`을 만들고, 거기에 메서드 `sayHi`를 정의해보았습니다.
  - 자바스크립트는 날짜, 오류, HTML 요소(HTML element) 등을 다룰 수 있게 해주는 다양한 내장 객체를 제공합니다. 
    - 이 객체들은 고유한 프로퍼티와 메서드를 가집니다.
  - 하지만, 이런 기능을 사용하면 시스템 자원이 많이 소모된다는 단점이 있습니다.
  - 객체는 원시값보다 “무겁고”, 내부 구조를 유지하기 위해 추가 자원을 사용하기 때문입니다.



### 원시값을 객체처럼 사용하기

- 자바스크립트 창안자(creator)는 다음과 같은 모순적인 상황을 해결해야만 했었습니다.
  - 문자열이나 숫자와 같은 원시값을 다루어야 하는 작업이 많은데, 메서드를 사용하면 작업을 수월하게 할 수 있을 것 같다는 생각이 듭니다.
  - 그런데 원시값은 가능한 한 빠르고 가벼워야 합니다.
- 조금 어색해 보이지만, 자바스크립트 창안자는 아래와 같은 방법을 사용해 해결책을 모색하였습니다.
  1. 원시값은 원시값 그대로 남겨둬 단일 값 형태를 유지합니다.
  2. 문자열, 숫자, 불린, 심볼의 메서드와 프로퍼티에 접근할 수 있도록 언어 차원에서 허용합니다.
  3. 이를 가능하게 하기 위해, 원시값이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체, "원시 래퍼 객체(object wrapper)"를 만들어 줍니다. 이 객체는 곧 삭제됩니다.

- "래퍼 객체"는 원시 타입에 따라 종류가 다양합니다. 

  - 각 래퍼 객체는 원시 자료형의 이름을 그대로 차용해, `String`,`Number`,`Boolean`, `Symbol`라고 부릅니다. 
  - 래퍼 객체 마다 제공하는 메서드 역시 다릅니다.

- 인수로 받은 문자열의 모든 글자를 대문자로 바꿔주는 메서드 [str.toUpperCase()](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase)를 예로 들어보겠습니다.

  ```js
  let str = "Hello";
  alert( str.toUpperCase() ); // HELLO
  ```

  - 간단하죠? 아래는 `str.toUpperCase ()`가 호출될 때 내부에서 실제로 일어나는 일입니다.
    1. 문자열 `str`은 원시값이므로 원시값의 프로퍼티(toUpperCase)에 접근하는 순간 특별한 객체가 만들어집니다. 이 객체는 문자열의 값을 알고 있고, `toUpperCase()`와 같은 유용한 메서드를 가지고 있습니다.
    2. 메서드가 실행되고, 새로운 문자열이 반환됩니다(`alert` 창에 이 문자열이 출력됩니다).
    3. 특별한 객체는 파괴되고, 원시값 `str`만 남습니다.
  - 이런 내부 프로세스를 통해 원시값을 가볍게 유지하면서 메서드를 호출할 수 있는 것입니다.
  - 자바스크립트 엔진은 위 프로세스의 최적화에 많은 신경을 씁니다. 
    - 원시 래퍼 객체를 만들지 않고도 마치 원시 래퍼 객체를 생성(명세에 언급됨)한 것처럼 동작하게끔 해주죠.

- 숫자형도 고유한 메서드를 지원합니다. 메서드 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)를 이용하면 원하는 자리에서 소수점 아래 숫자를 반올림할 수 있습니다.

  ```js
  let n = 1.23456;
  alert( n.toFixed(2) ); // 1.23
  ```

- [숫자형](https://ko.javascript.info/number), [문자열](https://ko.javascript.info/string)에서 더 많은 메서드에 대해 알아보겠습니다.



> **`String/Number/Boolean`를 생성자론 쓰지 맙시다.**
>
> - Java 등의 몇몇 언어에선 `new Number(1)` 또는 `new Boolean(false)`와 같은 문법을 사용해 원하는 타입의 "래퍼 객체"를 직접 만들 수 있습니다.
>
> - 자바스크립트에서도 하위 호환성을 위해 이 기능을 남겨 두었는데, 이런 식으로 래퍼 객체를 만드는 건 **추천하지 않습니다**. 
>   - 몇몇 상황에서 혼동을 불러일으키기 때문입니다.
>
> 
>
> - 예시:
>
>   ```js
>   alert( typeof 0 ); // "number"
>   alert( typeof new Number(0) ); // "object"!
>   ```
>
> 
>
> - 객체는 논리 평가 시 항상 참을 반환하기 때문에, 아래 예시에서 얼럿창은 무조건 열립니다.
>
>   ```js
>   let zero = new Number(0);
>   
>   if (zero) { // 변수 zero는 객체이므로, 조건문이 참이 됩니다.
>     alert( "그런데 여러분은 zero가 참이라는 것에 동의하시나요!?!" );
>   }
>   ```
>
>   
>
> - 그런데, `new`를 붙이지 않고 `String / Number / Boolean`을 사용하는 건 괜찮습니다. 
>
>   - `new` 없이 사용하면 상식에 맞게 인수를 원하는 형의 원시값(문자열, 숫자, 불린 값)으로 바꿔줍니다. 아주 유용하죠.
>
>     ```js
>     let num = Number("123"); // 문자열을 숫자로 바꿔줌
>     ```



> **`null/undefined`는 메서드가 없습니다.**
>
> - 특수 자료형인 `null`과 `undefined`의 원시값(`null/undefined`)은 위와 같은 법칙을 따르지 않습니다. 
> - 이 자료형과 연관되는 "래퍼 객체"도 없고, 메서드도 제공하지 않습니다. 
>   - 어떤 의미에서는 두 자료형이 "가장 원시적"이라 할 수 있을 것 같습니다.
>
> 
>
> - 두 자료형에 속한 값의 프로퍼티에 접근하려 하면 에러가 발생합니다.
>
>   ```js
>   alert(null.test); // error
>   ```



### 요약

- 'null’과 'undefined’를 제외한 원시값에 다양한 메서드를 호출할 수 있습니다. 이에 대해선 별도의 챕터에서 곧 알아보도록 하겠습니다.
- 원시값에 메서드를 호출하려 하면 임시 객체가 만들어집니다. 그런데 자바스크립트 엔진은 내부 최적화가 잘 되어있어 메서드를 호출해도 많은 리소스를 쓰지 않습니다.





## 5.2 숫자형

> https://ko.javascript.info/number



**도입**

- 모던 자바스크립트는 숫자를 나타내는 두 가지 자료형을 지원합니다.
  1. 일반적인 숫자는 '배정밀도 부동소수점 숫자(double precision floating point number)'로 알려진 64비트 형식의 [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision)에 저장됩니다. 튜토리얼 전체에서 이 형식을 사용하여 숫자를 표현할 예정입니다.
  2. 임의의 길이를 가진 정수는 BigInt 숫자로 나타낼 수 있습니다. 일반적인 숫자는 `2^53`이상이거나 `-2^53`이하일 수 없다는 제약 때문에 BigInt라는 새로운 자료형이 만들어졌습니다. BigInt는 아주 특별한 경우에만 사용되므로, 별도의 챕터 [BigInt](https://ko.javascript.info/bigint)에서 자세한 내용을 다루겠습니다.

- 자, 그럼 일반적인 숫자에 대해서 자세히 알아봅시다.



### 숫자를 입력하는 다양한 방법

- 10억을 입력해야 한다고 상상해 봅니다. 가장 분명한 방법은 아래와 같이 직접 10억(one billion)을 써주는 것입니다.

  ```js
  let billion = 1000000000;
  ```

- 그런데 이렇게 0을 많이 사용해 숫자를 표현하다 보면 잘못 입력하기 쉽기 때문에, 실제로는 이런 방법을 잘 사용하지 않습니다. 

  - 0을 많이 입력하는 게 귀찮기도 하지요. 
  - 그래서 대개는 10억(`billion`)을 나타낼 땐 `'1bn'`을 사용하고, 73억을 나타낼 땐 `'7.3bn'`을 사용합니다. 
  - 큰 숫자를 나타낼 땐 이런 방법이 주로 사용되죠.

- 자바스크립트에서도 숫자 옆에 `'e'`를 붙이고 0의 개수를 그 옆에 붙여주면 숫자를 줄일 수 있습니다.

  ```js
  let billion = 1e9;  // 10억, 1과 9개의 0
  alert( 7.3e9 );  // 73억 (7,300,000,000)
  ```

- 즉, `'e'`는 e 왼쪽의 수에 e 오른쪽에 있는 수만큼의 10의 거듭제곱을 곱하는 효과가 있습니다.

  ```js
  1e3 = 1 * 1000
  1.23e6 = 1.23 * 1000000
  ```

- 이제 아주 작은 숫자인 1마이크로초(백만 분의 1초)를 표현해보겠습니다.

  ```js
  let ms = 0.000001;
  ```

- 작은 숫자를 표현할 때도 큰 숫자를 표현할 때처럼 `'e'`를 사용할 수 있습니다. 0을 명시적으로 쓰고 싶지 않다면 다음과 같이 숫자를 표현할 수 있죠.

  ```js
  let ms = 1e-6; // 1에서 왼쪽으로 6번 소수점 이동
  ```

  - `0.000001`에서 0의 개수를 세면 6이므로 `0.000001`은 당연히 `1e-6`이 되죠.

- 이렇게 `'e'` 우측에 음수가 있으면, 이 음수의 절댓값 만큼 10을 거듭제곱한 수로 나누는 것을 의미합니다.

  ```js
  // 10을 세 번 거듭제곱한 수로 나눔
  1e-3 = 1 / 1000 (=0.001)
  
  // 10을 여섯 번 거듭제곱한 수로 나눔
  1.23e-6 = 1.23 / 1000000 (=0.00000123)
  ```



### 16진수, 2진수, 8진수

- [16진수](https://en.wikipedia.org/wiki/Hexadecimal)는 색을 나타내거나 문자를 인코딩할 때 등 다양한 곳에서 두루 쓰입니다. 

  - 다양한 곳에서 쓰이는 만큼 당연히 16진수를 짧게 표현하는 방법도 존재하겠죠. 

  - 16진수는 `0x`를 사용해 표현할 수 있습니다.

    ```js
    alert( 0xff ); // 255
    alert( 0xFF ); // 255 (대·소문자를 가리지 않으므로 둘 다 같은 값을 나타냅니다.)
    ```

- 2진수와 8진수는 아주 드물게 쓰이긴 하지만, 접두사 `0b`와 `0o`를 사용해 간단히 나타낼 수 있습니다.

  ```js
  let a = 0b11111111; // 255의 2진수
  let b = 0o377; // 255의 8진수
  
  alert( a == b ); // true, 진법은 다르지만, a와 b는 같은 수임
  ```

- 자바스크립트에서 지원하는 진법은 3개입니다. 

  - 이 외의 진법을 사용하려면 함수 `parseInt`를 사용해야 합니다(챕터 후반부에서 다룸).



### toString(base)

- `num.toString(base)` 메서드는 `base`진법으로 `num`을 표현한 후, 이를 문자형으로 변환해 반환합니다.

  ```js
  let num = 255;
  
  alert( num.toString(16) );  // ff
  alert( num.toString(2) );   // 11111111
  ```

- `base`는 `2`에서 `36`까지 쓸 수 있는데, 기본값은 `10`입니다.

- `base`별 유스 케이스는 다음과 같습니다.

  - **base=16** – 16진수 색, 문자 인코딩 등을 표현할 때 사용합니다. 숫자는 `0`부터 `9`, 10 이상의 수는 `A`부터 `F`를 사용하여 나타냅니다.

  - **base=2** – 비트 연산 디버깅에 주로 쓰입니다. 숫자는 `0` 또는 `1`이 될 수 있습니다.

  - **base=36** – 사용할 수 있는 `base` 중 최댓값으로, `0..9`와 `A..Z`를 사용해 숫자를 표현합니다. 알파벳 전체가 숫자를 나타내는 데 사용되죠. `36` 베이스는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용합니다. 예시를 살펴봅시다.

    ```js
    alert( 123456..toString(36) ); // 2n9c
    ```



> **점 두 개와 메서드 호출**
>
> - `123456..toString(36)`에 있는 점 두 개는 오타가 아닙니다. 
>   - 위 예시처럼 숫자를 대상으로 메서드 `toString`을 직접 호출하고 싶다면 숫자 다음에 점 두 개 `..`를 붙여야 합니다.
> - `123456.toString(36)`처럼 점을 한 개만 사용하면, 첫 번째 점 이후는 소수부로 인식되어 에러가 발생할 수 있습니다. 
>   - 점을 하나 더 추가하면 자바스크립트는 소수부가 없다고 판단하고 함수를 호출합니다.
> - `(123456).toString(36)`도 가능합니다.



### 어림수 구하기

- 어림수를 구하는 것(rounding)은 숫자를 다룰 때 가장 많이 사용되는 연산 중 하나입니다.

- 어림수 관련 내장 함수 몇 가지를 살펴봅시다.

  - `Math.floor`

    소수점 첫째 자리에서 내림(버림). `3.1`은 `3`, `-1.1`은 `-2`가 됩니다.

  - `Math.ceil`

    소수점 첫째 자리에서 올림. `3.1`은 `4`, `-1.1`은 `-1`이 됩니다.

  - `Math.round`

    소수점 첫째 자리에서 반올림. `3.1`은 `3`, `3.6`은 `4`, `-1.1`은 `-1`이 됩니다.

  - `Math.trunc` (Internet Explorer에서는 지원하지 않음)

    소수부를 무시. `3.1`은 `3`이 되고 `-1.1`은 `-1`이 됩니다.

- 각 내장 함수의 차이를 표로 나타내면 다음과 같습니다.

  |        | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |
  | :----- | :----------- | :---------- | :----------- | :----------- |
  | `3.1`  | `3`          | `4`         | `3`          | `3`          |
  | `3.6`  | `3`          | `4`         | `4`          | `3`          |
  | `-1.1` | `-2`         | `-1`        | `-1`         | `-1`         |
  | `-1.6` | `-2`         | `-1`        | `-2`         | `-1`         |

- 위에서 소개한 내장 함수들만으로도 소수부에 관련된 연산 대부분을 처리할 수 있습니다. 

- 그런데 소수점 `n-th`번째 수를 기준으로 어림수를 구해야 하는 상황이라면 어떻게 해야 할까요?

  - 예를 들어 `1.2345`가 있는데 소수점 두 번째 자릿수까지만 남겨 `1.23`을 만들고 싶은 경우처럼 말이죠.

  - 두 가지 방법이 있습니다.

    1. 곱하기와 나누기

    - 소수점 두 번째 자리 숫자까지만 남기고 싶은 경우, 숫자에 `100` 또는 `100`보다 큰 `10`의 거듭제곱 수를 곱한 후, 원하는 어림수 내장 함수를 호출하고 처음 곱한 수를 다시 나누면 됩니다.

      ```js
      let num = 1.23456;
      
      alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
      ```

    2. 소수점 `n` 번째 수까지의 어림수를 구한 후 이를 문자형으로 반환해주는 메서드인 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)를 사용합니다.

       ```js
       let num = 12.34;
       alert( num.toFixed(1) ); // "12.3"
       ```

       `toFixed`는 `Math.round`와 유사하게 가장 가까운 값으로 올림 혹은 버림해줍니다.

       ```js
       let num = 12.36;
       alert( num.toFixed(1) ); // "12.4"
       ```

       `toFixed`를 사용할 때 주의할 점은 이 메서드의 반환 값이 문자열이라는 것입니다. 소수부의 길이가 인수보다 작으면 끝에 0이 추가됩니다.

       ```js
       let num = 12.34;
       alert( num.toFixed(5) ); // "12.34000", 소수부의 길이를 5로 만들기 위해 0이 추가되었습니다.
       ```

       참고로, `+num.toFixed(5)`처럼 단항 덧셈 연산자를 앞에 붙이거나 `Number()`를 호출하면 문자형의 숫자를 숫자형으로 변환할 수 있습니다.

    

### 부정확한 계산

- 숫자는 내부적으로 64비트 형식 [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision)으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요합니다. 

  - 64비트 중 52비트는 숫자를 저장하는 데 사용되고, 
  - 11비트는 소수점 위치를(정수는 0), 
  - 1비트는 부호를 저장하는 데 사용됩니다.

- 그런데 숫자가 너무 커지면 64비트 공간이 넘쳐서 Infinity로 처리됩니다.

  ```js
  alert( 1e500 ); // Infinity
  ```

- 원인을 이해하려면 집중이 필요하긴 하지만, 꽤 자주 발생하는 현상인 정밀도 손실(loss of precision)도 있습니다.

  ```js
  alert( 0.1 + 0.2 == 0.3 ); // false
  ```

  - `0.1`과 `0.2`의 합이 `0.3`과 일치하는지 확인 했는데 `false`가 출력되었습니다.

  - 이상하네요! 합의 결과가 `0.3`이 아니라면 대체 무엇일까요?

    ```js
    alert( 0.1 + 0.2 ); // 0.30000000000000004
    ```

- 왜 이런 일이 발생할까요?

  - 숫자는 0과 1로 이루어진 이진수로 변환되어 연속된 메모리 공간에 저장됩니다. 
  - 그런데 10진법을 사용하면 쉽게 표현할 수 있는 `0.1`, `0.2` 같은 분수는 이진법으로 표현하면 무한 소수가 됩니다.
    - `0.1`은 1을 10으로 나눈 수인 `1/10`입니다. 10진법을 사용하면 이러한 숫자를 쉽게 표현할 수 있죠. 
    - `1/10`과 `1/3`을 비교해봅시다. `1/3`은 무한 소수 `0.33333(3)`이 됩니다.
  - 이렇게 `10`의 거듭제곱으로 나눈 값은 10진법에서 잘 동작하지만 `3`으로 나누게 되면 10진법에서 제대로 동작하지 않습니다. 
  - 같은 이유로 2진법 체계에서 `2`의 거듭제곱으로 나눈 값은 잘 동작하지만 `1/10`같이 `2`의 거듭제곱이 아닌 값으로 나누게 되면 무한 소수가 되어버립니다.
  - 10진법에서 1/3을 정확히 나타낼 수 없듯이, 2진법을 사용해 *0.1* 또는 *0.2*를 **정확하게** 저장하는 방법은 없습니다.

- IEEE-754에선 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 이런 문제를 해결합니다.

  - 그런데 반올림 규칙을 적용하면 발생하는 '작은 정밀도 손실’을 우리가 볼 수는 없지만 실제로 손실은 발생합니다.

  - 아래와 같이 코드를 작성하면 정밀도 손실을 눈으로 확인할 수 있죠.

    ```js
    alert( 0.1.toFixed(20) ); // 0.10000000000000000555
    ```

  - 그리고 두 숫자를 합하면 '정밀도 손실’도 더해집니다.

    - `0.1 + 0.2`가 정확히 `0.3`이 아닌 이유가 여기에 있습니다.

- 문제를 해결하는 방법은 없을까요? 물론 있습니다. 

  - 가장 신뢰할만한 방법은 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)메서드를 사용해 어림수를 만드는 것입니다.

    ```js
    let sum = 0.1 + 0.2;
    alert( sum.toFixed(2) ); // 0.30
    ```

  - 이때 `toFixed`는 항상 문자열을 반환한다는 점에 유의해야 합니다. 

    - 문자열을 반환하기 때문에 소수점 다음에 오는 숫자가 항상 2개가 될 수 있습니다. 
    - 인터넷 쇼핑몰을 구축 중이고 `$0.30`를 보여줘야 할 때 유용하죠. 

  - 문자형으로 바뀐 숫자를 다시 숫자형으로 강제 변환하려면 단항 덧셈 연산자를 사용하면 됩니다.

    ```js
    let sum = 0.1 + 0.2;
    alert( +sum.toFixed(2) ); // 0.3
    ```

  - 숫자에 임시로 100(또는 더 큰 숫자)을 곱하여 정수로 바꾸고, 원하는 연산을 한 후 다시 100으로 나누는 것도 하나의 방법이 될 수 있습니다.

    - 정수를 대상으로 하는 수학 연산은 소수를 대상으로 하는 연산보다 에러가 적기 때문입니다. 

    - 그런데 어쨌든 마지막에 나눗셈이 들어가기 때문에 소수가 다시 등장할 수 있다는 단점이 있습니다.

      ```js
      alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
      alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
      ```

    - 이렇게 10의 거듭제곱을 곱하고 다시 동일한 숫자로 나누는 전략은 오류를 줄여주긴 하지만 완전히 없애지는 못합니다.

- 구현을 하다 보면 무한 소수가 나오는 경우를 완전히 차단해야 하는 경우가 생기곤 합니다. 

  - 달러가 아닌 센트 단위로 물품 가격을 저장하는 쇼핑몰을 담당하고 있는데, 행사 때문에 가격을 30% 할인해야 하는 경우가 그렇죠. 

- **<u>무한소수를 방지하는 완벽한 방법은 사실 없습니다.</u>** 

  - 필요할 때마다 '꼬리’를 잘라 어림수를 만드는 방법뿐이죠.



> **흥미로운 발견**
>
> - 아래 예시를 실행해보세요.
>
> ```javascript
> // 숫자가 스스로 증가하네요!
> alert( 9999999999999999 ); // 10000000000000000이 출력됩니다.
> ```
>
> - 문제의 원인은 역시나 정밀도 손실 때문입니다. 
>   - 숫자를 저장할 땐 64비트가 사용되는데, 이 중 실제 숫자를 저장하는 데 사용되는 52비트에 위 숫자를 저장하기엔 공간이 모자랍니다. 
>   - 따라서 최소 유효 숫자(the least significant digit)가 손실되어 버렸습니다.
>
> - 자바스크립트는 숫자 손실이 일어나도 오류를 발생시키지 않습니다. 
>   - 적절한 포맷으로 숫자를 맞추는 데 최선을 다하긴 하지만 유감스럽게도 위 예시의 숫자를 담기엔 포맷이 충분하지 않네요.



> **두 종류의 0**
>
> - 자바스크립트 내부에서 숫자를 표현하는 방식 때문에 발생하는 또 다른 흥미로운 현상은 `0`과 `-0`이라는 두 종류의 0이 존재한다는 사실입니다.
> - 자바스크립트에선 숫자의 부호가 단일 비트에 저장되는데 0을 포함한 모든 숫자에 부호를 설정할 수도, 설정하지 않을 수도 있기 때문입니다.
> - 대부분의 연산은 `0`과 `-0`을 동일하게 취급하기 때문에 두 0의 차이는 두드러지지 않는 편입니다.



### isNaN과 isFinite

- 아래 두 특수 숫자 값이 기억나시나요?

  - `Infinity`와 `-Infinity`: 그 어떤 숫자보다 큰 혹은 작은 특수 숫자 값
  - `NaN`: 에러를 나타내는 값

- 두 특수 숫자는 `숫자형`에 속하지만 ‘정상적인’ 숫자는 아니기 때문에, 정상적인 숫자와 구분하기 위한 특별한 함수가 존재합니다.

  - `isNaN(value)` – 인수를 숫자로 변환한 다음 `NaN`인지 테스트함

    ```js
    alert( isNaN(NaN) ); // true
    alert( isNaN("str") ); // true
    ```

  - 그런데 굳이 이 함수가 필요할까요? "`=== NaN` 비교를 하면 되지 않을까?"라는 생각이 들 수 있습니다. 

    - 안타깝게도 대답은 '필요하다’입니다. 

    - **<u>`NaN`은 `NaN` 자기 자신을 포함하여 그 어떤 값과도 같지 않다</u>**는 점에서 독특합니다.

      ```js
      alert( NaN === NaN ); // false
      ```

  - `isFinite(value)` - 인수를 숫자로 변환하고 변환한 숫자가 `NaN/Infinity/-Infinity`가 아닌 일반 숫자인 경우 `true`를 반환함

    ```js
    alert( isFinite("15") ); // true
    alert( isFinite("str") ); // false, NaN이기 때문입니다.
    alert( isFinite(Infinity) ); // false, Infinity이기 때문입니다.
    ```

  - `isFinite`는 문자열이 일반 숫자인지 검증하는 데 사용되곤 합니다.

    ```js
    let num = +prompt("숫자를 입력하세요.", '');
    
    // 숫자가 아닌 값을 입력하거나 Infinity, -Infinity를 입력하면 false가 출력됩니다.
    alert( isFinite(num) );
    ```

  - <u>빈 문자열이나 공백만 있는 문자열은 `isFinite`를 포함한 모든 숫자 관련 내장 함수에서 `0`으로 취급</u>된다는 점에 유의하시기 바랍니다.



> **`Object.is`와 비교하기**
>
> [`Object.is`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/is)는 `===`처럼 값을 비교할 때 사용되는 특별한 내장 메서드인데, 아래와 같은 두 가지 에지 케이스에선 `===`보다 좀 더 신뢰할만한 결과를 보여줍니다.
>
> 1. `NaN`을 대상으로 비교할 때: `Object.is(NaN, NaN) === true`임.
> 2. `0`과 `-0`이 다르게 취급되어야 할 때: `Object.is(0, -0) === false`임. 숫자를 나타내는 비트가 모두 0이더라도 부호를 나타내는 비트는 다르므로 `0`과 `-0`은 사실 다른 값이긴 합니다.
>
> 이 두 에지 케이스를 제외하곤, `Object.is(a, b)`와 `a === b`의 결과는 같습니다.
>
> 이런 식의 비교는 자바스크립트 명세서에서 종종 찾아볼 수 있습니다. 내부 알고리즘에서 두 값을 비교해야 하는데, 비교 결과가 정확해야 하는 경우 `Object.is`를 사용하죠. `Object.is`에서 사용되는 비교방식은 명세서에서 [SameValue](https://tc39.github.io/ecma262/#sec-samevalue)라고 불립니다.



### parseInt와 parseFloat

- 단항 덧셈 연산자 `+` 또는 `Number()`를 사용하여 숫자형으로 변형할 때 적용되는 규칙은 꽤 엄격합니다. 

  - 피연산자가 숫자가 아니면 형 변환이 실패합니다.

    ```js
    alert( +"100px" ); // NaN
    ```

  - 엄격한 규칙이 적용되지 않는 유일한 예외는 문자열의 처음 또는 끝에 공백이 있어서 공백을 무시할 때입니다.

- 그런데 실무에선 CSS 등에서 `'100px'`, `'12pt'`와 같이 숫자와 단위를 함께 쓰는 경우가 흔합니다. 

  - 대다수 국가에서 `'19€'`처럼 금액 뒤에 통화 기호를 붙여 표시하기도 하죠. 숫자만 추출하는 방법이 필요해 보이네요.
  - 내장 함수 `parseInt`와 `parseFloat`는 이런 경우를 위해 만들어졌습니다.

- 두 함수는 불가능할 때까지 문자열에서 숫자를 ‘읽습니다’. 

  - 숫자를 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반환하죠. 

  - `parseInt`는 정수, `parseFloat`는 부동 소수점 숫자를 반환합니다.

    ```js
    alert( parseInt('100px') ); // 100
    alert( parseFloat('12.5em') ); // 12.5
    
    alert( parseInt('12.3') ); // 12, 정수 부분만 반환됩니다.
    alert( parseFloat('12.3.4') ); // 12.3, 두 번째 점에서 숫자 읽기를 멈춥니다.
    ```

- `parseInt`와 `parseFloat`가 `NaN`을 반환할 때도 있습니다. 읽을 수 있는 숫자가 없을 때 그렇죠.

  ```js
  alert( parseInt('a123') ); // NaN, a는 숫자가 아니므로 숫자를 읽는 게 중지됩니다.
  ```

  

> **`parseInt(str, radix)`의 두 번째 인수**
>
> - `parseInt()`의 두 번째 매개 변수는 선택적으로 사용할 수 있습니다. 
> - `radix`는 원하는 진수를 지정해 줄 때 사용합니다. 
>   - 따라서 `parseInt`를 사용하면 16진수 문자열, 2진수 문자열 등을 파싱할 수 있습니다.
>
> ```javascript
> alert( parseInt('0xff', 16) ); // 255
> alert( parseInt('ff', 16) ); // 255, 0x가 없어도 동작합니다.
> alert( parseInt('2n9c', 36) ); // 123456
> ```



### 기타 수학 함수

- 자바스크립트에서 제공하는 내장 객체 [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math)엔 다양한 수학 관련 함수와 상수들이 들어있습니다.

- 몇 가지 예시를 살펴봅시다.

  - `Math.random()`

    - 0과 1 사이의 난수를 반환합니다(1은 제외).

      ```js
      alert( Math.random() ); // 0.1234567894322
      alert( Math.random() ); // 0.5435252343232
      alert( Math.random() ); // ... (무작위 수)
      ```

  - `Math.max(a, b, c...)` / `Math.min(a, b, c...)`

    - 인수 중 최대/최솟값을 반환합니다.

      ```js
      alert( Math.max(3, 5, -10, 0, 1) ); // 5
      alert( Math.min(1, 2) ); // 1
      ```

  - `Math.pow(n, power)`

    - `n`을 power번 거듭제곱한 값을 반환합니다.

      ```js
      alert( Math.pow(2, 10) ); // 2의 10제곱 = 1024
      ```

  - 이 외에도 삼각법을 포함한 다양한 함수와 상수가 `Math`에 있습니다. 자세한 내용은 [MDN 문서](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math)에서 읽어보시기 바랍니다.



### 요약

0이 많이 붙은 큰 숫자는 다음과 같은 방법을 사용해 씁니다.

- 0의 개수를 `'e'` 뒤에 추가합니다. `123e6`은 0이 6개인 숫자, `123000000`을 나타냅니다.
- `'e'` 다음에 음수가 오면, 음수의 절댓값 만큼 10을 거듭제곱한 숫자로 주어진 숫자를 나눕니다. `123e-6`은 `0.000123`을 나타냅니다.

다양한 진법을 사용할 수도 있습니다.

- 자바스크립트는 특별한 변환 없이 16진수(`0x`), 8진수(`0o`), 2진수(`0b`)를 바로 사용할 수 있게 지원합니다.
- `parseInt(str, base)`를 사용하면 `str`을 `base`진수로 바꿔줍니다(단, `2 ≤ base ≤ 36`).
- `num.toString(base)`는 숫자를 `base`진수로 바꾸고, 이를 문자열 형태로 반환합니다.

`12pt`나 `100px`과 같은 값을 숫자로 변환하는 것도 가능합니다.

- `parseInt/parseFloat`를 사용하면 문자열에서 숫자만 읽고, 읽은 숫자를 에러가 발생하기 전에 반환해주는 ‘약한’ 형 변환을 사용할 수 있습니다.

소수를 처리하는 데 쓰이는 메서드는 다음과 같습니다.

- `Math.floor`, `Math.ceil`, `Math.trunc`, `Math.round`, `num.toFixed(precision)`를 사용하면 어림수를 구할 수 있습니다.
- 소수를 다룰 땐 정밀도 손실에 주의하세요.

이 외에도 다양한 수학 함수가 있습니다.

- 수학 연산이 필요할 때 [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) 객체를 찾아보세요. 작은 객체이지만 기본적인 연산은 대부분 다룰 수 있습니다.





## 5.3 문자열 

> https://ko.javascript.info/string

**도입**

- 자바스크립트엔 글자 하나만 저장할 수 있는 별도의 자료형이 없습니다. 
  - 텍스트 형식의 데이터는 길이에 상관없이 문자열 형태로 저장됩니다.
- 자바스크립트에서 문자열은 페이지 인코딩 방식과 상관없이 항상 [UTF-16](https://en.wikipedia.org/wiki/UTF-16) 형식을 따릅니다.



### 따옴표

- 따옴표의 종류가 무엇이 있었는지 상기해봅시다.

- 문자열은 작은따옴표나 큰따옴표, 백틱으로 감쌀 수 있습니다.

  ```js
  let single = '작은따옴표';
  let double = "큰따옴표";
  let backticks = `백틱`;
  ```

- 작은따옴표와 큰따옴표는 기능상 차이가 없습니다. 

- 그런데 백틱엔 특별한 기능이 있습니다. 

  - 표현식을 `${…}`로 감싸고 이를 백틱으로 감싼 문자열 중간에 넣어주면 해당 표현식을 문자열 중간에 쉽게 삽입할 수 있죠. 

  - 이런 방식을 **<u>템플릿 리터럴(template literal)</u>**이라고 부릅니다.

    ```js
    function sum(a, b) {
      return a + b;
    }
    
    alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
    ```

  - 백틱을 사용하면 문자열을 여러 줄에 걸쳐 작성할 수도 있습니다.

    ```js
    let guestList = `손님:
     * John
     * Pete
     * Mary
    `;
    
    alert(guestList); // 손님 리스트를 여러 줄에 걸쳐 작성함
    ```

    - 자연스럽게 여러 줄의 문자열이 만들어졌네요. 작은따옴표나 큰따옴표를 사용하면 위와 같은 방식으로 여러 줄짜리 문자열을 만들 수 없습니다.

  - 아래 예시를 실행해봅시다. 에러가 발생합니다.

    ```js
    let guestList = "손님: // Error: Invalid or unexpected token
      * John";
    ```

    - 작은따옴표나 큰따옴표로 문자열을 표현하는 방식은 자바스크립트가 만들어졌을 때부터 있었습니다. 
    - 이때는 문자열을 여러 줄에 걸쳐 작성할 생각조차 못 했던 시기였죠. 
    - 백틱은 그 이후에 등장한 문법이기 때문에 따옴표보다 다양한 기능을 제공합니다.

- 백틱은 '템플릿 함수(template function)'에서도 사용됩니다. 

  - func \`string\` 같이 첫 번째 백틱 바로 앞에 함수 이름(`func`)을 써주면, 
  - 이 함수는 백틱 안의 문자열 조각이나 표현식 평가 결과를 인수로 받아 자동으로 호출됩니다. 
  - 이런 기능을 **'태그드 템플릿(tagged template)**'이라 부르는데, 태그드 템플릿을 사용하면 사용자 지정 템플릿에 맞는 문자열을 쉽게 만들 수 있습니다. 
  - 태그드 템플릿과 템플릿 함수에 대한 자세한 내용은 MDN [문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates)에서 확인해보세요. 참고로 이 기능은 자주 사용되진 않습니다.



### 특수 기호

- '줄 바꿈 문자(newline character)'라 불리는 특수기호 `\n`을 사용하면 작은따옴표나 큰따옴표로도 여러 줄 문자열을 만들 수 있습니다.

  ```js
  let guestList = "손님:\n * John\n * Pete\n * Mary";
  alert(guestList); // 손님 리스트를 여러 줄에 걸쳐 작성함
  ```

- 따옴표를 이용해 만든 여러 줄 문자열과 백틱을 이용해 만든 여러 줄 문자열은 표현 방식만 다를 뿐 차이가 없습니다.

  ```js
  let str1 = "Hello\nWorld"; // '줄 바꿈 기호'를 사용해 두 줄짜리 문자열을 만듦
  
  // 백틱과 일반적인 줄 바꿈 방법(엔터)을 사용해 두 줄짜리 문자열을 만듦
  let str2 = `Hello
  World`;
  
  alert(str1 == str2); // true
  ```

- 자바스크립트엔 줄 바꿈 문자를 비롯한 다양한 ‘특수’ 문자들이 있습니다.

  특수 문자 목록:

  | 특수 문자                                            | 설명                                                         |
  | :--------------------------------------------------- | :----------------------------------------------------------- |
  | `\n`                                                 | 줄 바꿈                                                      |
  | `\r`                                                 | 캐리지 리턴(carriage return). Windows에선 캐리지 리턴과 줄 바꿈 특수 문자를 조합(`\r\n`)해 줄을 바꿉니다. 캐리지 리턴을 단독으론 사용하는 경우는 없습니다. |
  | `\'`, `\"`                                           | 따옴표                                                       |
  | `\\`                                                 | 역슬래시                                                     |
  | `\t`                                                 | 탭                                                           |
  | `\b`, `\f`, `\v`                                     | 각각 백스페이스(Backspace), 폼 피드(Form Feed), 세로 탭(Vertical Tab)을 나타냅니다. 호환성 유지를 위해 남아있는 기호로 요즘엔 사용하지 않습니다. |
  | `\xXX`                                               | 16진수 유니코드 `XX`로 표현한 유니코드 글자입니다(예시: 알파벳 `'z'`는 `'\x7A'`와 동일함). |
  | `\uXXXX`                                             | UTF-16 인코딩 규칙을 사용하는 16진수 코드 `XXXX`로 표현한 유니코드 기호입니다. `XXXX`는 반드시 네 개의 16진수로 구성되어야 합니다(예시: `\u00A9`는 저작권 기호 `©`의 유니코드임). |
  | `\u{X…XXXXXX}`(한 개에서 여섯 개 사이의 16진수 글자) | UTF-32로 표현한 유니코드 기호입니다. 몇몇 특수한 글자는 두 개의 유니코드 기호를 사용해 인코딩되므로 4바이트를 차지합니다. 이 방법을 사용하면 긴 코드를 삽입할 수 있습니다. |

- 유니코드를 사용한 예시:

  ```js
  alert( "\u00A9" ); // ©
  alert( "\u{20331}" ); // 佫, 중국어(긴 유니코드)
  alert( "\u{1F60D}" ); // 😍, 웃는 얼굴 기호(긴 유니코드)
  ```

- 모든 특수 문자는 '이스케이프 문자(escape character)'라고도 불리는 역슬래시 (backslash character) `\`로 시작합니다.

  - 역슬래시는 문자열 내에 따옴표를 넣을 때도 사용할 수 있습니다.

    ```js
    alert( 'I\'m the Walrus!' ); // I'm the Walrus!
    ```

  - 위 예시에서 살펴본 바와 같이 문자열 내의 따옴표엔 `\`를 꼭 붙여줘야 합니다. 이렇게 하지 않으면 자바스크립트는 해당 따옴표가 문자열을 닫는 용도로 사용된 것이라 해석하기 때문입니다.

- 이스케이프 문자는 문자열을 감쌀 때 사용한 따옴표와 동일한 따옴표에만 붙여주면 됩니다. 문자열 내에서 좀 더 우아하게 따옴표를 사용하려면 아래와 같이 따옴표 대신 백틱으로 문자열을 감싸주면 됩니다.

  ```js
  alert( `I'm the Walrus!` ); // I'm the Walrus!
  ```



### 문자열의 길이

- `length` 프로퍼티엔 문자열의 길이가 저장됩니다.

  ```js
  alert( `My\n`.length ); // 3
  ```

  - `\n`은 ‘특수 문자’ 하나로 취급되기 때문에 `My\n`의 길이는 `3`입니다.



> **`length`는 프로퍼티입니다.**
>
> - 자바스크립트 이외의 언어를 사용했던 개발자들은 `str.length`가 아닌 `str.length()`로 문자열의 길이를 알아내려고 하는 경우가 있습니다. 
>   - 하지만 원하는 대로 동작하지 않습니다.
> - `length`는 함수가 아니고, 숫자가 저장되는 프로퍼티라는 점에 주의하시기 바랍니다. 
>   - 뒤에 괄호를 붙일 필요가 없습니다.



### 특정 글자에 접근하기

- 문자열 내 특정 위치인 `pos`에 있는 글자에 접근

  - `[pos]`같이 대괄호를 이용하거나
  -  [str.charAt(pos)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/charAt)라는 메서드를 호출하면 됩니다. 
  - 위치는 0부터 시작합니다.

  ```js
  let str = `Hello`;
  
  // 첫 번째 글자
  alert( str[0] ); // H
  alert( str.charAt(0) ); // H
  
  // 마지막 글자
  alert( str[str.length - 1] ); // o
  ```

- 근래에는 대괄호를 이용하는 방식을 사용합니다. 

- `charAt`은 하위 호환성을 위해 남아있는 메서드라고 생각하시면 됩니다.

  - 두 접근 방식의 차이는 반환할 글자가 없을 때 드러납니다. 

  - 접근하려는 위치에 글자가 없는 경우 `[]`는 `undefined`를, `charAt`은 빈 문자열을 반환합니다.

    ```js
    let str = `Hello`;
    
    alert( str[1000] ); // undefined
    alert( str.charAt(1000) ); // '' (빈 문자열)
    ```

- `for..of`를 사용하면 문자열을 구성하는 글자를 대상으로 반복 작업을 할 수 있습니다.

  ```js
  for (let char of "Hello") {
    alert(char); // H,e,l,l,o (char는 순차적으로 H, e, l, l, o가 됩니다.)
  }
  ```

  

### 문자열의 불변성

- 문자열은 수정할 수 없습니다. 

  - 따라서 문자열의 중간 글자 하나를 바꾸려고 하면 에러가 발생합니다.

    ```js
    let str = 'Hi';
    
    str[0] = 'h'; // Error: Cannot assign to read only property '0' of string 'Hi'
    alert( str[0] ); // 동작하지 않습니다.
    ```

  - 이런 문제를 피하려면 완전히 새로운 문자열을 하나 만든 다음, 이 문자열을 `str`에 할당하면 됩니다.

    ```js
    let str = 'Hi';
    str = 'h' + str[1]; // 문자열 전체를 교체함
    alert( str ); // hi
    ```

    

### 대·소문자 변경하기

- 메서드 [toLowerCase()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase)와 [toUpperCase()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase)는 대문자를 소문자로, 소문자를 대문자로 변경(케이스 변경)시켜줍니다.

  ```js
  alert( 'Interface'.toUpperCase() ); // INTERFACE
  alert( 'Interface'.toLowerCase() ); // interface
  ```

- 글자 하나의 케이스만 변경하는 것도 가능합니다.

  ```js
  alert( 'Interface'[0].toLowerCase() ); // 'i'
  ```



### 부분 문자열 찾기

- 문자열에서 부분 문자열(substring)을 찾는 방법은 여러 가지가 있습니다.

  

1. `str.indexOf`

   - 첫 번째 방법은 [str.indexOf(substr, pos)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf) 메서드를 이용하는 것입니다.

   - 이 메서드는 문자열 `str`의 `pos`에서부터 시작해, 부분 문자열 `substr`이 어디에 위치하는지를 찾아줍니다. 

     - 원하는 부분 문자열을 찾으면 위치를 반환하고 그렇지 않으면 `-1`을 반환합니다.

   - 예시

     ```javascript
     let str = 'Widget with id';
     
     alert( str.indexOf('Widget') ); // 0, str은 'Widget'으로 시작함
     alert( str.indexOf('widget') ); // -1, indexOf는 대·소문자를 따지므로 원하는 문자열을 찾지 못함
     
     alert( str.indexOf("id") ); // 1, "id"는 첫 번째 위치에서 발견됨 (Widget에서 id)
     ```

   - `str.indexOf(substr, pos)`의 두 번째 매개변수 `pos`는 선택적으로 사용할 수 있는데, 이를 명시하면 검색이 해당 위치부터 시작됩니다.

     - 부분 문자열 `"id"`는 위치 `1`에서 처음 등장하는데, 두 번째 인수에 `2`를 넘겨 `"id"`가 두 번째로 등장하는 위치가 어디인지 알아봅시다.

     ```js
     let str = 'Widget with id';
     alert( str.indexOf('id', 2) ) // 12
     ```

   - 문자열 내 부분 문자열 전체를 대상으로 무언가를 하고 싶다면 반복문 안에 `indexOf`를 사용하면 됩니다. 

     - 반복문이 하나씩 돌 때마다 검색 시작 위치가 갱신되면서 `indexOf`가 새롭게 호출됩니다.

     ```js
     let str = 'As sly as a fox, as strong as an ox';
     
     let target = 'as'; // as를 찾아봅시다.
     
     let pos = 0;
     while (true) {
       let foundPos = str.indexOf(target, pos);
       if (foundPos == -1) break;
     
       alert( `위치: ${foundPos}` );
       pos = foundPos + 1; // 다음 위치를 기준으로 검색을 이어갑니다.
     }
     ```



> **`str.lastIndexOf(substr, position)`**
>
> - [str.lastIndexOf(substr, position)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf)는 `indexOf`와 유사한 기능을 하는 메서드입니다. 
>   - 문자열 끝에서부터 부분 문자열을 찾는다는 점만 다릅니다.
> - 반환되는 부분 문자열 위치는 문자열 끝이 기준입니다.



- `if`문의 조건식에 `indexOf`를 쓸 때 주의할 점이 하나 있습니다. 

  - 아래와 같이 코드들 작성하면 원하는 결과를 얻을 수 없습니다.

  ```js
  let str = "Widget with id";
  
  if (str.indexOf("Widget")) {
      alert("찾았다!"); // 의도한 대로 동작하지 않습니다.
  }
  ```

  - `str.indexOf("Widget")`은 `0`을 반환하는데, `if`문에선 `0`을 `false`로 간주하므로 `alert` 창이 뜨지 않습니다.
  - 따라서 **<u>부분 문자열 여부를 검사하려면 아래와 같이 `-1`과 비교해야 합니다.</u>**

  ```js
  let str = "Widget with id";
  
  if (str.indexOf("Widget") != -1) {
      alert("찾았다!"); // 의도한 대로 동작합니다.
  }
  ```



### includes, startsWith, endsWith

- `includes` 메서드

  - 비교적 근래에 나온 메서드인 [str.includes(substr, pos)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/includes)는 `str`에 부분 문자열 `substr`이 있는지에 따라 `true`나 `false`를 반환합니다.

  - 부분 문자열의 위치 정보는 필요하지 않고 포함 여부만 알고 싶을 때 적합한 메서드입니다.

    ```js
    alert( "Widget with id".includes("Widget") ); // true
    alert( "Hello".includes("Bye") ); // false
    ```

  - `str.includes`에도 `str.indexOf`처럼 두 번째 인수를 넘기면 해당 위치부터 부분 문자열을 검색합니다.

    ```js
    alert( "Widget".includes("id") ); // true
    alert( "Widget".includes("id", 3) ); // false, 세 번째 위치 이후엔 "id"가 없습니다.
    ```

- `startsWith`와 `endsWith` 메서드

  - 메서드 이름 그대로 문자열 `str`이 특정 문자열로 시작하는지(start with) 여부와 특정 문자열로 끝나는지(end with) 여부를 확인할 때 사용할 수 있습니다.

    ```js
    alert( "Widget".startsWith("Wid") ); // true, "Widget"은 "Wid"로 시작합니다.
    alert( "Widget".endsWith("get") ); // true, "Widget"은 "get"으로 끝납니다.
    ```



### 부분 문자열 추출하기

- 자바스크립트엔 부분 문자열 추출과 관련된 메서드가 세 가지 있습니다. 

  - 세 가지 메서드 `substring`, `substr`, `slice`를 하나씩 알아봅시다.

- `str.slice(start [, end])`

  - 문자열의 `start`부터 `end`까지(`end`는 미포함)를 반환합니다.

    ```js
    let str = "stringify";
    alert( str.slice(0, 5) ); // 'strin', 0번째부터 5번째 위치까지(5번째 위치의 글자는 포함하지 않음)
    alert( str.slice(0, 1) ); // 's', 0번째부터 1번째 위치까지(1번째 위치의 자는 포함하지 않음)
    ```

  - 두 번째 인수가 생략된 경우엔, 명시한 위치부터 문자열 끝까지를 반환합니다.

    ```js
    let str = "stringify";
    alert( str.slice(2) ); // ringify, 2번째부터 끝까지
    ```

  - `start`와 `end`는 음수가 될 수도 있습니다. <u>음수를 넘기면 문자열 끝에서부터 카운팅</u>을 시작합니다.

    ```js
    let str = "stringify";
    
    // 끝에서 4번째부터 시작해 끝에서 1번째 위치까지
    alert( str.slice(-4, -1) ); // gif
    ```

- `str.substring(start [, end])`

  - `start`와 `end` *사이*에 있는 문자열을 반환합니다.

  - `substring`은 `slice`와 아주 유사하지만 `start`가 `end`보다 커도 괜찮다는 데 차이가 있습니다.

    ```js
    let str = "stringify";
    
    // 동일한 부분 문자열을 반환합니다.
    alert( str.substring(2, 6) ); // "ring"
    alert( str.substring(6, 2) ); // "ring"
    
    // slice를 사용하면 결과가 다릅니다.
    alert( str.slice(2, 6) ); // "ring" (같음)
    alert( str.slice(6, 2) ); // "" (빈 문자열)
    ```

  - `substring`은 음수 인수를 허용하지 않습니다. 음수는 `0`으로 처리됩니다.

- `str.substr(start [, length])`

  - `start`에서부터 시작해 `length` 개의 글자를 반환합니다.

  - `substr`은 끝 위치 대신에 길이를 기준으로 문자열을 추출한다는 점에서 `substring`과 `slice`와 차이가 있습니다.

    ```js
    let str = "stringify";
    alert( str.substr(2, 4) ); // ring, 두 번째부터 글자 네 개
    ```

  - 첫 번째 인수가 음수면 뒤에서부터 개수를 셉니다.

    ```js
    let str = "stringify";
    alert( str.substr(-4, 2) ); // gi, 끝에서 네 번째 위치부터 글자 두 개
    ```

- 부분 문자열 추출과 관련된 메서드를 요약해 봅시다.

  | 메서드                  | 추출할 부분 문자열                    | 음수 허용 여부(인수)  |
  | :---------------------- | :------------------------------------ | :-------------------- |
  | `slice(start, end)`     | `start`부터 `end`까지(`end`는 미포함) | 음수 허용             |
  | `substring(start, end)` | `start`와 `end` 사이                  | 음수는 `0`으로 취급함 |
  | `substr(start, length)` | `start`부터 `length`개의 글자         | 음수 허용             |



> **어떤 메서드를 선택해야 하나요?**
>
> - 모두 사용해도 괜찮습니다. 그런데 `substr`에는 단점이 하나 있습니다. `substr`는 코어 자바스크립트 명세서(ECMA-262 – 옮긴이)가 아닌, 구식 스크립트에 대응하기 위해 남겨 둔 브라우저 전용 기능들을 명시해 놓은 부록 B(Annex B)에 정의되어있습니다. 거의 모든 곳에서 이 메서드가 동작하긴 하지만 브라우저 이외의 호스트 환경에서는 제대로 동작하지 않을 수 있습니다.
>
> - 남은 두 메서드 중 `slice`는 음수 인수를 허용한다는 측면에서 `substring`보다 좀 더 유연합니다. 메서드 이름도 더 짧죠. 따라서 세 메서드 중 `slice`만 외워놓고 사용해도 충분할 것 같습니다.



### 문자열 비교하기

- [비교 연산자](https://ko.javascript.info/comparison) 챕터에서 알아보았듯이 문자열을 비교할 땐 알파벳 순서를 기준으로 글자끼리 비교가 이뤄집니다.

- 그런데 아래와 같이 몇 가지 이상해 보이는 것들이 있습니다.

  1. 소문자는 대문자보다 항상 큽니다.

  ```javascript
  alert( 'a' > 'Z' ); // true
  ```

  2. 발음 구별 기호(diacritical mark)가 붙은 문자는 알파벳 순서 기준을 따르지 않습니다.

  ```javascript
  alert( 'Österreich' > 'Zealand' ); // true (Österreich는 오스트리아를 독일어로 표기한 것임 - 옮긴이)
  ```

  - 이런 예외사항 때문에 이름순으로 국가를 나열할 때 예상치 못한 결과가 나올 수 있습니다. 사람들은 `Österreich`가 `Zealand`보다 앞서 나올 것이라 예상하는데 그렇지 않죠.

- 자바스크립트 내부에서 문자열이 어떻게 표시되는지 상기하며 원인을 알아봅시다.

  - 모든 문자열은 [UTF-16](https://en.wikipedia.org/wiki/UTF-16)을 사용해 인코딩되는데, UTF-16에선 모든 글자가 숫자 형식의 코드와 매칭됩니다. 

  - 코드로 글자를 얻거나 글자에서 연관 코드를 알아낼 수 있는 메서드는 다음과 같습니다.

    - `str.codePointAt(pos)`: `pos`에 위치한 글자의 코드를 반환합니다.

      ```js
      // 글자는 같지만 케이스는 다르므로 반환되는 코드가 다릅니다.
      alert( "z".codePointAt(0) ); // 122
      alert( "Z".codePointAt(0) ); // 90
      ```

    - `String.fromCodePoint(code)`: 숫자 형식의 `code`에 대응하는 글자를 만들어준다.

      ```js
      alert( String.fromCodePoint(90) ); // Z
      ```

      `\u` 뒤에 특정 글자에 대응하는 16진수 코드를 붙이는 방식으로도 원하는 글자를 만들 수 있습니다.

      ```js
      // 90을 16진수로 변환하면 5a입니다.
      alert( '\u005a' ); // Z
      ```

- 이제 이 배경지식을 가지고 코드 `65`와 `220` 사이(라틴계열 알파벳과 기타 글자들이 여기에 포함됨)에 대응하는 글자들을 출력해봅시다.

  ```js
  let str = '';
  
  for (let i = 65; i <= 220; i++) {
    str += String.fromCodePoint(i);
  }
  alert( str );
  //ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
  // ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
  ```

  - 보이시나요? 대문자 알파벳이 가장 먼저 나오고 특수 문자 몇 개가 나온 다음에 소문자 알파벳이 나오네요. `Ö`은 거의 마지막에 출력됩니다.

- 글자는 글자에 대응하는 숫자 형식의 코드를 기준으로 비교됩니다. 

  - 코드가 크면 대응하는 글자 역시 크다고 취급되죠. 
  - 따라서 `a`(코드:97)는 `Z`(코드:90) 보다 크다는 결론이 도출됩니다.
  - 알파벳 소문자의 코드는 대문자의 코드보다 크므로 소문자는 대문자 뒤에 옵니다.
  - `Ö` 같은 글자는 일반 알파벳과 멀리 떨어져 있습니다. `Ö`의 코드는 알파벳 소문자의 코드보다 훨씬 큽니다.



### 문자열 제대로 비교하기

- 언어마다 문자 체계가 다르기 때문에 문자열을 ‘제대로’ 비교하는 알고리즘을 만드는 건 생각보다 간단하지 않습니다.

- 문자열을 비교하려면 일단 페이지에서 어떤 언어를 사용하고 있는지 브라우저가 알아야 합니다.

- 다행히도 모던 브라우저 대부분이 국제화 관련 표준인 [ECMA-402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf)를 지원합니다(IE10은 아쉽게도 [Intl.js](https://github.com/andyearnshaw/Intl.js/) 라이브러리를 사용해야 합니다).

- ECMA-402엔 언어가 다를 때 적용할 수 있는 문자열 비교 규칙과 이를 준수하는 메서드가 정의되어있습니다.

- [str.localeCompare(str2)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)를 호출하면 ECMA-402에서 정의한 규칙에 따라 `str`이 `str2`보다 작은지, 같은지, 큰지를 나타내주는 정수가 반환됩니다.

  - `str`이 `str2`보다 작으면 음수를 반환합니다.
  - `str`이 `str2`보다 크면 양수를 반환합니다.
  - `str`과 `str2`이 같으면 `0`을 반환합니다.

  ```js
  alert( 'Österreich'.localeCompare('Zealand') ); // -1
  ```



### 문자열 심화

> **심화 학습**
>
> 이번 절에선 문자열을 더 깊게 다룹니다. 이모티콘이나 일부 수학 기호, 상형 문자를 비롯한 희귀 기호 등을 다뤄야 한다면 앞으로 배울 내용이 유용하게 사용될 것입니다.
>
> 이런 글자들을 사용할 계획이 없다면 본 절을 넘어가셔도 좋습니다.



#### 서로게이트 쌍

#### 발음 구별 기호와 유니코드 정규화



### 요약

- 자바스크립트엔 세 종류의 따옴표가 있는데, 이 중 하나인 백틱은 문자열을 여러 줄에 걸쳐 쓸 수 있게 해주고 문자열 중간에 `${…}`을 사용해 표현식도 넣을 수 있다는 점이 특징입니다.
- 자바스크립트에선 UTF-16을 사용해 문자열을 인코딩합니다.
- `\n` 같은 특수 문자를 사용할 수 있습니다. `\u...`를 사용하면 해당 문자의 유니코드를 사용해 글자를 만들 수 있습니다.
- 문자열 내의 글자 하나를 얻으려면 대괄호 `[]`를 사용하세요.
- 부분 문자열을 얻으려면 `slice`나 `substring`을 사용하세요.
- 소문자로 바꾸려면 `toLowerCase`, 대문자로 바꾸려면 `toUpperCase`를 사용하세요.
- `indexOf`를 사용하면 부분 문자열의 위치를 얻을 수 있습니다. 부분 문자열 여부만 알고 싶다면 `includes/startsWith/endsWith`를 사용하면 됩니다.
- 특정 언어에 적합한 비교 기준 사용해 문자열을 비교하려면 `localeCompare`를 사용하세요. 이 메서드를 사용하지 않으면 글자 코드를 기준으로 문자열이 비교됩니다.

이외에도 문자열에 쓸 수 있는 유용한 메서드 몇 가지가 있습니다.

- `str.trim()` – 문자열 앞과 끝의 공백 문자를 다듬어 줍니다(제거함).
- `str.repeat(n)` – 문자열을 `n`번 반복합니다.
- 이 외의 메서드는 [MDN 문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String)에서 확인해보시기 바랍니다.

정규 표현식을 사용해 문자열을 찾거나 교체해주는 메서드도 여러 개 있는데 이는 아주 큰 주제이기 때문에 별도의 섹션 [정규 표현식](https://ko.javascript.info/regular-expressions)에서 다루겠습니다.



## 5.4 배열

## 5.5 배열과 메서드

## 5.6 iterable 객체

## 5.7 map과 set

## 5.8 weakMap과 weakSet

## 5.9 Object.keys, values, entries

## 5.10 구조 분해 할당

## 5.11 Date 객체와 날짜

## 5.12 JSON과 메서드

