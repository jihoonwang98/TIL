# [자바스크립트 패턴과 테스트] 1부 - 2장 도구 다루기

> [소스 파일](https://github.com/gilbutITbook/006844)



### 도입

**목차**

- 2.1 테스팅 프레임워크
- 2.2 의존성 주입 프레임워크
- 2.3 Aspect toolkit
- 2.4 코드 검사 도구
- 2.5 정리하기



**이 장의 주제**

- 본인이 개발한 코드의 믿음성을 단위 테스팅 프레임워크인 재스민으로 보장한다.
- 의존성 주입(DI) 컨테이너로 모듈성, 재사용성, 테스트성을 드높인다.
- AOP로 코드를 더욱 간단하고 바르게 작성한다.
- 테스트 주도 개발의 사례를 든다.
- JSLint로 제품 출시 전 코드의 문제점을 발견한다.



## 2.1 테스팅 프레임워크

- 한 여행사의 예약 시스템 구축 프로젝트

  - 항공 예약 데이터 생성 모듈을 만들어야 함.
  - 그중에 작동 명세가 다음과 같은 모듈 함수가 있다고 하자.
  - '승객(passenger) 객체, 항공편(flight) 객체를 입력받은 `createReservation`은 `passengerInformation` 프로퍼티가 승객 객체, `flightInfromation` 프로퍼티가 항공편 객체인 새로운 객체를 반환한다.'

- 간단하다. 바로 함수로 구현해보자.

  ```js
  // 예제 2-1 TDD 없이 작성한 createReservation 구현부
  // TestFrameworks_01.js
  function createReservation(passenger, flight) {
    return {
      passengerInfo: passenger,
      flightInfo: flight
    };
  }
  ```

- 팀 규정상 단위 테스트 없이 제품 코드를 check-in 할 수는 없으므로 단위 테스트 작성이 필요하다.

  ```js
  // 예제 2-2 테스트 대상을 완성한 다음 작성한 createReservation의 테스트 코드
  // TestFrameworks_01_tests.js
  describe('createReservation(passenger, flight)', function() {
    it('주어진 passenger를 passengerInfo 프로퍼티에 할당한다', function () {
      var testPassenger = {
        firstName: '윤지', 
        lastName: '김'
      };
      
      var testFlight = {
        number: '3443', 
        carrier: '대한항공',
        destination: '울산'
      };
      
      var reservation = createReservation(testPassenger, testFlight);
      expect((reservation.passengerInfo).toBe(testPassenger));
    });
    
    it('주어진 flight를 flightInfo 프로퍼티에 할당한다', function () {
      var testPassenger = {
        firstName: '윤지', 
        lastName: '김'
      };
      
      var testFlight = {
        number: '3443', 
        carrier: '대한항공',
        destination: '울산'
      };
      
      var reservation = createReservation(testPassenger, testFlight);
      expect((reservation.flightInfo).toBe(testFlight));
    });
  })
  ```

  - 위 예제는 재스민 테스팅 프레임워크로 작성한 단위 테스트 코드다. 우리는 앞으로 계속 재스민을 애용할 생각인데, 자세한 사용법과 설명은 뒷부분에 얘기한다.
  - `it` 함수 각자는 개별 단위 테스트고(따라서 이 예제는 단위 테스트가 2개 있다).
    - 이들은 함수에서 반환된 객체의 속성이 적절한지 `expect` 함수로 검사한다.

  

  > **Tip**
  >
  > - 두 단위 테스트에 반복된 설정 코드는 명백한 DRY 원칙 위반이다.
  > - 재스민 프레임워크에서 이런 코드를 들어내는 방법은 잠시 후에 다시 설명한다.



- 팀 내 단위 테스트 규정을 잘 따랐으니 코드를 체크인하고 자신 있게 다음 개발을 진행했다.

- 몇 시간 후 다른 팀에서 `createReservation` 함수 통합 작업을 진행 중인 동료 개발자가 메일을 보낸다.

- 통합 테스트 꾸러미에서 실행했더니 `createResrevation` 함수 테스트가 모두 실패했다는 내용이다.

  - 반환된 예약 객체의 속성명은 `passengerInformation`과 `flightInformation`이라고 명세에 나와 있는데,

    `createReservation` 개발을 너무 서두른 나머지 속성명을 `passengerInfo`와 `flightInfo`로 잘못 코딩한 것이다.

  - 당연히 동료 개발자는 명세에 쓰여 있는 이름을 가진 속성을 전제로 테스트 코드를 작성했을 것이다.

- 명세가 아니라 함수 코드의 개발에 따라 테스트를 작성한 탓에 테스트는 기대하는 함수 작동이 아닌, 구현된 함수의 (잘못된) 실제 작동을 확인한 꼴이다. 

- 명세 기준으로 테스트 코드를 작성했으면 애당초 속성명을 틀릴 일은 없었을 것이다.

  - 테스트 기반을 현재 코드가 아니라 명세에 두는 TDD 방식으로 개발해도 이 정도 실수는 일어나지 않겠냐고 하는 사람도 있겠지만, 경험에 따르면 전혀 그렇지 않다.

> **Tip**
>
> - 단위 테스트가 없는 기존 코드를 작업할 땐 실제 기능을 확인하는 테스트를 작성해야 한다.
> - 그래야 밖으로 표출되는 기능을 변경하지 않은 상태에서 코드를 리팩터링할 수 있다.



### 2.1.1 잘못된 코드 발견하기

- TDD는 코드 결함을 최대한 빨리, 곧 코드 생성 직후 감지하며, 작은 기능 하나라도 테스트를 먼저 작성한 뒤, 최소한의 코드만으로 기능을 구현한다.

- `createReservation` 함수로 다시 돌아가 테스트를 먼저 작성하면 어떻게 달라지는지 알아보자.

- 이 함수의 명세는 다음과 같다.

  - `createReservation`은 승객 객체, 항공편 객체를 입력받아  `passengerInformation` 프로퍼티가 승객 객체, `flightInformation` 프로퍼티가 항공편 객체인 새로운 객체를 반환한다.

- **<u>먼저</u>** `passengerInformation` 프로퍼티 할당이 정상적인지 확인하는 테스트를 작성한다.

  ```js
  // 예제 2-3 초기 createReservation 단위 테스트
  // TestFrameworks_02_tests.js
  describe('createReservation(passenger, flight)', function() {
    it('주어진 passenger를 passengerInfo 프로퍼티에 할당한다', function () {
      var testPassenger = {
        firstName: '윤지', 
        lastName: '김'
      };
      
      var testFlight = {
        number: '3443', 
        carrier: '대한항공',
        destination: '울산'
      };
      
      var reservation = createReservation(testPassenger, testFlight);
      expect((reservation.passengerInformation).toBe(testPassenger));
    });
  })
  ```

  - 그런 다음 이 테스트를 성공시킬 `createReservation` 코드를 최소한으로 작성한다.

  ```js
  // 예제 2-4 TDD로 구현한 createReservation 초기 코드
  // TestFrameworks_02.js
  function createReservation(passenger, flight) {
    return {
      passengerInfo: passenger,
      flightInformation: flight
    };
  }
  ```

  - 단위 테스트하면 실패한다. 이유가 뭘까?
    - 결과: `Expected undefined to be { firstName : 'Pete', lastName: 'Mitchell' }`
  - 옳거니! 반환 객체의 속성명을 잘못 적었다.
    - 속성명을 정정하고 다시 테스트하면 성공한다.
  - `flightInformation` 할당 테스트도 마찬가지 방법으로 실행하면 `createReservation` 함수는 문제가 없음을 확인할 수 있다.

- 반환 객체의 속성명을 잘못 쓴 실수가 `createReservation` 함수를 구현한 코드에 잠복해 있지만, 이번에는 테스트를 먼저 작성한 뒤 명세에 따라 테스트를 했다.

  - 에러를 즉시 확인하여 조치할 수 있다.





### 2.1.2 테스트성을 감안하여 설계하기

- 테스트를 먼저 작성하란 건 **코드의 테스트성(testability)**를 주요 관심사로 생각하라는 것이다.
  - 코드의 테스트성 UP -> 해당 코드의 테스트가 실제로 잘 이루어짐
  - 테스트하기 쉬울수록 -> 유지 보수성, 확장성 UP
- 1장에서 말했듯,
  - SOLID 원칙 준수 -> 코드 테스트에 도움됨
  - 결국 테스트성(testability)을 설계 목표로 정하면 SOLID한 코드를 작성할 수 있다.



- 예시

  - `createReservation` 함수로 생성한 모든 예약 데이터는 웹 서비스를 거쳐 DB에 저장해야 한다.

  - TDD 없이 개발하면,

    - AJAX로 예약 데이터를 웹 서비스 종단점으로 전송하는 `jQuery.ajax(...)` 호출 코드를 `createReservation`에 보태기만 하면 댐
      - 하지만, 단순한 함수 호출 하나가 더해지면서 `createReservation` 함수의 할 일이 늘었고, 단위 테스트 하기가 힘들어짐. (testablitiy DOWN)
    - 그 다음에는 DB에 예약 데이터가 잘 쌓이는지 수동으로 한 차례 테스트하려 할 것이다.
      - 기능 하난하나에 단위 테스트를 붙이는 건 너무 귀찮기 때문...

  - TDD에 충실한 사람이면 무조건 전진해서 `createReservation`을 고치기보다는 일단 새 기능을 확인하는 테스트를 작성한다.

    - 첫 번째 테스트에서 예약 데이터가 제대로 웹 서비스 종단점까지 보내졌는지를 확인한다.

    - 그런데 여기서 "`createReservation`이 웹 서비스 통신까지 맡아야 하나?" 하는 의문을 가지는 건 자기 계발에 상당히 도움된다.

      ```js
      describe('createReservation(passenger, flight)' function () {
        // Existing tests
        it('예약 정보를 웹 서비스 종단점으로 전송한다', function() {
          
          // createReservation이 웹 서비스 통신까지 맡아야 하나?
          
        });
      });
      ```

    - 정답은 '그럴일 없다'이다.

    - 웹 서비스 통신 전담 객체가 없으면 하나 만드는 편이 좋겠다.

- 이처럼 **코드 테스트성(testablitiy)**을 극대화하면 SOLID 원칙을 어긴 코드도 쉽게 솎아낼 수 있다.





### 2.1.3 꼭 필요한 코드만 작성하기

- TDD 작업(작은 기능 하나를 검증하는 작업) 절차
  - 실패 테스트 작성
  - 테스트를 성공시킬 만큼만 최소한으로 코딩
  - 내부적으로 세부 구현을 변경하는 **리팩터링**하기 (중복 코드 제거)
- 최소한의 코드를 넣고 리팩터링으로 중복 코드 없애고... 
  - 이런 과정을 거치면 결국 마지막에는 꼭 필요한 코드만 살아남게 된다.



### 2.1.4 안전한 유지 보수와 리팩터링

- TDD를 실천하면 프로젝트 제품 코드를 대상으로 확실한 <u>단위 테스트 꾸러미</u>를 구축할 수 있다.
  - 예전에 잘 돌아가던 코드가 제대로 동작 안하는 **회귀 결함(regression defect)** -> 코드 품질, 믿음성 DOWN
- 종합적인 단위 테스트 꾸러미가 마련된 제품 코드를 확장, 보수할 때 -> 안도감
  - 실수로 다른 코드를 건드리지 않았다는 확신 -> 자신감 있는 코드 변경 가능



### 2.1.5 실행 가능한 명세

- TDD 실천 결과물인 단위 테스트 꾸러미
  - 테스트 대상 코드의 실행 가능한 **명세** 역할도 할 수 있음
- 단위 테스트 프레임워크인 재스민은 행위 기반(behavior-based)으로 테스트를 구성한다.
  - 재스민에서 **스펙(specification)**이라 부르는 개별 테스트는, 테스트하여 검증할 작동 로직을 일상 문장으로 표현하면서 시작한다.
  - 각 테스트를 실행할 때마다 이 문장들은 재스민의 테스트 결과 기본 포매터로 화면에 표시된다.
  - `createReservation` 함수를 예로 들면, <u>재스민으로 단위 테스트한 결과 메시지를 보고 이 함수가 무슨 일을 하는지 큰 그림을 그려볼 수 있다.</u>
    - `createReservation`이 하는 일을 굳이 코드를 읽고 분석하지 않아도 단위 테스트가 죄다 알려주는 셈이다.



### 2.1.6 최신 오픈 소스 및 상용 프레임워크

- 우리가 선호하는 재스민 말고 다른 프레임워크도 있다.
  - 그중 많이 사용되는 QUnit과 D.O.H를 소개한다. (생략)



### 2.1.7 재스민 입문

- [재스민](http://jasmine.github.io)은 **행위 주도 개발(Behavior-Driven Development, BDD)** 방식으로 자바스크립트 단위 테스트를 작성하기 위한 라이브러리다.

> - BDD와 TDD는 상호 배타 관계가 아니다.
> - BDD는 단위 테스트로 확인할 기능 또는 작동 로직을 일상 언어로 서술한다.
>   - 이로써 개발자는 자신이 작성 중인 코드가 '어떻게'가 아니라 '무엇'을 해야 하는지 테스트 코드에 표현할 수 있다.
> - 그리고 행위 주도 스타일로 정의/구성한 테스트는 쉬운 문장으로 서술한 기능 명세서로 삼을 만하다는 이점도 있다.



#### 테스트 꾸러미와 스펙

- 재스민 테스트 꾸러미는 전역 함수 `describe`로 정의되며, 이 함수는 두 인자를 받는다.
  - 문자열: 무엇을 테스트할지 서술
  - 함수: 테스트 꾸러미의 구현부(implementation)
- 테스트 꾸러미는 스펙, 즉 개별 테스트로 구현되며, 각 스펙은 전역 함수 `it`로 정의된다.
- `it` 함수도 `describe` 함수처럼 인자를 2개 받는다.
  - 문자열: 무엇을 테스트할지 서술
  - 적어도 한 개의 기대식(expression)을 가진 함수: 코드 상태의 true/false를 확인하는 단언(assertion)
- 테스트 꾸러미 구현부에 전역 함수 `beforeEach/afterEach`를 쓰면 각 꾸러미 테스트가 실행되기 이전에 `beforeEach` 함수를, 그 이후에는 `afterEach` 함수를 호출한다.
  - 전체 테스트가 공유할 설정(setup)과 정리(teardown) 코드를 두 함수에 담아두면 코드 중복을 피할 수 있어 좋다.
  - 테스트 꾸러미 역시 SOLID하고 DRY해야 한다.



- 설정 단계가 정확히 같은 테스트가 2개 있는 예제 2-2에서 DRY 원칙을 어긴 코드를 어떻게 해결하는지 살펴보자.

  ```js
  // 재스민 beforeEach와 afterEach 함수
  // TestFrameworks_03_tests.js
  describe('createReservation(passenger, flight)', function() {
    var testPassenger = null, 
        testFlight = null,
        testReservation = null;
    
    beforeEach(function() {
      testPassenger = {
        firstName: '윤지', 
        lastName: '김'
      };
      
      testFlight = {
        number: '3443', 
        carrier: '대한항공',
        destination: '울산'
      };
      
      testReservation = createReservation(testPassenger, testFlight);
    });
    
    it('주어진 passenger를 passengerInfo 프로퍼티에 할당한다', function () {
      expect((testReservation.passengerInformation).toBe(testPassenger));
    });
    
    it('주어진 passenger를 passengerInfo 프로퍼티에 할당한다', function () {
      expect((testReservation.flightInformation).toBe(testFlight));
    });
    
  });
  ```



#### 기대식(expression)과 매처(matcher)

- `expect`문은 테스트마다 있다.

  - 다음은 첫 번째 단위 테스트 `createReservation`의 `expect`문이다.

    ```js
    expect((testReservation.passengerInformation).toBe(testPassenger));
    // expect((실제값).toBe(기댓값))
    ```

  - `expect` 함수는 테스트 대상 코드가 낸 실제값(여기서는 `testReservation.passengerInformation`)을 인자로 받아 기댓값과 견주어본다.

    - 이 테스트가 기대하는 값은 `testPassenger`다.

- 실제값과 기댓값을 비교하는 일은 매처(matcher) 함수의 몫이다.

  - 매처는 비교 결과 성공하면 `true`를, 실패하면 `false`를 반환한다.
  - 하나 이상의 기대식이 포함된 스펙에서 매처가 하나라도 실패하면 모조리 실패한 것으로 간주한다.
  - 반대로, 모든 매처가 성공하면 스펙은 성공한다.

- `toBe` 매처는 이름에서 짐작할 수 있듯이 `testReservation.passengerInformation`이 `testPassenger`와 같은 객체여야(to be) 한다는 의미다.

- 재스민이 제공하는 내장 매처는 여럿 있는데, 용도에 맞는 매처가 없으면 재스민이 지원하는 **커스텀 매처**를 만들어 쓸 수도 있다.

  - 재스민-제이쿼리 같은 라이브러리를 쓰면 매칭 기능을 더 보강할 수 있다.



#### 스파이

- 재스민 스파이(spy)는 **테스트 더블(test double)** 역할을 하는 자바스크립트 함수다.
  - **테스트 더블**이란 어떤 함수/객체의 본래 구현부를 테스트 도중 다른 (보통은 더 간단한) 코드로 대체한 것을 말한다. (스턴트맨)
  - 테스트 더블은 웹 서비스 같은 외부 자원과의 의존 관계를 없애고 단위 테스트의 복잡도를 낮출 목적으로 사용된다.



- 생성된 예약 데이터를 DB에 저장하는 웹 서비스와 직접 통신할 수 있게 `createReservation` 함수를 확장하는 문제를 앞서 간략히 살펴봤다.
  - 그리고 웹 서비스 통신은 이 함수가 할 일은 아니라고 결론 내렸다.
- 동료 개발자는 `ReservationSaver`라는 자바스크립트 객체를 만들어 이 객체의 `saveReservation` 함수로 웹 서비스에 예약 데이터를 전송하는 기능을 캡슐화했다.
- 나는 `createReservation` 함수를 확장하여 이 함수가 `ReservationSaver ` 인스턴스를 인자로 받아 이 인스턴스의 `saveReservation` 함수를 실행하는지 확인하고자 한다.
- `saveReservation` 함수는 웹 서비스와 통신하므로 지금부터 작성할 테스트는 예약 데이터 저장 후 DB를 질의하고 예약 데이터가 분명히 추가됐는지 확인하는 과정이 모두 들어가야 할 듯싶다.
  - 과연 그럴까? 다행히 그렇지 않다.
  - 그럴 필요도 없거니와 그러면 안된다.
  - 자칫 <u>단위 테스트가 웹 서비스, DB 같은 외부 시스템 유무와 작동 여부에 의존하게 될지도 모른다</u>.

> **Tip**
>
> - 외부 시스템과 연동하는 코드에 이상이 없는지 확인하는 테스트를 **통합 테스트(integration test)**라 한다.
> - 소프트웨어를 바르게 작성하는 데 중요한 과정이지만, 단위 테스트와는 분명히 구별해야 한다.



- 재스민 스파이를 사용하면 복잡한 `saveReservation` 구현부를 외부 시스템 의존성을 배제한, 단순한 형태로 바꿀 수 있다.

  - 먼저 동료 개발자가 작성한 `ReservationSaver` 객체를 보자.

    ```js
    function ReservationSaver() {
    	this.saveReservation = function(reservation) {
        // 예약 정보를 저장하는 웹 서비스와 연동하는 복잡한 코드가 있을 것이다.
      }
    }
    ```

> **Tip**
>
> - 동료 개발자는 새 `ReservationSaver` 인스턴스를 `new ReservationSaver()`로 만들었는데, 이는 생성자-함수 패턴(Constructor-function pattern)으로 JS 객체를 생성한 것이다.

- 다음 절인 '의존성 주입 프레임워크'에서 더 깊이 설명하겠지만, `createReservation` 함수는 `ReservationSaver` 인스턴스를 전달받게끔 개선되었다.

  - `ReservationSaver`를 인자로 받으므로 예약 데이터가 저장되었는지 확인하는 테스트를 다음과 같이 작성할 수 있다.

    ```js
    describe('createReservation', function() {
      it('예약 정보를 저장한다.', function() {
        var saver = new ReservationSaver();
        // testPassenger와 testFlight는 이 테스트 꾸러미의
        // beforeEach 함수에서 이미 설정되었다고 가정한다.
        createReservation(testPassenger, testFlight, saver);
        
        // saver.saveReservation(...)이 정말 호출되었는지 어떻게 알 수 있을까?
      })
    })
    ```

    - 이 테스트는 코드에 씌어있는 대로 복잡한 `ReservationSaver`의 implementation을 `createReservation` 함수에 전달하고 있다.
    - 이렇게 하면 결국 <u>외부 시스템에 의존</u>하게 되고 <u>함수를 테스트하기가 어려워지므로</u> 별로 내키지 않는다.
    - 이럴 때 **재스민 스파이**가 제격이다.



- `createReservation`을 호출하기 전에 `saveReservation` 함수에 스파이를 심는다.

  - 스파이로 함수 실행 여부를 알 수 있는데, 첫 번째 테스트에 아주 잘 들어맞는다.

- 재스민에서 전역 함수 `spyOn`을 쓰면 특정 함수를 몰래 들여다볼 수 있다.

  - 이 함수의 첫 번째 인자는 객체 인스턴스, 두 번째 인자는 감시할 함수명이다.

  - 다음과 같이 기존 테스트를 `saveReservation`에 스파이를 심은 코드로 바꿔보자.

    ```js
    it('예약 정보를 저장한다', function() {
      var saver = new ReservationSaver();
      spyOn(saver, 'saveReservation');
      // testPassenger와 testFlight는 이 테스트 꾸러미의 
      // beforeEach 함수에서 이미 설정되었다고 가정한다.
      createReservation(testPassenger, testFlight, saver);
      
      // saveReservation이 정말 호출되었는지 어떻게 알 수 있을까?
    });
    ```

- 스파이를 써서 `saver` 객체의 `saveReservation` 구현부를 예약 데이터 저장 기능과 무관한 함수로 대체했다.

  - 스파이는 함수를 호출한 시점과 호출 시 전달한 인자까지 정확히 포착하고, 
  - 무엇보다 재스민은 어떤 스파이가 한 번 이상 실행됐는지 확인하는 기대식을 지닌 스파이 전용 매처를 지원한다.

- 다음과 같이 기대식까지 추가하면 완벽하다.

  ```js
  it('예약 정보를 저장한다', function() {
  	var saver = new ReservationSaver();
    spyOn(saver, 'saveReservation');
    // testPassenger와 testFlight는 이 테스트 꾸러미의 
    // beforeEach 함수에서 이미 설정되었다고 가정한다.
    createReservation(testPassenger, testFlight, saver);
    
    expect(saver.saveReservation).toHaveBeenCalled();
  });
  ```

  

- `createReservation` 함수의 인자가 늘었으니 기존 두 테스트 역시 수정할 수밖에 없다.

  - 하지만 `saveReservation` 함수 구현부를 직접 실행할 테스트는 없을 테니 `ReservationSaver` 생성 코드와 스파이 관련 코드를 전체 꾸러미의 `beforeEach` 함수로 옮겨 리팩터링한다.

    ```js
    // 예제 2-7 ReservationSaver를 포함한 테스트
    // TestFrameworks_04_tests.js
    describe('createReservation', function() {
      var testPassenger = null,
          testFlight = null,
          testReservation = null,
          testSaver = null;
      
      beforeEach(function() {
        testPassenger = {
          firstName: '윤지',
          lastName: '김'
        };
        
        testFlight = {
    			number: '3443',
          carrier: '대한항공',
          destination: '울산'
        };
        
        testSaver = new ReservationSaver();
        spyOn(testSaver, 'saveReservation');
        
        testReservation = createReservation(testPassenger, testFlight, testSaver);
      });
      
      it('passenger를 passengerInformation 프로퍼티에 할당한다', function() {
        expect(testReservation.passengerInformation).toBe(testPassenger);
      });
      
      it('flight를 flightInformation 프로퍼티에 할당한다', function() {
        expect(testReservation.flightInformation).toBe(testFlight);
      });
      
      it('예약 정보를 저장한다', function() {
        expect(testSaver.saveReservation).toHaveBeenCalled();
      });
    });
    ```

    - 지금 실행하면 테스트 꾸러미는 실패한다. `createReservation` 함수를 약간 손봐야 한다.

    ```js
    // 예제 2-8 ReservationSaver를 쓴 createReservation 구현부
    // TestFrameworks_04.js
    function createReservation(passenger, flight, saver) {
      var reservation = {
        passengerInformation: passenger,
        flightInformation: flight
      };
      
      saver.saveReservation(reservation);
      
      return reservation;
    }
    
    // 동료가 작성한 ReservationSaver
    function ReservationSaver() {
      this.saveReservation = function(reservation) {
        // 예약 정보를 저장하는 웹 서비스와 연동하는 복잡한 코드가 존재
      };
    }
    ```

    

























## 2.2 의존성 주입 프레임워크

## 2.3 Aspect toolkit

## 2.4 코드 검사 도구 

## 2.5 정리하기



















