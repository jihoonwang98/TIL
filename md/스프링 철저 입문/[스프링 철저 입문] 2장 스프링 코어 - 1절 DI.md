## 2.1 DI

스프링 프레임워크에 대해 설명하기 전에 **의존성 주입(DI: Dependency Injection)**이 필요하게 된 배경을 알아보자. 



보통 엔터프라이즈 애플리케이션을 개발할 때는 하나의 처리를 수행하기 위해 **여러 개의 컴포넌트를 조합해서 구현**하는 경우가 일반적이다. 이때 사용되는 컴포넌트에는 '공통으로 사용되는 기능을 따로 분리한 컴포넌트', '데이터베이스에 접근하기 위한 컴포넌트', '외부 시스템이나 서비스에 접속하기 위한 컴포넌트' 등과 같이 다양한 컴포넌트가 있다. 또한 오늘날의 애플리케이션 개발에서는 직접 개발하기보다는 이미 잘 만들어진 오픈소스 라이브러리를 활용하는 형태도 많아지고 있다.



이처럼 하나의 처리를 구현하기 위해 여러 개의 컴포넌트를 통합할 때 **의존성 주입**이라는 접근 방식이 큰 힘을 발휘한다. 예를 들어, 사용자를 등록하는 클래스를 구현한다고 가정해 보자. 사용자 등록을 위해 필요한 처리 흐름은 다음과 같다.



1. **등록하려는 사용자 계정이 이미 등록돼 있는지 확인한다.**
2. **등록하려는 사용자의 패스워드를 해시(hash)한다.**
3. **사용자 정보를 저장한다.**



**[표 2.1] 사용자 등록 기능에서 사용할 인터페이스**

| 인터페이스명    | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| UserRepository  | 사용자 정보를 영속적으로 저장하거나 저장된 사용자 정보를 가져오는 인터페이스 |
| PasswordEncoder | 패스워드를 해시화하는 인터페이스                             |
| UserService     | 사용자 등록을 처리하는 인터페이스                            |





이제 이러한 인터페이스에 어떤 기능이 있는지 메서드를 살펴보자. 그리고 **UserRepository**와 **PasswordEncoder**를 조합한 **UserService**의 구현 클래스로 **UserServiceImpl**이 어떤 모양으로 만들어지는지에 대해서도 다음 예제를 통해 확인해보자.





**사용자 등록을 처리하는 인터페이스**

```java
public interface UserService {
	// 사용자 정보를 등록한다.
	void register(User user, String rawPassword);
}
```





**패스워드를 해시화하는 인터페이스**

```java
public interface PasswordEncoder {
	// 패스워드를 해시화한다.
	String encode(CharSequence rawPassword);
}
```





**사용자 정보를 관리하는 인터페이스**

```java
public interface UserRepository {
	// 사용자 정보를 저장한다.
    User save(User user);
    // 사용자 계정명이 일치하는 사용자 수를 카운트한다.
    int countByUsername(String username);
}
```





**사용자 등록을 처리하는 구현 클래스**

```java
public class UserServiceImpl implements UserService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    
    
    public UserServiceImpl(javax.sql.DataSource dataSource) {
        // 데이터베이스 방식으로 사용자 정보를 관리하는 구현 클래스
        this.userRepository = new JdbcUserRepository(dataSource);
        
        // Bcrypt 알고리즘으로 해시화하는 구현 클래스
        this.passwordEncoder = new BCryptPasswordEncoder();
    }
    
    public void register(User user, String rawPassword) {
        if (this.userRepository.countByUsername(user.getUsername()) > 0) {
            // 같은 사용자 계정의 사용자가 있다면 예외를 발생시킨다.
            throw new UserAlreadyRegisteredException();
        }
        
        // 입력된 원본 패스워드를 해시화한 후, 사용자 정보로 설정한다.
        user.setPassword(this.passwordEncoder.encode(rawPassword));
        this.userRepository.save(user);
    }
}
```



이 예에서는 생성자에서 `userRepository`와 `passwordEncoder`를 초기화하기 위해 `UserRepository`와 `PasswordEncoder`의 구현 클래스를 직접 생성해서 할당한다. 그래서 `UserServiceImpl` 클래스를 개발하는 단계에서는 의존하는 컴포넌트의 클래스가 이미 완성되어 있어야 한다. 이처럼 필요한 컴포넌트를 생성자에서 직접 생성하는 방식은 일단 클래스가 생성되고 나면 이미 생성된 `UserRepository`나 `PasswordEncoder`의 구현 클래스를 교체하는 것이 사실상 어려울 수 있다. 이러한 클래스 간의 관계를 두고 '클래스 간의 결합도가 높다'라고 말한다.



한편 엔터프라이즈 애플리케이션을 개발할 때는 다양한 컴포넌트를 조합하는 것이 일반적이라고 했는데, 많은 컴포넌트에 의존해야 하는 클래스를 이 같은 방식으로 개발하는 것은 상당히 비효율적이다. 예를 들어 의존하는 클래스가 아직 개발 중이거나, 미들웨어 벤더가 제공해줘야 하는 클래스가 있는데 그 벤더의 제품이 완성되지 않았을 수도 있다. 결국 모든 컴포넌트가 제대로 모양새를 갖추려면 개발의 막바지에 이르러서야 오류 없이 조립할 수 있다. 

이런 문제를 해결할 대안으로는 필요한 컴포넌트가 완성될 때까지 임시로 더미(dummy) 클래스를 만들어서 대체하는 방법이 있다. 다만 언젠가는 제대로 구현해서 교체해야 할 코드이기 때문에 개발할 애플리케이션의 규모가 커지면 커질수록 재작업할 양이 늘어난다.





그럼 `UserServiceImpl`  클래스의 결합도를 낮추려면 어떻게 해야 할까? 우선 생성자 안에서 `UserRepository`와 `PasswordEncoder`의 구현 클래스를 직접 생성하는 대신, 다음과 같이 생성자의 인수로 받아서 할당하는 방법을 생각해볼 수 있다.



**생성자를 활용한 의존 컴포넌트 초기화**

```java
public UserServiceImpl(UserRepository userRepository, PasswordEncoder passwordEncoder) {
	this.userRepository = userRepository;
	this.passwordEncoder = passwordEncoder;
}
```



이렇게 하면 `UserServiceImpl`의 소스코드 안에서 `UserRepository`와 `PasswordEncoder`의 구현 클래스 정보가 제거되어 `UserServiceImpl`의 외부에서 `UserRepository`와 `PasswordEncoder`의 구현체를 쉽게 변경할 수 있게 된다. 결국 `UserService`를 사용하는 애플리케이션은 다음과 같은 형태가 된다.



**애플리케이션에서 UserService를 사용**

```java
UserRepository userRepository = new JdbcUserRepository(dataSource);
PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
UserService userService = new UserServiceImpl(userRepository, passwordEncoder);
// 생략
```



한편 만약 `JdbcUserRepository`와 `BCryptPasswordEncoder`가 아직 완성되지 않았다면 어떻게 해야 할까? 앞서 생성자 안에서 구현 클래스를 직접 생성하던 방식과 달리 `UserServiceImpl`을 변경하지 않고 `JdbcUserRepository`와 `BcryptPasswordEncoder`의 더미 클래스를 임시로 만들어서 대체하면 개발을 중단 없이 계속할 수 있다.



**미완성된 클래스를 더미로 대체**

```java
UserRepository userRepository = new DummyUserRepository(dataSource);
PasswordEncoder passwordEncoder = new DummyPasswordEncoder();
UserService userService = new UserServiceImpl(userRepository, passwordEncoder);
// 생략
```



하지만 이 경우에도 `UserServiceImpl`이 의존하는 각 컴포넌트는 개발자가 직접 생성해서 주입해야 하기 때문에 변경이 발생하는 경우의 재작업은 피할 수 없다. 여기서 본 것처럼 어떤 클래스가 필요로 하는 컴포넌트를 외부에서 생성한 후, 내부에서 사용 가능하게 만들어 주는 과정을 **'의존성을 주입(DI)한다'** 또는 **'인젝션(Injection)한다'**라고 말한다. 그리고 이러한 의존성 주입을 자동으로 처리하는 기반을 **'DI 컨테이너'**라고 한다.



스프링 프레임워크가 제공하는 기능 중 가장 중요한 것이 바로 이 DI 컨테이너의 기능이다. 스프링 프레임워크의 DI 컨테이너에 `UserService`, `UserRepository`, `PasswordEncoder`의 인터페이스와 구현 클래스를 알려주고 의존 관계를 정의해주면 `UserServiceImpl`이 생성될 때 `UserRepository`와 `PasswordEncoder`의 구현 클래스가 자동으로 생성되어 주입된다. `UserService`를 사용하고 싶은 애플리케이션은 DI 컨테이너에서 `UserService`를 꺼내오기만 하면 되고, 이때 `UserRepository`와 `PasswordEncoder`는 `UserService`에 이미 조합된 상태다.



DI 컨테이너에서 `UserService`를 꺼내오는 코드는 다음과 같다.



**DI 컨테이너에서 `UserService` 꺼내기**

```java
ApplicationContext context = ...; // 스프링 DI 컨테이너
UserService userService = context.getBean(UserService.class);
// 생략
```



이렇게 DI 컨테이너를 통해 각 컴포넌트의 인스턴스를 생성하고 통합 관리하면서 얻을 수 있는 장점은 다음과 같다.

- 컴포넌트 간의 **의존성** 해결
- 인스턴스의 **스코프(scope) 관리**: 싱글턴, 프로토타입 등 객체의 스코프를 컨테이너가 대신 관리해줌.
- **AOP** 기능 구현: 각 인스턴스가 필요로 하는 **공통 처리 코드**를 외부에서 자동으로 끼워넣어줌.







### 2.1.1 DI 개요

**DI**는 **의존성 주입**이라고도 하며, **IoC**라고 하는 소프트웨어 디자인 패턴 중 하나다. 이때의 **IoC**는 인스턴스를 제어하는 주도권이 역전된다는 의미로 사용되는데, **컴포넌트를 구성하는 인스턴스의 생성과 의존 관계의 연결 처리를 해당 소스코드가 아닌 DI 컨테이너에서 대신해주기 때문에 제어가 역전됐다**고 보는 것이다.



DI 컨테이너에서 인스턴스를 관리하는 방식에는 다음과 같은 장점이 있다.

- 인스턴스의 **스코프**를 **제어**할 수 있다.
- 인스턴스의 **생명 주기**를 **제어**할 수 있다.
- **AOP** 방식으로 **공통 기능**을 집어넣을 수 있다.
- 의존하는 컴포넌트 간의 결합도를 낮춰서 **단위 테스트**하기 쉽게 만든다.





### 2.1.2 ApplicationContext와 빈 정의

스프링 프레임워크에서는 `ApplicationContext`가 DI 컨테이너의 역할을 한다. 다음은 DI 컨테이너에서 인스턴스를 꺼내는 것을 예로 든 것이다.



#### DI 컨테이너에서 인스턴스 꺼내기

```java
ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);   --- (1)
UserService userService = context.getBean(UserService.class);                           --- (2)
```



**(1)**: **설정 클래스(configuration class)**를 인수로 전달하고 **DI 컨테이너**를 **생성**한다. 설정 클래스는 여러 개 정의할 수도 있다.

**(2)**: **DI 컨테이너**에서 `UserService` 인스턴스를 가져온다.





여기서 `AppConfig` 클래스는 DI 컨테이너에서 **설정 파일 역할**을 하며, 자바로 작성돼 있어서 **Java Configuration Class**라고도 한다. 그리고 이렇게 **Java Configuration Class**로 설정하는 방식을 **자바 기반 설정 방식**이라고 하며, 다음과 같은 형태로 작성한다.



#### 자바 기반 설정 방식의 예

```java
@Configuration
public class AppConfig {
    @Bean
    UserRepository userRepository() {
        return new UserRepositoryImpl();
    }
    
    @Bean
    PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    UserService userService() {
        return new UserServiceImpl(userRepository(), passwordEncoder());
    }
}
```



**@Configuration**과 **@Bean** 애너테이션을 사용해서 DI 컨테이너에 컴포넌트를 등록하면 애플리케이션은 DI 컨테이너에 있는 빈(Bean)을 `ApplicationContext` 인스턴스를 통해 가져올 수 있다. 스프링 프레임워크에서는 DI 컨테이너에 등록하는 컴포넌트를 **빈**이라고 하고, 이 빈에 대한 설정(Configuration) 정보를 **'빈 정의(Bean Definition)'**라고 한다. 또한 DI 컨테이너에서 빈을 찾아오는 행위를 **'룩업(lookup)'**이라고 한다.





DI 컨테이너에서 빈을 가져오는 방법에는 몇 가지 유형이 있다. 다음 예를 살펴보자.



#### DI 컨테이너에서 빈 가져오기

```java
UserService userService = context.getBean(UserService.class);                    --- (1)
UserService userService = context.getBean("userService", UserService.class);     --- (2)
UserService userService = (UserService) context.getBean("userService");          --- (3)
```



**(1):** 가져오려는 빈의 타입(Type)을 지정하는 방법이다. **지정한 타입에 해당하는 빈이 DI 컨테이너에 오직 하나만 있을 때 사용**한다.

**(2)**: 가져오려는 빈의 이름과 타입을 지정하는 방법이다. **지정한 타입에 해당하는 빈이 DI 컨테이너에 여러 개 있을 때 이름으로 구분하기 위해 사용**한다.

**(3):** 가져오려는 빈의 이름을 지정하는 방법이다. 반환값이 `Object` 타입이라서 원하는 빈의 타입으로 형변환해야 한다.







한편 빈을 설정하는 방법에도 몇 가지 유형이 있는데 대표적인 방법은 아래의 표와 같다.



#### 대표적인 빈 설정 방법

| 방법                                                         | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **자바 기반 설정 방식**                        <br />(Java-based configuration) | 자바 클래스에 **@Configuration** 애너테이션을, 메서드에 **@Bean** 애너테이션을 사용해 빈을 정의하는 방법. 최근에는 스프링 기반 애플리케이션 개발에 자주 사용되고 특히 **스프링 부트에서 이 방식을 많이 활용**한다. |
| **XML 기반 설정 방식**                         <br />(XML-based configuration) | **XML 파일을 사용**하는 방법으로 \<bean> 요소의 class 속성에 FQCN(Fully-Qualified Class Name)을 기술하면 빈이 정의된다. \<constructor-arg>나 \<property> 요소를 사용해 의존성을 주입한다. |
| **애너테이션 기반 설정 방식 **                                        <br />(Annotation-based configuration) | **@Component** 같은 **마커 애너테이션(Marker Annotation)**이 부여된 클래스를 탐색해서(Component Scan) DI 컨테이너에 빈을 <u>자동으로 등록</u>하는 방법이다. |





`ApplicationContext`에는 이와 같은 다양한 설정 방식을 지원하기 위한 구현 클래스가 준비되어 있다. 다음 예를 살펴보자.





#### `ApplicationContext`를 생성하는 다양한 방법

```java
ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);       --- (1)
ApplicationContext context = new AnnotationConfigApplicationContext("com.example.app");     --- (2)
ApplicationContext context = 
    new ClassPathXmlApplicationContext("META-INF/spring/applicationContext.xml");           --- (3)
ApplicationContext context = 
    new FileSystemXmlApplicationContext("./spring/applicationContext.xml");                 --- (4)
```



**(1)**: **자바 기반의 설정 방식**으로 `AnnotationConfigApplicationContext`의 생성자에 <u>@Configuration 애너테이션이 붙은</u> **클래스**를 인수로 전달한다.

**(2)**: **애너테이션 기반의 설정 방식**으로 `AnnotationConfigApplicationContext`의 생성자에 **패키지명**을 인수로 전달한다. 지정된 패키지 이하의 경로에서 컴포넌트를 스캔한다.

**(3)**: XML 기반의 설정 방식으로 `ClassPathXmlApplicationContext`의 생성자에 XML 파일을 인수로 전달한다. 경로에 접두어(Prefix)가 생략된 경우에는 클래스패스 안에서 상대 경로로 설정 파일을 탐색한다.

**(4)**: XML 기반의 설정 방식으로 `FileSystemXmlApplicationContext`의 생성자에 XML 파일을 인수로 전달한다. 경로에 접두어(Prefix)가 생략된 경우에는 JVM의 작업 디렉터리 안에서 상대 경로로 설정 파일을 탐색한다.



`ApplicationContext`는 단독 애플리케이션에서 스프링 프레임워크를 사용하거나 JUnit으로 만든 테스트 케이스 안에서 스프링 프레임워크를 구동할 때 사용된다. 반면 웹 애플리케이션에서는 스프링 MVC를 활용하게 되는데, 이때는 `ApplicationContext`를 웹 환경에 맞게 확장한 `WebApplicationContext`를 사용한다.







### 2.1.3 빈 설정

앞서 살펴본 빈의 세 가지 설정 방식에 대해 좀 더 자세히 알아보자.





#### 자바 기반 설정 방식

**자바 기반 설정 방식**에서는 자바 코드로 빈을 설정한다. 이때 사용되는 자바 클래스를 **Java Configuration Class**라고 한다. 다음 예를 살펴보자.



##### **자바 기반 설정 방식으로 빈 정의**

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
// 기타 임포트 문은 생략

@Configuration    --- (1)
public class AppConfig {
    @Bean     --- (2)
    UserRepository userRepository() {
        return new UserRepositoryImpl();
    }
    
    @Bean
    PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    UserService userService() {
        return new UserServiceImpl(userRepository(), passwordEncoder());  --- (3)
    }
}
```



**(1)**: 클래스에 **@Configuration** 애너테이션을 붙여 설정 클래스를 선언한다. 설정 클래스는 여러 개 정의할 수 있다.

**(2)**: 메서드에 **@Bean** 애너테이션을 부여해서 빈을 정의한다. **메서드명이 빈의 이름이 되고** 그 빈의 인스턴스가 반환값이 된다. 이 예제에서는 `userRepository`가 빈의 이름이다. 만약 빈 이름을 다르게 명시하고 싶다면 `@Bean(name = "userRepo")`와 같이 name 속성에 빈의 이름을 재정의하면 된다.

**(3)**: 다른 컴포넌트를 참조해야 할 때는 해당 컴포넌트의 메서드를 호출한다. 의존성 주입이 프로그램적인 방법으로 처리된다.







자바 기반 설정 방식에서는 메서드에 매개변수를 추가하는 방법으로 다른 컴포넌트의 의존성을 주입할 수 있다. 단, 인수로 전달될 인스턴스에 대한 빈은 별도로 정의돼 있어야 한다.



##### **메서드의 매개변수를 통해 의존성 주입**

```java
@Bean
UserService userService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
	return new UserServiceImpl(userRepository, passwordEncoder);
}
```



**자바 기반 설정 방식만 사용해서 빈을 설정할 때는 애플리케이션에서 사용되는 모든 컴포넌트를 빈으로 정의해야 한다**. 다만 뒤에 설명할 애너테이션 기반 설정 방식과 조합하면 설정 내용의 많은 부분을 줄일 수 있다.











#### XML 기반 설정 방식

**XML 기반의 설정 방식**은 XML 파일을 이용해 빈을 설정한다. 다음 예를 살펴보자.



##### **XML 기반 설정 방식으로 빈 정의**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans
	xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    	http://www.springframework.org/schema/beans/spring-beans.xsd
    	http://www.springframework.org/schema/context
    	http://www.springframework.org/schema/context/spring-context-4.3.xsd">
    
    <bean id="userRepository" class="com.example.demo.UserRepositoryImpl" />
    <bean id="passwordEncoder" class="com.example.demo.BCryptPasswordEncoder" />
    <bean id="userService" class="com.example.demo.UserServiceImpl">
    	<constructor-arg ref="userRepository" />
    	<constructor-arg ref="passwordEncdoer" />
	</bean>
</beans>
```





**XML 기반 설정 방식**을 사용할 때도 앞의 **자바 기반 설정 방식**과 마찬가지로 XML만으로 설정하려 하면 애플리케이션에서 사용하는 모든 컴포넌트의 빈을 정의해야 하는 번거로움이 있다. 그래서 **자바 기반 설정 방식**에서와 같이 뒤에 설명할 **애너테이션 기반 설정 방식**과 조합해서 사용하는 것이 일반적이다.





참고로 **의존성 주입**에서 <u>주입할 대상이 다른 빈이 아니라 특정 값</u>인 경우, **ref** 속성을 사용하지 않고 **value** 속성을 사용한다.



##### **생성자의 인수에 빈이 아닌 특정 값 주입**

```xml
<constructor-arg value="wikibook" />
<constructor-arg value="secret" />
```


XML 파일의 **value** 속성에 문자열을 지정한다고 해서 실제 <u>자바 코드에서 그 값을 받는 타입이 반드시 문자열 타입일 필요는 없다</u>. XML 파일에는 문자열로 기재돼 있더라도 필요한 경우 DI를 하는 과정에서 숫자나 날짜 타입, 혹은 파일(File)이나 프로퍼티(Properties) 같은 여러 가지 타입으로 형변환할 수 있다. 자세한 내용은 2.3절 '데이터 바인딩과 형 변환'에서 설명한다.













#### 애너테이션 기반 설정 방식

**애너테이션 기반의 설정 방식**에서는 DI 컨테이너에 관리할 빈을 빈 설정 파일에 정의하는 대신 <u>빈을 정의하는 애너테이션을 빈의 클래스에 부여</u>하는 방식을 사용한다. 이후 이 애너테이션이 붙은 클래스를 탐색해서 DI 컨테이너에 자동으로 등록하는데 이러한 탐색 과정을 **컴포넌트 스캔(Component Scan)**이라고 한다. 또한 **의존성 주입**도 이제까지처럼 명시적으로 설정하는 것이 아니라 <u>애너테이션이 붙어 있으면 DI 컨테이너가 자동으로 필요로하는 의존 컴포넌트를 주입</u>하게 한다. 이러한 주입 과정을 **오토와이어링(Autowiring)**이라 한다.




##### **애너테이션 기반 설정 방식으로 빈 정의(UserRepositoryImpl.java)**

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
// 기타 임포트 문은 생략

@Component
public class UserRepositoryImpl implements UserRepository {
    // 생략
}
```





**애너테이션을 활용한 빈 설정(BCryptPasswordEncoder.java)**

```java
@Component
public class BCryptPasswordEncoder implements PasswordEncoder {
	// 생략
}
```



Bean 클래스에 **@Component** 애너테이션을 붙여 컴포넌트 스캔이 되도록 만든다.







**애너테이션을 활용한 빈 설정(UserServiceImpl.java)**

```java
@Component
public class UserServiceImpl implements UserService {
	@Autowired
    public UserServiceImpl(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        // 생략
    }
}
```



생성자에 **@Autowired** 애너테이션을 부여해서 **Autowiring**되도록 만든다. **Autowiring**을 사용하면 기본적으로 주입 대상과 같은 타입의 빈을 DI 컨테이너에서 찾아 **Wiring** 대상에 주입하게 된다.









컴포넌트 스캔을 수행할 때는 **스캔할 범위**를 지정해야 하는데 설정 방식으로는 **자바 기반 설정 방식**이나 **XML 기반 설정 방식**을 사용할 수 있다.




##### **자바 기반 설정 방식으로 컴포넌트 스캔 범위를 설정**

```java
import org.springframework.context.annotation.ComponentScan;
// 기타 임포트문 생략

@Configuration
@ComponentScan("com.example.demo")
public class AppConfig {
    // 생략
}
```

**컴포넌트 스캔**이 활성화되도록 클래스에 **@ComponentScan** 애너테이션을 부여한다. 애너테이션의 **value** 속성이나 **basePackages** 속성에 컴포넌트를 <u>스캔할 패키지를 지정</u>한다. 이 예제의 경우 **com.example.demo** 패키지 이하의 범위에서 클래스를 스캔하고, 스캔 대상이 되는 애너테이션이 부여된 클래스를 DI 컨테이너에 자동으로 등록한다. <u>이 속성을 생략할 경우 설정 클래스가 들어있는 패키지 이하를 스캔한다.</u>





##### **XML 기반 설정 방식으로 컴포넌트 스캔 범위를 설정**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans
	xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    	http://www.springframework.org/schema/beans/spring-beans.xsd
    	http://www.springframework.org/schema/context
    	http://www.springframework.org/schema/context/spring-context-4.3.xsd">
    
    <context:component-scan base-package="com.example.demo" />
</beans>
```


**DI 컨테이너에 등록되는 빈의 이름은 기본적으로 클래스명의 첫 글자를 소문자로 바꾼 이름과 같다.** 단, 첫 글자 이후에 대문자가 연속되는 경우에는 첫 글자를 소문자로 변환하지 않고 클래스명이 그대로 빈 이름으로 사용된다. 







만약 <u>빈 이름을 명시적으로 지정</u>하고 싶다면 **@Component** 애너테이션에 원하는 이름을 넣어주면 된다.



##### **애너테이션 기반 설정 방식에서 빈 이름 명시**

```java
@Component("userService")
public class UserServiceImpl implements UserService {
	// 생략
}
```









### 2.1.4 의존성 주입

다음은 **의존성 주입**에 대해서 알아보자. 앞서 살펴본 예에서는 생성자의 인수를 통해 의존성 주입을 했는데, 그 밖에도 두 가지 방법이 더 있어서, **총 세 가지 의존성 주입 방법**을 사용할 수 있다.



- **설정자 기반 의존성 주입 방식(setter-based dependency injection)**
- **생성자 기반 의존성 주입 방식(constructor-based dependency injection)**
- **필드 기반 의존성 주입 방식(field-based injection)**







#### 설정자 기반 의존성 주입 방식

**설정자 기반의 의존성 주입 방식**은 설정자 메서드의 인수를 통해 의존성을 주입하는 방식이다. 편의상 설정자 기반 의존성 주입 방식을 **세터 인젝션**이라고 부르자.



**세터 인젝션**은 설정자 메서드가 만들어져 있어야 사용할 수 있기 때문에 앞서 예를 든 `UserServiceImpl` 클래스를 다음과 같이 바꿔봤다.



**UserServiceImpl에 설정자 메서드 구현**

```java
public class UserServiceImpl implements UserService {
	private UserRepository userRepository;
    private PasswordEncoder passwordEncoder;
    
    // 기본 생성자(생략 가능)
    public UserServiceImpl() {
        
    }
    
    public void setUserRepository(UserRepository userRepository) {
       this.userRepository = userRepository;
    }
    
    public void setPasswordEncoder(PasswordEncoder passwordEncoder) {
        this.passwordEncoder = passwordEncoder;
    }
    
    // 생략
}
```





이와 같이 설정자 메서드가 만들어졌다면 이제 **의존성 주입**을 해보자. 우선 **세터 인젝션**을 **자바 기반 설정 방식**으로 표현한 예다.



##### **세터 인젝션을 자바 기반 설정 방식으로 표현한 예**

```java
@Bean
UserService userService() {
    UserServiceImpl userService = new UserServiceImpl();
    userService.setUserRepository(userRepository());
    userService.setPasswordEncoder(passwordEncoder());
    return userService;
}
```



설정한 내용을 살펴보면 설정자 메서드에 다른 컴포넌트의 참조 결과를 설정했을 뿐이다. 이와 조금 다른 방식으로 다음과 같이 **@Bean** 애너테이션을 붙인 메서드에 매개변수 형태로 의존 컴포넌트를 받게한 후, 그 값을 설정자 메서드를 통해 주입시켜도 된다.





##### **매개변수를 활용해 세터 인젝션을 자바 기반 설정 방식으로 표현한 예**

```java
@Bean
UserService userService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
    UserServiceImpl userService = new UserServiceImpl();
    userService.setUserRepository(userRepository);
    userService.setPasswordEncoder(passwordEncoder);
    return userService;
}
```



이처럼 **자바 기반 설정 방식**으로 **세터 인젝션**을 하는 경우, 마치 프로그램에서 인스턴스를 직접 생성하는 코드처럼 보이기 때문에 과연 이것이 빈을 정의한 설정인지 체감이 안될 수 있다.











다음은 **세터 인젝션**을 **XML 기반 설정 방식**으로 표현한 예다.



##### **세터 인젝션을 XML 기반 설정 방식으로 표현한 예**

```xml
<bean id="userService" class="com.example.demo.UserServiceImpl">
	<property name="userRepository" ref="userRepository" />
    <property name="passwordEncoder" ref="passwordEncoder" />
</bean>
```



**XML 기반 설정 방식**에서 **세터 인젝션**을 할 때는 주입할 대상을 **\<property>** 요소에 기술하는데, **\<property>** 요소의 **name** 속성에 주입할 대상의 이름을 지정하면 된다. 여기서 말하는 **프로퍼티는 자바빈즈(JavaBeans)의 프로퍼티에 해당하기 때문에 자바빈즈의 관례에 따라 프로퍼티의 이름과 메서드의 이름을 정하게 된다**. 예를 들어, 프로퍼티의 이름이 xyz라고 한다면 설정자와 접근자 메서드의 이름은 setXyz, getXyz가 된다.













다음은 **세터 인젝션**을 **애너테이션 기반 설정 방식**으로 표현한 예다.



##### **세터 인젝션을 애너테이션 기반 설정 방식으로 표현한 예**

```java
@Component
public class UserServiceImpl implements UserService {
	private UserRepository userRepository;
	private PasswordEncoder passwordEncoder;
    
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Autowired
    public void setPasswordEncoder(PasswordEncoder passwordEncoder) {
        this.passwordEncoder = passwordEncoder;
    }
}
```



이처럼 **설정자 메서드**에 **@Autowired** 애너테이션을 달아주기만 하면 된다. **애너테이션 기반의 설정 방식**을 이용하면 **자바 기반 설정 방식**이나 **XML 기반 설정 방식**과 같이 <u>별도의 설정 파일을 둘 필요가 없다</u>.







#### 생성자 기반 의존성 주입 방식

**생성자 기반 의존성 주입 방식**은 **생성자의 인수**를 사용해 의존성을 주입하는 방식이다. 이 책에서는 편의상 생성자 기반 의존성 주입 방식을 **컨스트럭터 인젝션**이라고 부르기로 한다.



**컨스트럭터 인젝션**의 예는 이미 2.1.3절 '빈 설정'에서 살펴본 적이 있다. **자바 기반 설정 방식**에서는 생성자에 의존 컴포넌트를 직접 설정하고, **XML 기반 설정 방식**에서는 **\<constructor-arg>** 요소에서 참조하는 컴포넌트를 설정한다. 그리고 **애너테이션 기반 설정 방식**에서는 생성자에 **@Autowired**를 부여한다.



생성자가 여러 개의 인자를 필요로 하는 경우 \<constructor-arg>를 여러 번 정의하면 된다. 단, 이때 인수의 순서에 주의해야 하는데, 다음과 같이 **index** 속성을 활용하면 생성자 인수의 순서를 명시적으로 지정할 수 있다.



- **컨스트럭터 인젝션을 XML 기반 설정 방식으로 표현한 예(인덱스 사용)**

```xml
<bean id="userService" class="com.example.demo.UserServiceImpl">
	<constructor-arg index="0" ref="userRepository" />
    <constructor-arg index="1" ref="passwordEncoder" />
</bean>
```



이렇게 **index** 속성을 사용하면 가독성이 좋아지고 생성자의 개수가 늘거나 줄어들 때 발생할 수 있는 실수를 쉽게 발견할 수 있다는 장점이 있다.





다른 방법으로는 **name** 속성에 인수명을 지정할 수도 있다.



- **컨스트럭터 인젝션을 XML 기반 설정 방식으로 표현한 예(인수명을 사용)**

```xml
<bean id="userService" class="com.example.demo.UserServiceImpl">
	<constructor-arg name="userRepository" ref="userRepository" />
    <constructor-arg name="passwordEncoder" ref="passwordEncoder" />
</bean>
```



**name** 속성을 활용하면 인수의 순서가 바뀌거나 추가될 때도 인덱스 순서를 매번 변경하지 않아도 되는 장점이 있다. 다만 인수명 정보는 소스코드가 컴파일되는 과정에서 없어지기 때문에 컴파일할 때 **javac** 명령과 함께 디버깅 정보를 전달할 수 있는 **-g** 옵션을 사용하거나, JDK 8 이후부터는 메서드 매개변수의 메타 정보를 생성할 수 있는 **-parameters** 옵션을 사용해야 한다. 만약 이렇게 별도의 컴파일 옵션을 주는 것이 번거롭다면 다음과 같이 **@ConstructorProperties** 애너테이션(java.beans.ConstructorProperties)을 달아주는 방법도 있다.



- **컨스트럭터 인젝션을 애너테이션 기반 설정으로 표현한 예**

```java
@ConstructorProperties({"userRepository", "passwordEncoder"})
public UserServiceImpl(UserRepository userRepository, PasswordEncoder passwordEncoder) {
    // 생략
}
```



**컨스트럭터 인젝션**을 사용하면 필드를 **final**로 선언해서 생성 후에 변경되지 않게 만들 수 있다. 이렇게 필드를 변경하지 못하도록 엄격하게 제한을 거는 것은 다른 의존성 주입 방법으로는 처리하지 못하고 오직 컨스트럭터 인젝션에서만 할 수 있다.





#### 필드 기반 의존성 주입 방식

**필드 기반 의존성 주입 방식**은 생성자나 설정자 메서드를 쓰지 않고 DI 컨테이너의 힘을 빌려 의존성을 주입하는 방식이다. 이 책에서는 편의상 필드 기반 의존성 주입 방식을 **필드 인젝션**이라고 부른다.



**필드 인젝션**을 할 때는 의존성을 주입하고 싶은 필드에 **@Autowired** 애너테이션을 달아주면 된다. **Autowiring**에 대해서는 뒤에서 자세히 설명한다. 이처럼 필드 기반 의존성 주입 방식을 사용하면 생성자나 설정자 메서드를 굳이 만들 필요가 없어지기 때문에 생성자와 설정자 메서드 작성을 생략해서 소스코드가 비교적 간결해 보이는 장점이 있다.



- **필드 인젝션을 애너테이션 기반 설정으로 표현한 예**

```java
@Component
public class UserServiceImpl implements UserService {
    @Autowired
    UserRepository userRepository;
    
    @Autowired
    PasswordEncoder passwordEncoder;
    
    // 생략
}
```



**필드 인젝션**을 사용할 때는 한 가지 <span style="color:red">주의</span>할 점이 있다. 그것은 소스코드의 양을 줄이기 위해 생성자나 설정자 메서드를 생략하고 싶다면 반드시 **DI 컨테이너**를 사용해야 한다는 것을 전제해야 한다는 것이다. 예를 들어, DI 컨테이너 없이 사용되는 독립형 라이브러리로 사용될 소스코드에서 필드 인젝션을 사용하고 있다면 잘못된 것이라고 판단해야 한다.



> **필드 인젝션**의 대상이 되는 **필드**는 어떤 **가시성(visibility)**을 가지는 것이 적절할까? 여기에는 다양한 의견이 있어 관점에 따라 판단이 달라질 수 있다. 일단 다음과 같은 관점에서 가시성을 생각해보자.
>
> - 컴포넌트의 **테스트 가능성**
> - 필드의 **은폐**
>
> 위의 관점에서 본다면 가시성을 지정하지 않은 **no modifier** 혹은 **package-private**을 사용하거나 **protected**를 사용하는 것이 적절하다. 





### 2.1.5 Autowiring

**Autowiring**은 **자바 기반 설정 방식**에서 **@Bean** 메서드를 사용하거나 **XML 기반 설정 방식**에서 **\<bean>** 요소를 사용하는 것처럼 명시적으로 빈을 정의하지 않고도 <u>DI 컨테이너에 빈을 자동으로 주입</u>하는 방식이다.



**Autowiring**에는 **타입을 이용한 방식**(autowiring by type)과 **이름을 사용한 방식**(autowiring by name)이 있다. 이제 이 두 방식에 대해 알아보자.





#### 타입으로 Autowiring하기

지금까지 소스코드에서 봐온 **@Autowired** 애너테이션은 **타입**으로 **Autowiring**하는 방식이다. 타입으로 Autowiring하는 방식은 **세터 인젝션, 컨스트럭터 인젝션, 필드 인젝션**의 세 가지 의존성 주입 방법에서 모두 활용할 수 있다. 타입으로 Autowiring 할 때는 기본적으로 <u>의존성 주입이 반드시 성공한다고 가정</u>한다. 그래서 주입할 타입에 해당하는 빈을 DI 컨테이너가 찾지 못한다면 `org.springframework.beans.factory.NoSuchBeanDefinitionException`이라는 **예외**가 발생한다.



만약 이러한 필수 조건을 완화하고 싶다면 다음과 같이 **@Autowired** 애너테이션의 **required** 속성에 **false**를 설정하면 된다. 해당 타입의 빈을 찾지 못하더라도 예외가 발생하지 않고 의존성 주입은 실패했기 때문에 해당 필드의 값은 **null**이 된다.



- **Autowiring의 필수 조건을 완화해서 필드 인젝션을 한 예(required = false)**

```java
@Component
public class UserServiceImpl implements UserService {
    
    @Autowired(required = false)
    PasswordEncoder passwordEncoder;
    
    // 생략
}
```



스프링 프레임워크 4부터는 필수 조건을 완화할 때 **required = false**를 사용하는 대신 Java SE 8부터 도입된 `java.util.Optional`을 사용할 수 있다.



- **Autowiring의 필수 조건을 완화해서 필드 인젝션을 한 예(Optional)**

```java
@Autowired
Optional<PasswordEncoder> passwordEncoder;

public void createUser(User user, String rawPassword) {
    String encodedPassword = passwordEncoder.map(x -> x.encode(rawPassword)).orElse(rawPassword);
    
    // ...
}
```



한편 타입으로 **Autowiring**을 할 때 <u>DI 컨테이너에 같은 타입의 빈이 여러 개 발견</u>된다면 그 중에서 어느 것을 사용해야 할지 알 수가 없다. 그래서 이런 경우에는 **NoUniqueBeanDefinitionException** 예외(org.springframework.beans.factory.NoUniqueBeanDefinitionException)가 발생한다. 이처럼 같은 타입의 빈이 여러 개 정의된 경우에는 **@Qualifier** 애너테이션(org.springframework.beans.factory.annotation.Qualifier)을 추가하면서 <u>빈 이름을 지정</u>하면 <u>같은 타입의 빈 중에서 원하는 빈만 선택</u>할 수 있다.





다음은 <u>같은 타입의 빈 여러 개</u>가 **자바 기반 설정 방식**으로 정의된 경우다.



- **두 개의 PasswordEncoder를 자바 기반 설정 방식으로 정의한 예**

```java
@Configuration
@ComponentScan
public class AppConfig {
    @Bean
    PasswordEncoder sha256PasswordEncoder() {
        return new Sha256PasswordEncoder();
    }
    
    @Bean
    PasswordEncoder bcryptPasswordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    // 생략
}
```



이 예에서는 **PasswordEncoder** 인터페이스를 구현한 클래스가 두 개 있는데 하나는 **SHA-256** 방식, 또 다른 하나는 **BCrypt** 방식의 알고리즘으로 구현돼 있다. 이것들은 같은 인터페이스를 구현하고 있기 때문에 **@Autowired**만으로는 빈을 구분하지 못한다. 그래서 빈의 이름을 추가로 명시할 필요가 있다. 만약 **SHA-256**을 사용하는 경우는 다음과 같이 **@Qualifier** 애너테이션을 추가하고 **sha256PasswordEncoder**라는 이름을 명시하면 된다.



- **@Qualifier를 사용해 빈 이름 명시**

```java
@Component
public class UserServiceImpl implements UserService {
    @Autowired
    @Qualifier("sha256PasswordEncoder")
    PasswordEncoder passwordEncoder;
    // 생략
}
```







한편 **자바 기반 설정 방식**에서 **@Primary** 애너테이션 (org.springframework.context.annotation.Primary)을 사용하면 **@Qualifier**를 사용하지 않았을 때 <u>우선적으로 선택될 빈을 지정</u>할 수 있다.



- **@Primary를 사용해 기본 빈을 지정**

```java
@Configuration
@ComponentScan
public class AppConfig {
    @Bean
    PasswordEncoder sha256PasswordEncoder() {
        return new Sha256PasswordEncoder();
    }
    
    @Bean
    @Primary
    PasswordEncoder bcryptPasswordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    // 생략
}
```



위 같이 설정된 상태에서 다음과 같이 **@Qualifier**를 따로 지정하지 않는 경우 **@Primary** 애너테이션이 붙은 **bcryptPasswordEncoder**가 사용된다.



- **@Primary로 지정된 빈이 선택되도록 PasswordEncoder를 사용하는 예**

```java
@Autowired
PasswordEncoder passwordEncoder;
```



만약 자바 기반 설정을 변경하지 않고 **sha256PasswordEncoder**로 교체하려면 **@Autowired**에 **@Qualifier**를 추가하고 명시적으로 **sha256PasswordEncoder**라는 이름을 지정하면 된다.



다만 **@Qualifier**로 수식하는 빈의 이름에 구현 클래스의 이름이 포함된다거나 구현과 관련된 정보가 포함돼 있다면 그 빈의 명명 방법이 바람직하다고는 볼 수 없다. 왜냐하면 결합도를 낮추기 위해 기껏 DI 방식을 채택했는데, 빈을 사용할 때 특정 구현체가 사용될 것으로 의식한 이름을 지정해 버리면 DI를 사용하는 의미가 없어진다. 이런 경우라면 DI를 아예 사용하지 않는 것이 나을 수 있다.



그렇다면 어떻게 명명하는 것이 좋을까? 이런 경우에는 빈의 이름으로 **구현체의 이름**을 쓰는 대신 **역할이나 사용 목적, 혹은 용도**를 이름으로 쓰는 것이 좋다. 앞의 예에서 같은 타입의 구현체를 여러 개 준비한 이유가 '기본적으로는 보안이 강력한 **BCrypt**를 제공하지만, 경우에 따라서는 비교적 경량인 **SHA-256**도 쓸 수 있게 하고 싶다'라는 요구사항을 반영한 것이라고 볼 수 있다. 그렇다면 **Sha256PasswordEncoder**의 빈 이름을 요구사항의 취지와 목적에 맞춰 '**lightweight**'라고 지을 수 있을 것이다.





- **SHA-256으로 구현한 PasswordEncoder의 이름을 용도에 맞게 지정한 예**

```java
@Configuration
@ComponentScan
public class AppConfig {
    
    @Bean(name = "lightweight")
    PasswordEncoder sha256PasswordEncoder() {
        return new Sha256PasswordEncoder();
    }
    
    @Bean
    @Primary
    PasswordEncoder bcryptPasswordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```



만약 패스워드를 다룰 때 처리 속도가 빠르고 부담이 적은 경량 알고리즘을 사용하고 싶다면 다음과 같이 **@Qualifier**를 설정하면 된다.



- **빈 이름이 lightweight인 PasswordEncoder를 사용하는 예**

```java
@Autowired
@Qualifier("lightweight")
PasswordEncoder passwordEncoder;
```



한편 빈의 역할이나 용도는 문자열 형태의 이름이 아닌 타입(애너테이션)으로 표현할 수도 있다. 다음은 **@Lightweight** 애너테이션을 직접 만들고 **@Qualifier** 역할을 하도록 만든 예다.



- **@Qualifier 역할을 한 @Lightweight 애너테이션의 구현 예**

```java
import org.springframework.beans.factory.annotation.Qualifier;
import java.lang.annotation.*;

@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Qualifier
public @interface Lightweight {
    
}
```



이제 **자바 기반 설정 방식**에서 경량 알고리즘을 사용하기 위해 **@Lightweight** 애너테이션을 활용해 보자.



- **직접 작성한 @Lightweight 애너테이션을 활용해 빈을 정의한 예**

```java
@Configuration
@ComponentScan
public class AppConfig {
    
    @Bean
    @Lightweight
    PasswordEncoder sha256PasswordEncoder() {
        return new Sha256PasswordEncoder();
    }
    
    @Bean
    @Primary
    PasswordEncoder bcryptPasswordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    // 생략
}
```



이 같이 정의되면 **필드 인젝션**을 할 때도 **@Lightweight**를 활용할 수 있다.



- **직접 작성한 @Lightweight 애너테이션을 활용해 필드 인젝션을 하는 예**

```java
@Autowired
@Lightweight
PasswordEncoder passwordEncoder;
```



이처럼 직접 애너테이션을 정의하는 방식은 문자열로 빈 이름을 지정하는 방식과 달리 오타가 발생하더라도 사전에 확인할 수 있고, 여러 개의 유사한 빈을 정의해야 한다면 최적의 방법이라 생각할 수 있다. 물론 앞서 설명한 것처럼 **@Sha256**과 같이 구현 정보가 직접 노출되는 애너테이션 이름은 피하는 것이 좋다.





#### 이름으로 Autowiring하기

한편 **빈의 이름**이 **필드명**이나 **프로퍼티명**과 일치할 경우에 **빈 이름**으로 **필드 인젝션**을 하는 방법도 있다. 이 방법에서는 **JSR 250** 사양을 지원하는 **@Resource** 애너테이션(javax.annotation.Resource)을 활용한다.



다음은 앞에서 설명한 **@Qualifier**의 예를 **@Resource**로 대체한 것이다.



- **@Resource 애너테이션을 활용해 필드 인젝션을 하는 예**

```java
@Component
public class UserServiceImpl implements UserService {
    @Resource(name = "sha256PasswordEncoder")
    PasswordEncoder passwordEncoder;
    // 생략
}
```



이때 **@Resource** 애너테이션의 **name** 속성을 생략할 수 있는데, **필드 인젝션**을 하는 경우에는 **필드 이름**과 같은 이름의 빈이 선택되고, **세터 인젝션**을 하는 경우에는 **프로퍼티 이름**과 같은 이름의 빈이 선택된다. 



- **@Resource 애너테이션을 활용해 필드 인젝션을 하는 예(필드 이름과 일치)**

```java
@Component
public class UserServiceImpl implements UserService {
	@Resource
    PasswordEncoder sha256PasswordEncoder;
    // 생략
}
```



- **@Resource 애너테이션을 활용해 세터 인젝션을 하는 예(프로퍼티 이름과 일치)**

```java
@Component
public class UserServiceImpl implements UserService {
    private PasswordEncoder passwordEncoder;
    
    @Resource
    public void setSha256PasswordEncoder(PasswordEncoder passwordEncoder) {
        this.passwordEncoder = passwordEncoder;
    }
}
```



만약 위의 어느 경우에도 해당되지 않으면 타입으로 Autowiring을 시도한다. **@Resource** 동작 방식은 조금 복잡한 편이라서 동작 방식을 제대로 이해한 후에 사용할 것을 권장한다. 참고로 <u>**컨스트럭터 인젝션**에서는 **@Resource** 애너테이션을 사용하지 못한다.</u>





#### 컬렉션이나 맵 타입으로 Autowiring하기

지금까지 <u>같은 인터페이스를 구현하는 빈이 여러 개 정의</u>된 경우에 **@Qualifier**와 **@Resource**를 활용해 인젝션할 대상을 한정하는 방법을 살펴봤다. 스프링 프레임워크에서는 이렇게 단 하나의 빈만 가져오는 방법 외에도 같은 인터페이스를 구현한 빈을 **컬렉션(Collection)**이나 **맵(Map)** 타입에 담아서 가져오는 방법도 제공한다. 



- **IF 인터페이스를 구현한 빈을 여러 개 정의한 예(인터페이스)**

```java
public interface IF<T> {
}

@Component
public class IntIF1 implements IF<Integer> {
}

@Component
public class IntIF2 implements IF<Integer> {
}

@Component
public class StringIF implements IF<String> {
}
```



이처럼 같은 인터페이스를 구현한 빈이 여러 개 있는 경우 Autowiring을 다음과 같은 형태로 할 수도 있다.



- **IF 인터페이스를 구현한 빈을 모두 가져오기**

```java
@Autowired
List<IF> ifList;

@Autowired
Map<String, IF> ifMAp;
```



**ifList**에는 **IntIF1, IntIF2, StringIF**와 같은 빈이 리스트 형태로 주입된다. 그리고 **ifMap**에는 '빈 이름 = 빈'과 같은 형식으로 **{intIF1 = IntIF1 빈, intIF2 = IntIF2 빈, stringIF = StringIF 빈}**이 맵 형태로 주입된다.







이제 제네릭(Generic)의 타입 파라미터에 구체적인 값을 넣어 보자.



- **IF\<Integer> 인터페이스를 구현한 빈을 모두 가져오기**

```java
@Autowired
List<IF<Integer>> ifList;

@Autowired
Map<String, IF<Integer>> ifMap;
```



이렇게 하면 주입될 빈의 타입 파라미터가 **Integer**로 한정되기 때문에 **ifList**에는 **IntIF1, IntIF2**와 같은 빈만 주입된다. 그리고 **ifMap**에는 **{intIF1 = IntIF1 빈, intIF2 = IntIF2 빈}**만 주입된다.







그렇다면 애당초 처음부터 리스트나 맵 형태로 빈을 정의해보면 어떨까? 다음 예를 살펴보자.



- **리스트와 맵 형태로 빈을 정의**

```java
@Bean
List<IF> ifList() {
	return Arrays.asList(new IntIF1(), new IntIF2(), new StringIF());
}

@Bean
Map<String, IF> ifMap() {
    Map<String, IF> map = new HashMap<>();
    map.put("intIF1", new IntIF1());
    map.put("intIF2", new IntIF2());
    map.put("stringIF", new StringIF());
    return map;
}
```



사실 이러한 방식으로 빈을 정의한 경우에는 **@Autowired** 애너테이션을 사용하더라도 실제로는 <u>Autowiring 되지 않는다</u>.



- **@Autowired 애너테이션을 이용한 필드 인젝션(인젝션 불가)**

```java
@Autowired
@Qualifier("ifList") // 인젝션 불가
List<IF> ifList;

@Autowired
@Qualifier("ifMap") // 인젝션 불가
Map<String, IF> ifMap;
```





다만 이런 경우에는 다음과 같이 **@Resource**를 사용하면 Autowiring 할 수 있다.



- **@Resource 애너테이션을 이용한 필드 인젝션(인젝션 가능)**

```java
@Resource // 인젝션 가능
List<IF> ifList;

@Resource // 인젝션 가능
Map<String, IF> ifMap;
```







### 2.1.6 컴포넌트 스캔

앞에서 잠깐 다룬 **컴포넌트 스캔(Component Scan)**은 **클래스 로더(Class Loader)**를 스캔하면서 특정 클래스를 찾은 다음, DI 컨테이너에 등록하는 방법을 말한다.





#### 기본 설정으로 컴포넌트 스캔하기

별도의 설정이 없는 기본 설정에서는 다음과 같은 애너테이션이 붙은 클래스가 탐색 대상이 되고, 탐색된 컴포넌트는 DI 컨테이너에 등록된다.

- **@Component (org.springframework.stereotype.Component)**
- **@Controller (org.springframework.stereotype.Controller)**
- **@Service (org.springframework.stereotype.Service)**
- **@Repository (org.springframework.stereotype.Repository)**
- **@Configuration (org.springframework.context.annotation.Configuration)**
- **@RestController (org.springframework.web.bind.annotation.RestController)**
- **@ControllerAdvice (org.springframework.web.bind.annotation.ControllerAdvice)**
- **@ManagedBean (javax.annotation.ManagedBean)**
- **@Named (javax.inject.Named)**



앞에서 살펴본 것처럼 
**자바 기반 설정 방식**에서는 **컴포넌트 스캔**을 하기 위해 **@ComponentScan** 애너테이션을 사용하고, 
**XML 기반 설정 방식**에서는 **\<context:component-scan>** 요소를 사용한다.

**컴포넌트 스캔**을 할 때는 **클래스 로더**에서 위와 같은 애너테이션이 붙은 클래스를 찾아야 하기 때문에 탐색 범위가 넓고 처리하는 시간도 오래 걸린다. 이 시간은 결국 스프링 프레임워크를 사용한 애플리케이션의 <u>기동 시간을 느리게 만드는 원인</u>이 되기도 한다.





예를 들어, 다음과 같이 탐색 범위를 넓게 설정하는 것은 성능 면에서 좋지 않다.



- **컴포넌트 스캔 범위가 넓은 경우**

```java
@ComponentScan(basePackages = "com")
@ComponentScan(basePackages = "com.example")
```



가능한 한 위와 같이 광범위한 범위 설정을 피해야 하는데, 통상 애플리케이션의 최상위나 한 단계 아래의 패키지까지를 스캔 대상으로 잡는 것이 적절하다.



- **컴포넌트 스캔 범위가 적절한 경우**

```java
@ComponentScan(basePackages = "com.example.demo")
@ComponentScan(basePackages = "com.example.demo.app")
```



이때 **basePackages** 속성 대신 별칭으로 **value** 속성을 써도 된다. 어느 쪽을 사용해도 스캔하는 데는 문제가 없으나, 이 속성 자체를 생략할 경우 **@ComponentScan**이 설정된 클래스가 속한 패키지부터 그 하위 패키지를 스캔한다는 것에 유의하자.





앞서 살펴본 스캔 대상 애너테이션 가운데 가장 많이 활용되는 네 가지는 다음과 같다.



**대표적인 스캔 대상 애너테이션**

| **애너테이션**  | **설명**                                                     |
| --------------- | ------------------------------------------------------------ |
| **@Controller** | MVC 패턴에서 컨트롤러 역할을 하는 컴포넌트에 붙이는 애너테이션이다. 클라이언트에서 오는 요청을 받고, 비즈니스 로직의 처리 결과를 응답으로 돌려보내는 기능을 한다. 이때 실제 비즈니스 로직은 @Service가 붙은 컴포넌트에서 처리하도록 위임한다. |
| **@Service**    | 비즈니스 로직(service)을 처리하는 컴포넌트에 붙이는 애너테이션이다. 컨트롤러에서 받은 입력 데이터를 활용해 비즈니스 로직을 실행하는 기능을 한다. 이때 영속적으로 보관해야 하는 데이터가 있다면 @Repository가 붙은 컴포넌트에서 처리하도록 위임한다. |
| **@Repository** | 영속적인 데이터 처리를 수행하는 컴포넌트에 붙이는 애너테이션이다. ORM(Object-Relational Mapping) 관련 라이브러리를 활용해 데이터의 CRUD를 처리하는 기능을 한다. |
| **@Component**  | 위의 세 경우에 해당하지 않는 컴포넌트(유틸리티 클래스나 기타 지원 클래스 등)에 붙이는 애너테이션이다. |







#### 필터를 적용한 컴포넌트 스캔

앞서 살펴본 **컴포넌트 스캔 대상** 외에도 **추가로 다른 컴포넌트를 더 포함하고 싶다면 필터를 적용**하는 방법으로 **스캔 범위를 커스터마이징**할 수 있다. 스프링 프레임워크에서는 다음과 같은 **필터**를 제공한다. 

- **애너테이션을 활용한 필터(ANNOTATION)**
- **할당 가능한 타입을 활용한 필터(ASSIGNABLE_TYPE)**
- **정규 표현식 패턴을 활용한 필터(REGEX)**
- **AspectJ 패턴을 활용한 필터**





이제 **필터**를 사용하는 몇 가지 예를 살펴보자. 필터를 추가할 때는 **includeFilters** 속성에 나열하면 된다. 다음은 할당 가능한 타입을 필터로 활용한 것으로, **자바 기반 설정 방식**으로 표현한 예다.



- **할당 가능한 타입으로 필터링(인터페이스)**

```java
public interface DomainService {
	// 생략
}
```



- **할당 가능한 타입으로 필터링(자바 기반 설정 방식)**

```java
@ComponentScan(basePackages = "com.example.demo" includeFilter = {
    @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = {DomainService.class})
})
```



이를 **XML 기반 설정 방식**으로 표현하면 다음과 같다.



- **할당 가능한 타입으로 필터링(XML 기반 설정 방식)**

```xml
<context:component-scan base-package="com.example.demo">
	<context:include-filter type="assignable" expression="com.example.demo.domain.DomainService" />
</context:component-scan>
```







다음은 **정규 표현식 패턴**을 필터로 활용한 것으로, **자바 기반 설정 방식**으로 표현한 예다.



- **정규 표현식 패턴으로 필터링(자바 기반 설정 방식)**

```java
@ComponentScan(basePackages = "com.example.demo",
             includeFilters = { @ComponentScan.Filter(type = FilterType.REGEX,
                    pattern = { ".+DomainService$" }) })
```



이를 **XML 기반 설정 방식**으로 표현하면 다음과 같다.



- **정규 표현식 패턴으로 필터링(XML 기반 설정 방식)**

```xml
<context:component-scan base-package="com.example.demo">
	<context:include-filter type="regex" expression=".+DomainService$" />
</context:component-scan>
```





여기서 <span style="color:red">한 가지 주의할 점</span>은 필터를 적용해서 컴포넌트를 스캔할 때 앞서 살펴본 **애너테이션이 붙은 스캔 대상도 함께 탐색 범위에 포함**된다는 것이다. 만약 기본 설정에서 애너테이션이 붙은 스캔 대상을 무시하고, 순수하게 필터를 적용해서 탐색되는 컴포넌트만 사용하고 싶다면 다음과 같이 **useDefaultFilters** 속성을 **false**로 설정하면 된다.



- **기본 스캔 대상을 제외하고 필터로만 스캔(자바 기반 설정 방식)**

```java
@ComponentScan(basePackages = "com.example.demo", useDefaultFilters = false,
             includeFilters = { @ComponentScan.Filter(type = FilterType.REGEX,
                    pattern = { ".+DomainService$"}) })
```



이를 **XML 기반 설정 방식**으로 표현하면 다음과 같다.



- **기본 스캔 대상을 제외하고 필터로만 스캔(XML 기반 설정 방식)**

```xml
<context:component-scan base-package="com.example.demo" use-default-filters="false">
	<context:include-filter type="regex" expression=".+DomainService$" />
</context:component-scan>
```



기본 스캔 대상에 필터를 적용해 특정 컴포넌트를 추가하는 것과 반대로, **특정 컴포넌트를 스캔 대상에서 빼고 싶을 수도 있다**. 이 경우에는 **excludeFilters** 속성을 활용한다. 예를 들어, 정규 표현식 패턴을 필터로 활용하면서 **@Exclude** 애너테이션(com.example.demo.Exclude)이 붙은 컴포넌트를 걸러내고 싶다면 다음과 같이 설정하면 된다.



- **기본 스캔 대상과 특정 컴포넌트를 제외하고 필터로만 스캔(자바 기반 설정 방식)**

```java
@ComponentScan(basePackages = "com.example.demo", useDefaultFilters = false,
             includeFilters = { @ComponentScan.Filter(type = FilterType.REGEX,
                    pattern = { ".+DomainService$" }) },
             excludeFilters = { @ComponentScan.Filter(type = FilterType.ANNOTATION,
                    pattern = { Exclude.class}) })
```



- **기본 스캔 대상과 특정 컴포넌트를 제외하고 필터로만 스캔(XML기반 설정 방식)**

```xml
<context:component-scan base-package="com.example.demo" use-default-filters="false">
	<context:include-filter type="regex" expression=".+DomainService$" />
    <context:exclude-filter type="annotation" expression="com.example.demo.Exclude" />
</context:component-scan>
```



만약 **포함(include)**하는 필터와 **제외(exclude)**하는 필터 <span style="color:red">모두에 해당하는 컴포넌트가 있는 경우</span>, **제외하는 필터가 포함하는 필터보다 우선순위가 높아 해당 컴포넌트는 스캔 대상에서 빠지고 결과적으로 DI 컨테이너에도 등록되지 않는다**.





### 2.1.7 Bean Scope

DI 컨테이너는 빈 간의 의존 관계를 관리할 뿐만 아니라 **빈의 생존 기간**도 관리한다. 빈의 생존 기간을 **빈 스코프(Bean Scope)**라고 하는데 개발자가 직접 **빈의 스코프**를 다루지 않아도 된다는 점은 DI 컨테이너를 사용하는 큰 이유이기도 하다.



만약 DI 컨테이너가 **빈의 스코프**를 관리하지 않고 의존 관계만 관리해준다고 가정해보자. 앞서 살펴본 **UserService**를 싱글턴으로 사용하고 싶다면 개발자가 직접 싱글턴 패턴을 구현해야 한다. 



조금 더 복잡한 경우를 생각해보자. 만약 단순한 싱글턴이 아니라 **HTTP 세션**이 살아 있는 동안에만 존재하는 단 하나의 인스턴스가 필요한 경우에는 어떻게 해야 할까? 이를 구현하려면 **HttpSession**의 특정 속성에 내가 찾는 인스턴스가 설정돼 있는지 확인한 후, 만약 그 인스턴스가 없다면 새로 만들어서 설정하고, 만약 그 인스턴스가 있다면 그것을 재사용하게 만들어야 한다. 문제는 이것으로만 끝나는 것이 아니다. **HttpSession**이 파괴될 때는 **HttpSessionListener**를 사용해 세션의 특정 속성에 포함된 인스턴스의 파괴 후처리를 개발자가 직접 구현해야 한다.



이러한 구현 코드는 상당히 중요한 부분이지만, 구현하고자 하는 비즈니스 관점에서는 본질과는 동떨어진 관심 밖의 내용이다. 그래서 이러한 코드가 많으면 많을수록 애플리케이션 전체를 이해하기 어려워지고 기능을 예측할 수 없게 된다.



다행히도 스프링 프레임워크에는 빈 스코프를 관리하는 기능이 있기 때문에 이런 복잡한 처리를 DI 컨테이너가 대신하도록 맡길 수 있다. <u>DI 컨테이너가 관리하는 빈은 기본적으로 **싱글턴**으로 만들어진다</u>. 그래서 **UserService**의 싱글턴 인스턴스가 필요하다면 다음과 같이 가져오면 된다.



`UserService userService = context.getBean(UserService.class);`



한편 스프링 프레임워크에서 사용 가능한 **스코프의 종류**는 다음과 같다. 이 중에는 웹 환경에서만 사용 가능한 것도 있다.



**스프링 프레임워크에서 사용 가능한 스코프**

| 스코프             | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| **singleton**      | **DI 컨테이너를 기동할 때** <u>빈 인스턴스 하나</u>가 만들어지고, 이후부터는 그 인스턴스를 공유하는 방식이다. 기본 스코프이기 때문에 별도로 스코프를 지정하지 않았다면 singleton으로 간주한다. |
| **prototype**      | DI 컨테이너에 **빈을 요청할 때마다** 새로운 빈 인스턴스가 만들어진다. 멀티 스레드 환경에서 오동작이 발생하지 않아야 하는(thread-safe) 빈이라면 singleton 스코프가 아닌 prototype을 사용해야 한다. |
| **request**        | **HTTP 요청이 들어올 때마다** 새로운 빈 인스턴스가 만들어진다. 웹 애플리케이션을 만들 때만 사용할 수 있다. |
| **session**        | **HTTP 세션이 만들어질 때마다** 새로운 빈 인스턴스가 만들어진다. 웹 애플리케이션을 만들 때만 사용할 수 있다. |
| **global session** | **포틀릿(portlet) 환경에서 글로벌 HTTP 세션이 만들어질 때마다** 새로운 빈 인스턴스가 만들어진다. 포틀릿을 사용한 웹 애플리케이션을 만들 때만 사용할 수 있다. |
| **application**    | **서블릿 컨텍스트(Servlet Context)가 만들어질 때마다** 빈 인스턴스가 만들어진다. 웹 애플리케이션을 만들 때만 사용할 수 있다. |
| **custom**         | 스코프 이름을 직접 정할 수 있고 정의한 규칙에 따라 빈 인스턴스를 만들 수 있다. |







#### 스코프 설정

DI 컨테이너에 등록된 빈은 **빈 스코프**가 **singleton**이다. 즉 DI 컨테이너에서 빈을 가져오려 할 때 같은 것이 없으면 새로 만들고, 같은 것이 있을 때는 이미 만들어진 것을 공유한다. 그리고 <u>DI 컨테이너가 파괴될 때 그 안에 있던 빈도 파괴</u>된다. 



만약 **기본 스코프**가 아닌 다른 스코프로 빈을 사용하고 싶다면 빈을 정의하는 단계에서 스코프를 명시해야 한다. **자바 기반 설정 방식**이나 **XML 기반 설정 방식**, **애너테이션 기반 설정 방식** 모두에서 설정 가능하다.





**자바 기반의 설정 방식**에서는 **@Bean** 애너테이션이 붙은 메서드에 **@Scope** 애너테이션(org.springframework.context.annotation.Scope)을 추가해서 스코프를 명시한다.



- **UserService를 prototype 스코프로 설정(자바 기반 설정 방식)**

```java
@Bean
@Scope("prototype")
UserService userService() {
	return new UserServiceImpl();
}
```



이 같이 설정된 경우, 다음의 **userService1**과 **userService2**는 서로 다른 인스턴스가 된다.



- **DI 컨테이너에서 prototype 스코프의 빈 가져오기**

```java
UserService userService1 = context.getBean(UserService.class);
UserService userService2 = context.getBean(UserService.class);
```







**XML 기반 설정 방식**에서는 **\<bean>** 요소의 **scope **속성에서 스코프를 지정할 수 있다.



- **UserService를 prototype 스코프로 설정(XML 기반 설정 방식)**

```xml
<bean id="userService" class="com.example.deom.UserServiceImpl" scope="prototype" />
```









**애너테이션 기반 설정 방식**에서는 스캔 대상이 되는 클래스에 **@Scope** 애너테이션을 추가해서 스코프를 명시한다.



- **UserService를 prototype 스코프로 설정(애너테이션 기반 설정 방식)**

```java
@Component
@Scope("prototype")
public class UserServiceImpl implements UserService {
	// 생략
}
```







#### 다른 스코프의 빈 주입

**스코프**는 **빈의 생존 기간**을 의미한다. 그래서 빈 간의 스코프가 서로 다르다는 말은 곧 각 빈의 수명이 다르다는 말이기도 하다. 예를 들어, **singleton** 스코프가 **prototype** 스코프보다 더 오래 산다. 웹 애플리케이션 환경이라면 **request < session < singleton** 순으로 뒤로 갈수록 더 오래 산다.



DI 컨테이너에서는 빈 간의 의존 관계가 형성되는데, 만약 <span style="color:red">하나의 빈이 또 다른 빈에 의존</span>하고 있다면 **DI 컨테이너에 의해 주입된 빈은 자신의 스코프와 상관없이 주입받는 빈의 스코프를 따르게 된다.**

예를 들어, **prototype** 스코프의 빈을 **singleton** 스코프의 빈에 주입한 경우를 생각해보자. 주입된 **prototype** 스코프의 빈은 자신을 주입받은 **singleton** 스코프의 빈이 살아 있는 한 DI 컨테이너에서 다시 만들 필요가 없기 때문에 결과적으로 **singleton**과 같은 수명을 살게 된다.



조금 더 구체적인 예를 들어보자. 다음은 **prototype** 스코프로 설정된 **PasswordEncoder**다. 참고로 이 빈은 멀티 스레드 환경에서 안전(thread-safe)하지 않기 때문에 반드시 요청을 받을 때마다 새로 생성하는 **prototype** 스코프로 동작해야 한다. 만약 **singleton** 스코프로 처리되어 여러 스레드가 동시에 이 빈을 이용하면 오동작을 일으킬 수 있다.



- **Prototype 스코프로 PasswordEncoder 빈 정의**

```java
@Bean
@Scope("prototype")
PasswordEncoder passwordEncoder() {
    // 멀티 스레드 환경에서 안전하지 않으므로 singleton으로 사용하면 안 됨
	return new ThreadUnsafePasswordEncoder();
}
```





다음은 이 빈을 **UserService** 빈이 사용하는 경우다. 참고로 **UserService**의 스코프는 **singleton**이다.



- **singleton 스코프인 UserService에 prototype 스코프인 PasswordEncoder 주입**

```java
@Component
public class UserServiceImpl implements UserService {
    @Autowired
    PasswordEncoder passwordEncoder;
    
    public void register(User user, String rawPassword) {
        String encodedPassword = passwordEncoder.encode(rawPassword);
        // 생략
    }
}
```



이런 구성이면 **PasswordEncoder**가 **prototype** 스코프로 정의돼 있다 하더라도 **UserService**의 스코프가 **singleton**이므로 **PasswordEncoder**는 <span style="color:red">매번 새로운 인스턴스가 만들어지지 않고 이미 만든 인스턴스를 재사용하게 된다</span>. 즉 **register** 메서드를 두 번 실행하면 같은 **PasswordEncoder** 인스턴스가 두 번 사용되는 셈이다. 이렇게 되면 굳이 **PasswordEncoder**를 **prototype** 스코프로 정의한 것이 소용없어진다. 또한 여러 스레드가 동시에 사용할 때 오동작이 발생할 수 있는 멀티 스레드에 안전하지 않은 빈이라면 반드시 **prototype** 스코프로 동작해야 한다. 그러면 이럴 때 어떻게 해야 할까?





#### 룩업 메서드 인젝션으로 해결

위 문제를 해결하는 가장 좋은 방법은 **PasswordEncoder**를 주입하지 않는 것이다. 그 대신 필요할 때마다 DI 컨테이너에서 빈을 찾아오면 된다. 우선 가장 쉬운 방법부터 살펴보자.



- **ApplicationContext에서 빈을 직접 찾아서 꺼내오기**

```java
@Component
public class UserServiceImpl implements UserService {
    @Autowired
    ApplicationContext context;
    public void register(User user, String rawPassword) {
        PasswordEncoder passwordEncoder = passwordEncoder();
        String encodedPassword = passwordEncoder.encode(rawPassword);
        
       	// 생략
    }
    
    PasswordEncoder passwordEncoder() {
        return this.context.getBean(PasswordEncoder.class);
    }
}
```



이 코드는 동작하는 데 큰 문제는 없다. 의존 관계에 있는 빈끼리 낮은 결합도를 유지하기 위해 DI 컨테이너를 사용했다. 하지만 한 가지 흠이라면 DI 컨테이너를 사용하는 과정에서 **DI 컨테이너 의존적인 클래스와 API가 소스코드 상에 노출**됐다는 것이다. 빈 간의 의존 관계는 해결했으나 **DI 컨테이너와의 의존 관계가 소스코드 상에 남았으니** 이런 방식은 사실상 <span style="color:red">바람직하지 못하며</span> 될 수 있으면 피하는 것이 좋다.



그렇다면 어떻게 해야 DI 컨테이너와 관련된 코드를 소스코드에 남기지 않고 빈을 찾아오게 만들까? DI 컨테이너에는 앞서 살펴본 **passwordEncoder** 메서드 같은 코드를 바이트코드 형태로 만드는 기능이 있다. 즉 DI 컨테이너가 빈을 **룩업(Lookup)**하는 메서드를 만든 다음, 그 메서드를 의존할 빈에게 주입하면 되는데, 이 기능을 **룩업 메서드 인젝션(Lookup Method Injection)**이라 부른다.



이 기능을 사용하려면 DI 컨테이너에게 룩업을 대행하게 하고 싶은 메서드에 **@Lookup** 애너테이션(org.springframework.beans.factory.annotation.Lookup)을 붙여주면 된다. 그러면 이 빈이 DI 컨테이너에 등록되는 시점에 DI 컨테이너에서 빈을 찾는 실제 코드가 **@Lookup** 애너테이션이 붙은 메서드 자리에 주입된다.



- **룩업 메서드 인젝션을 활용한 의존 관계 정의(애너테이션 기반 설정 방식)**

```java
@Component
public class UserServiceImpl implements UserService {
    public void register(User user, String rawPassword) {
        PasswordEncoder passwordEncoder = passwordEncoder();
        String encodedPassword = passwordEncoder.encode(rawPassword);
        // 생략
    }
    
    @Lookup
    PasswordEncoder passwordEncoder() {
        return null; // 반환값은 널이라도 상관없다.
    }
}
```





이 동작 원리를 조금 더 구체적으로 설명하자면, 우선 DI 컨테이너는 **UserServiceImpl** 클래스의 **서브 클래스**를 동적으로 만든다. 이때 DI 컨테이너는 기존의 **passwordEncoder** 메서드를 DI 컨테이너가 직접 만든 룩업 메서드로 **override**한다. 따라서 **@Lookup**을 붙인 메서드에는 **private**이나 **final**을 지정하면 안 된다. 그리고 메서드의 매개변수 역시 지정하면 안 된다. 왜냐하면 DI 컨테이너가 해당 메서드를 오버라이드하는 데 방해되기 때문이다.



그렇다면 룩업할 대상은 어떻게 찾을까? **@Lookup** 애너테이션의 **value** 속성에는 빈의 이름을 지정할 수 있다. 만약 별도의 **value** 속성을 지정하지 않았다면 그때는 메서드의 반환값 타입을 보고 룩업 대상 빈을 찾게 된다.



한편, **XML 기반 설정 방식**에서는 **\<lookup-method>** 요소를 통해 **룩업 메서드 인젝션**을 사용할 수 있다. 다음 예를 보자.



- **룩업 메서드 인젝션을 활용한 의존 관계 정의(XML 기반 설정 방식)**

```xml
<bean id="passwordEncoder" class="com.example.demo.ThreadUnsafePasswordEncoder" scope="prototype" />

<bean id="userService" class="com.example.demo.UserServiceImpl">
	<lookup-method name="passwordEncoder" bean="passwordEncoder" />
    <!-- name 속성에 룩업 메서드명을 지정하고 bean 속성에 룩업할 빈의 이름을 지정한다. -->
    <!-- 생략 -->
</bean>
```



이처럼 **룩업 메서드 인젝션**은 서로 다른 스코프의 빈을 조합하면서 생기는 문제를 해결할 뿐만 아니라 소스코드에서 직접 DI 컨테이너를 사용하는 것을 방지하는 용도로도 활용할 수 있다. 참고로 **자바 기반 설정 방식**에서는 **룩업 메서드 인젝션**을 사용하지 못한다.





#### Scoped Proxy

앞서 살펴본 것처럼 의존 관계에 있는 빈의 스코프가 다를 경우, 의도치 않은 오동작이 발생할 수 있다. 이것을 해결할 방법으로 **룩업 메서드 인젝션**을 살펴봤는데, 그 밖에도 **Scoped Proxy**라는 방법도 활용할 수 있다. 이 방법은 이름에서 짐작할 수 있듯이 기존의 빈을 **Proxy**로 감싼 후, 이 **proxy**를 다른 빈에 주입하고, 주입받은 빈에서 이 **proxy**의 메서드를 호출하면 **proxy** 내부적으로 DI 컨테이너에서 빈을 룩업하고 룩업된 빈의 메서드를 실행하는 방식이다.



이 방법은 보통 **request** 스코프나 **session** 스코프와 같이 수명이 짧은 빈을 **singleton** 스코프와 같은 상대적으로 수명이 긴 빈에 주입할 때 많이 사용한다.



구체적인 예로 앞서 살펴본 **ThreadUnsafePasswordEncoder**를 **request** 스코프로 사용하는 경우를 생각해보자. **Scoped Proxy**를 활성화할 때는 **@Scope** 애너테이션을 붙인 다음, **proxyMode** 속성에 **proxy**를 만드는 방법을 지정하면 된다.



- **Scoped Proxy 활성화(자바 기반 설정 방식)**

```java
@Bean
@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES)
PasswordEncoder passwordEncoder() {
	return new ThreadUnsafePasswordEncoder();
}
```



한편 **PasswordEncoder**를 사용하는 **UserServiceImpl**은 다음과 같다.



- **UserServiceImpl에 PasswordEncoder 주입**

```java
@Component
public class UserServiceImpl implements UserService {
    @Autowired
    PasswordEncoder passwordEncoder;
    
    public void register(User user, String rawPassword) {
        String encodedPassword = passwordEncoder.encode(rawPassword);
        // 생략
    }
}
```



**Scoped proxy**가 활성화된 상태이기 때문에 위의 **passwordEncoder** 필드에는 **PasswordEncoder**의 **Proxy**가 주입되고 **encode** 메서드가 호출될 때마다 **request** 스코프의 **PasswordEncoder** 인스턴스가 만들어진다.



**Scoped Proxy**를 사용하려면 **proxyMode** 속성에 다음 중 하나를 지정한다.

- **ScopedProxyMode.INTERFACES**: JDK의 동적 proxy(java.lang.reflect.Proxy)를 사용해 인터페이스 기반의 proxy를 만든다.
- **ScopedProxyMode.TARGET_CLASS**: 스프링 프레임워크에 내장된 CGLIB을 사용해 서브 클래스 기반의 proxy를 만든다.





> **Scoped Proxy** 방식은 proxy 모드에 따라 **인터페이스**를 기반으로 proxy를 만들거나 **서브클래스**를 기반으로 proxy를 만든다. 다음은 **인터페이스**를 기반으로 만들어진 proxy와 **서브클래스**를 기반으로 만들어진 proxy의 소스코드다. 동적으로 생성되는 만큼 반드시 이렇게 구현된다는 보장은 없지만 두 proxy 모드의 차이를 확인하기에는 충분하니 어떤 형태로 구현되는지 봐두자.
>
> 
>
> **인터페이스 기반으로 만들어진 proxy**
>
> ```java
> public class PasswordEncoderProxy implements PasswordEncoder {
>     @Autowired
>     ApplicationContext context;
>     
>     @Override
>     public String encode(String rawPassword) {
>         PasswordEncoder passwordEncoder = context.getBean("passwordEncoder", PasswordEncoder.class);
>         return passwordEncoder.encode(rawPassword);
>     }
> }
> ```
>
> 
>
> **서브클래스 기반으로 만들어진 proxy**
>
> ```java
> public class PasswordEncoderProxy extends ThreadUnsafePasswordEncoder {
>     @Autowired
>     ApplicationContext context;
>     
>     @Override
>     public String encode(String rawPassword) {
>         PasswordEncoder passwordEncoder = context.getBean("passwordEncoder", PasswordEncoder.class);
>         return passwordEncoder.encode(rawPassword);
>     }
> }
> ```
>
> 
>
> 만약 **Scoped proxy**를 적용할 대상 빈이 <u>인터페이스를 가지고 있지 않은 경우</u>에는 **서브클래스 기반의 proxy를 사용**해야 한다. 참고로 서브클래스 기반의 proxy는 메서드를 오버라이드해야 하기 때문에 메서드나 클래스에 final을 붙일 수 없다.





**XML 기반 설정 방식**으로 **Scoped Proxy**를 표현할 때는 **\<aop:scoped-proxy>** 요소를 사용한다. 그리고 **\<beans>** 요소는 aop 요소를 사용하기 위한 XML 네임스페이스(xmlns)와 스키마(xsi) 정보가 추가돼 있어야 한다.



- **XML 기반 설정 방식으로 Scoped Proxy 설정**

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/aop
           http://www.springframework.org/schema/aop/spring-aop.xsd">
    
	<bean id="passwordEncoder" class="com.example.demo.ThreadUnsafePasswordEncoder" scope="request">
    	<aop:scoped-proxy proxy-target-class="false" />    
    </bean>
    
    <!-- 
	Scoped Proxy를 적용할 빈의 <bean> 요소 아래에 <aop:scoped-proxy> 요소를 정의한다. 
	proxy-target-class 속성을 false로 지정하면 인터페이스를 기반으로 한 proxy가 만들어지고
	true인 경우에는 서브클래스 기반 proxy가 만들어진다.
	-->
    
    <bean id="userService" class="com.example.demo.UserServiceImpl">
    	<property name="passwordEncoder" ref="passwordEncoder" />
        <!-- 생략 -->
    </bean>
</beans>
```





**애너테이션 기반 설정 방식**으로 **Scoped Proxy**를 표현할 때는 스캔 대상 클래스에 붙인 **@Scope** 애너테이션에 **proxyMode** 속성을 추가하면 된다.



- **애너테이션 기반 설정 방식으로 Scoped Proxy 설정하기**

```java
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES)
public class ThreadUnsafePasswordEncoder implements PasswordEncoder {
	// 생략
}
```



스프링 프레임워크 공식 문서에서는 **request, session, globalSession** 스코프에서 **Scoped Proxy**를 사용하고, **prototype** 스코프에 대해서는 **룩업 메서드 인젝션**을 사용하도록 안내하고 있다.



**prototype** 스코프에서 **Scoped Proxy**를 사용하지 못하는 것은 아니지만, 주입된 필드에서 **Proxy** 안에 있는 메서드를 한번 더 호출하기 때문에 매번 새로운 인스턴스가 만들어질 때마다 각 프락시의 메서드가 반복해서 호출되므로 효율성 측면에서 바람직하지 않다는 점을 감안해야 한다.





#### 커스텀 스코프 만들기

스프링 프레임워크에서는 미리 만들어져서 제공되는 스코프 외에도 사용자가 직접 정의한 **커스텀 스코프(custom scope)**를 만들 수 있다. **커스텀 스코프**를 구현하려면 **Scope** 인터페이스(org.springframework.beans.factory.config.Scope)를 구현하고 **CustomScopeConfigurer** 클래스(org.springframework.beans.factory.config.CustomScopeConfigurer)에 자신이 만든 스코프를 스코프명과 함께 설정하면 된다.



다음은 **Scope** 인터페이스를 직접 구현하는 대신 스프링 프레임워크에서 제공하는 샘플 구현체를 사용한 예다. 샘플로 제공되는 **SimpleThreadScope** 클래스(org.springframework.context.support.SimpleThreadScope)를 커스텀 스코프라고 생각하고 자바 기반 설정 방식으로 어떻게 설정하는지 확인해보자.



- **커스텀 스코프 설정**

```java
@Bean
static CustomScopeConfigurer customScopeConfigurer() {
    CustomScopeConfigurer configurer = new CustomScopeConfigurer();
    configurer.addScope("thread", new SimpleThreadScope());
    return configurer;
}
```



여기까지 하고 나면 스레드 단위로 스코프를 주고 싶은 빈에 **@Scope("thread")** 애너테이션만 붙이면 된다. 그러면 DI 컨테이너에 해당 빈을 요청할 때마다 스레드 단위로 인스턴스가 만들어질 것이다.





### 2.1.8 빈의 생명주기

DI 컨테이너에서 관리되는 **빈의 생명 주기**는 크게 다음의 세 가지 단계로 구분할 수 있다.

1. **빈 초기화 단계(initialization)**
2. **빈 사용 단계(activation)**
3. **빈 종료 단계(destruction)**



위의 세 가지 단계 중 대부분의 시간은 **빈의 사용 단계**, 즉 애플리케이션이 실행 중인 상태다. 그 밖의 **빈 초기화 단계**나 **종료 단계**에서는 DI 컨테이너가 내부적으로 많은 작업을 하게 되는데 이러한 내부 동작을 이해한다면 전처리나 후처리와 같은 **콜백(callback)**을 활용할 수 있을 것이다.



#### 초기화 단계

**초기화 단계**는 다시 크게 세 개의 과정으로 나눌 수 있는데 

**첫 번째**가 **빈을 설정하는 과정**이고,

**두 번째**는 **빈을 인스턴스화하고 의존성을 주입하는 과정,**

**세 번째**는 **빈을 생성한 다음의 후처리를 하는 과정**이다.



![](https://blog.kakaocdn.net/dn/bI6CEC/btqvrC3FOqh/HV78rpCDkfqRv2ytUEci3K/img.png)



**빈 설정 정보 읽기 및 보완**

우선 빈을 생성하는 데 필요한 정보를 수집한다. **빈 정의 내용**은 **자바 기반 설정 방식**으로 **Java Configuration** 파일에서 읽어오거나, **XML 기반 설정 방식**으로 **XML** 파일에서 읽어오거나, 또는 **애너테이션 기반 설정 방식**으로 **컴포넌트 스캔**을 통해 읽어온다. 이 단계에서는 정보만 불러올 뿐 아직 빈을 생성한 것은 아니다.



빈이 정의된 설정 정보를 모두 수집했다면, 다음으로 **Bean Factory Post Processor(BFPP)**를 사용해 **빈의 정보를 보완**하는 작업이 이뤄진다. 이 처리는 **BeanFactoryPostProcessor** 인터페이스(org.springframework.beans.factory.config.BeanFactoryPostProcessor)를 구현한 클래스가 수행한다.



- **BeanFactoryPostProcessor 인터페이스**

```java
public interface BeanFactoryPostProcessor {
	void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory);
}
```



이후 2.4절 '프로퍼티 관리'에서 설명하겠지만 빈을 정의할 때 사용되는 **프로퍼티 플레이스홀더(placeholder)**는 이 시점에 실제 프로퍼티 값으로 치환된다. 마찬가지로 **BeanFactoryPostProcessor** 인터페이스를 직접 구현해서 빈으로 정의한다면 자신만의 빈 정보 보완 처리도 할 수 있다.





**빈 생성 및 의존 관계 해결**

빈 정의 정보를 읽고, 빈 인스턴스를 성공적으로 생성했다면 다음은 **빈 간의 의존관계**를 해결하기 위해 **의존성 주입**을 할 차례다. 앞서 세 가지 의존성 주입 방법을 설명했는데 실제로 수행되는 순서는 다음과 같다.

1. **생성자 기반 의존성 주입**
2. **필드 기반 의존성 주입**
3. **세터 기반 의존성 주입**







**빈 생성 후 초기화 작업**

빈 간의 의존 관계까지 정리되면 마지막으로 **빈 생성 후의 초기화 작업(Post Construct)**이 수행된다. 이 작업은 크게 **전처리, 초기화 처리, 후처리**로 구분된다. 



그 중에서도 **초기화** 부분은 다양한 설정 방식으로 정의할 수 있으며, **처리 순서**는 다음과 같다.

1. **애너테이션 기반 설정을 사용하는 경우, @PostConstruct 애너테이션(javax.annotation.PostConstruct)이 붙은 메서드**
2. **InitializingBean 인터페이스(org.springframework.beans.factory.InitializingBean)를 구현하는 경우, afterPropertiesSet 메서드**
3. **자바 기반 설정을 사용하는 경우, @Bean의 initMethod 속성에 지정한 메서드**
4. **XML 기반 설정을 사용하는 경우, \<bean> 요소의 init-method 속성에 지정한 메서드**



이렇게 빈이 생성된 후에 이뤄지는 초기화는 빈을 생성할 때 해주는 초기화와 큰 차이가 있는데, 그것은 바로 **의존성 주입이 끝난 필드 값을 초기화에 활용할 수 있다**는 점이다.



한편, **전처리**와 **후처리**는 **BeanPostProcessor(BPP)** 인터페이스(org.springframework.beans.factory.config.BeanPostProcessor)의 메서드를 통해 실행된다. 이 메서드는 다음과 같은 형태다.



- **BeanPostProcessor 인터페이스의 전처리, 후처리 메서드**

```java
public interface BeanPostProcessor {
	// 전처리
	Object postProcessBeforeInitialization(Object bean, String beanName);
    // 전처리
    Object postProcessAfterInitialization(Object bean, String beanName);
}
```



만약 빈을 **초기화**하는 과정에서 **전처리**와 **후처리**가 필요하다면 **BeanPostProcessor** 인터페이스를 구현하면서 **postProcessBeforeInitialization**과 **postProcessAfterInitialization** 메서드를 확장 지점으로 활용하면 된다.





다음은 **@PostConstruct**를 활용한 예다. 이때 **UserServiceImpl**은 **@Component** 애너테이션이 붙어 있으므로 빈 정의를 **XML** 기반으로 하는 경우에는 **\<context:annotation-config>**나 **\<context:component-scan>** 요소를 정의해야 한다. 이것은 뒤에 설명할 **@PreDestroy**에서도 마찬가지다.



- **@PostConstruct 애너테이션 활용**

```java
@Component
public class UserServiceImpl implements UserService {
	// 생략
    
    @PostConstruct
    void populateCache() {
        // 캐시 등록
    }
}
```



주의할 점은 **@PostConstruct** 애너테이션이 붙는 메서드는 반환값이 **void**이고 메서드의 매개 변수는 없어야 한다는 것이다. 이 같은 처리는 **InitializingBean** 인터페이스를 구현한 다음, **afterProperties** 메서드로 대체할 수도 있다.





- **InitializingBean 인터페이스 구현**

```java
@Component
public class UserServiceImpl implements UserService, InitializingBean {
    // 생략
    
    @Override
    public void afterPropertiesSet() {
        // 캐시 등록
    }
}
```



만약 다루려는 빈이 직접 개발한 것이 아니거나 서드파티 라이브러리 형태로 사용하고 있어서 소스코드에 **@PostConstruct** 애너테이션을 붙이거나 **InitializingBean** 인터페이스를 구현하지 못할 수도 있다. 이 경우에는 다음과 같이 빈을 정의할 때 초기화 메서드명을 지정하는 방법으로 대체할 수 있다.



- **자바 기반 설정 방식에서 초기화 메서드 지정**

```java
@Bean(initMethod = "populateCache")
UserService userService() {
	return new UserServiceImpl();
}
```



- **XML 기반 설정 방식에서 초기화 메서드 지정**

```xml
<bean id="userService" class="com.example.demo.UserServiceImpl" init-method="populateCache" />
```





#### 종료 단계

DI 컨테이너가 역할을 다하고 파괴될 때가 되면 그 안에 관리되던 빈도 역시 파괴되는 절차를 밟게 된다. 경우에 따라서는 파괴되기 전에 마지막으로 처리해야 하는 작업이 있을 수 있는데, 이를 위해 스프링 프레임워크에서는 빈이 파괴되기 전에 전처리(Pre Destroy)를 할 수 있는 방법을 제공한다.





**빈이 파괴되기 전에 전처리 수행**

빈이 파괴되기 전의 전처리(**PreDestroy**)는 빈 생성 후의 초기화(**PostConstruct**)와 동작 방식이나 구조는 대칭되면서도 내용 면에서는 정반대로 동작한다. 전처리 부분은 다양한 설정 방식으로 정의할 수 있으며, **처리 순서**는 다음과 같다.

1. **애너테이션 기반 설정을 사용하는 경우, @PreDestroy 애너테이션(javax.annotation.PreDestroy)이 붙은 메서드**
2. **DisposableBean 인터페이스(org.springframework.beans.factory.DisposableBean)를 구현하는 경우, destroy 메서드**
3. **자바 기반 설정을 사용하는 경우, @Bean의 destroyMethod 속성에 지정한 메서드**
4. **XML 기반 설정을 사용하는 경우, \<bean> 요소의 destroy-method 속성에 지정한 메서드**



**@PreDestroy**를 사용한 예는 다음과 같다.



- **@PreDestroy 애너테이션 활용** 

```java
@Component
public class UserServiceImpl implements UserService {
    // 생략
    
    @PreDestroy
    void clearCache() {
        // 캐시 삭제
    }
}
```



이 같은 처리는 **DisposableBean** 인터페이스를 구현한 다음, **destroy** 메서드로 대체할 수도 있다.



- **DisposableBean 인스턴스 구현**

```java
@Component
public class UserServiceImpl implements UserService, DisposableBean {
    // 생략
    
    @Override
    public void destroy() {
        // 캐시 삭제
    }
}
```



또한 빈을 생성한 후, 초기화할 때와 마찬가지로 다루려는 빈이 직접 개발한 것이 아니거나 서드파티 라이브러리 형태로 사용하고 있어서 소스코드에 **@PreDestroy** 애너테이션을 붙이거나 **DisposableBean** 인터페이스를 구현하지 못할 수 있다. 이 경우에는 다음과 같이 빈을 정의할 때 파괴 메서드명을 지정하는 방법으로 대체할 수 있다.



- **자바 기반 설정 방식에서 파괴 메서드 지정**

```java
@Bean(destroyMethod = "clearCache")
UserService userService() {
    return new UserServiceImpl();
}
```



- **XML 기반 설정 방식에서 파괴 메서드 지정**

```xml
<bean id="userService" class="com.example.demo.UserServiceImpl" destroy-method="clearCache" />
```



참고로 <u>빈 파괴 전의 전처리(**PreDestroy**) 작업은 **prototype** 스코프의 빈에서는 동작하지 않으므로 주의</u>하자.







**DI 컨테이너 종료**

**ConfigurableApplicationContext** 인터페이스(org.springframework.context.ConfigurableApplicationContext)는 **ApplicationContext** 인터페이스를 확장한 서브 인터페이스로, 우리가 사용하는 DI 컨테이너가 바로 **ConfigurableApplicationContext** 인터페이스의 구현체다. 이 인터페이스에는 **close**라는 메서드가 있는데 이것을 호출하면 DI 컨테이너가 종료된다. 대부분의 경우, 직접 DI 컨테이너를 종료할 일은 없지만 굳이 프로그램적으로 종료시키고 싶다면 다음과 같이 구현한다.



- **DI 컨테이너 종료**

```java
ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
// 애플리케이션 코드
context.close();
```



**ConfigurableApplicationContext**는 **java.io.Closeable** 인터페이스를 구현하고 있으므로 다음과 같이 **try-with-resources** 구문으로 기술할 수도 있다.



- **try-with-resources 구문을 활용한 DI 컨테이너 종료**

```java
try (ConfigurableApplicationContext context = 
    new AnnotationConfigApplicationContext(AppConfig.class)) {
    // 애플리케이션 코드
}
```



명시적으로 **close**를 호출해서 닫기가 곤란한 경우에는 다음과 같이 **JVM**을 종료(Shutdown)할 때 함께 종료되도록 **훅(Hook)**으로 등록할 수 있다.



- **JVM 셧다운 시 DI 컨테이너를 종료하도록 훅 등록**

```java
ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
context.registerShutdownHook();
```







### 2.1.9 빈 설정 분할

DI 컨테이너에서 관리하는 빈이 많아지면 많아질수록 설정 내용도 많아져서 관리하기가 어려워진다. 이럴 때는 **빈 설정 범위**를 명확히 하고 가독성도 높이기 위해 **목적에 맞게 분할**하는 것이 좋다.



#### 자바 기반 설정의 분할

**자바 기반 설정 방식**에서 설정된 내용(**Configuration Class**)을 분할할 때는 **@Import** 애너테이션(org.springframework.context.annotation.Import)을 사용한다. 다음은 **AppConfig** 클래스의 빈 정의 내용을 **DomainConfig** 클래스와 **InfrastructureConfig** 클래스에 나눠서 분할한 예다.



- **분할한 설정 클래스를 임포트하는 대표 설정 클래스(AppConfig.java)**

```java
@Configuration
@Import({DomainConfig.class, InfrastructureConfig.class})
public class AppConfig {
    /* DomainConfig.class와 InfrastructureConfig.class에 정의한 빈을 주입할 수 있다. */
}
```



- **분할된 설정 클래스(DomainConfig.java)**

```java
@Configuration
public class DomainConfig {
    @Bean
    UserService userService() {
        // 생략
    }
}
```



- **분할된 설정 클래스(InfrastructureConfig.java)**

```java
@Configuration
public class InfrastructureConfig {
    @Bean
    DataSource dataSource() {
        // 생략
    }
}
```







#### XML 기반 설정의 분할

**XML 기반 설정 방식**에서 XML 설정 파일을 분할할 때는 **\<import>** 요소를 사용한다. 다음 예제에서는 **app-config.xml**의 빈 정의 내용을 **domain-config.xml** 파일과 **infra-config.xml** 파일에 나눠서 분할한다.



- **분할한 XML 파일을 임포트하는 대표 XML 파일(app-config.xml)**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <import resource="classpath:conf/domain-config.xml" />
    <import resource="classpath:conf/infra-config.xml" />
    <!--
	domain-config.xml과 infra-config.xml에 정의된 빈을 참조할 수 있다.
	-->
</beans>
```



- **분할된 XML 파일(domain-config.xml)**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <bean id="userService" class="..." />
</beans>
```



- **분할된 XML 파일(infra-config.xml)**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <bean id="dataSource" class="..." />
</beans>
```







### 2.1.10 프로파일별 설정 구성

스프링 프레임워크에서는 설정 파일을 특정 환경이나 목적에 맞게 선택적으로 사용할 수 있도록 그룹화할 수 있으며, 이 기능을 **프로파일(profile)**이라고 한다. 예를 들어, 애플리케이션이 실행될 환경마다 서로 다른 프로파일을 만든다면 
개발 환경을 위한 **development** 프로파일,
검증 환경을 위한 **staging** 프로파일,
실제 운영 환경을 위한 **production** 프로파일 등을 만들 수 있을 것이다.



#### 프로파일 정의

**자바 기반 설정 방식**에서 **프로파일**을 지정할 때는 **@Profile** 애너테이션(org.springframework.context.annotation.Profile)을 사용한다.



- **자바 기반 설정 방식에서의 프로파일 정의**

```java
@Configuration
@Profile("development")
public class DevelopmentConfig {
    // 생략
}

@Configuration
@Profile("staging")
public class StagingConfig {
    // 생략
}

@Configuration 
@Profile("production") 
public class ProductionConfig {
    // 생략
}
```



한편, **클래스 레벨**이 아니라 **메서드 레벨**로 적용 범위를 좁힐 수도 있다.



- **자바 기반 설정 방식에서 메서드 레벨로 프로파일 정의**

```java
@Configuration
public class AppConfig {
	
    @Bean(name = "dataSource")
    @Profile("development")
    DataSource dataSourceForDevelopment() {
        // 생략
    }
    
    @Bean(name = "dataSource")
    @Profile("staging")
    DataSource dataSourceForStaging() {
        // 생략
    }
    
    @Bean(name = "dataSource") 
    @Profile("production")
    DataSource dataSourceForProduction() {
        // 생략
    }
}
```



**@Profile** 애너테이션에서는 **@Profile({"development", "staging"})**처럼 여러 개의 프로파일을 지정하거나 **production** 프로파일만 제외한다는 의미로 **@Profile("!production")**과 같이 부정형으로 표현할 수도 있다. 이렇게 프로파일을 개발 환경별로 구분하는 방식은 개발이 어느 정도 진행된 다음에 다른 개발 환경으로 쉽게 옮겨갈 수 있게 해주는 유용한 기법이다.



한편 **XML 기반 설정 방식**에서는 **\<beans>** 요소의 **profile** 속성을 활용한다. 다음 예는 프로파일별로 하나의 XML 설정 파일을 사용한 예다.



- **XML 기반 설정 방식에서의 프로파일 정의(XML 파일 하나에 하나의 프로파일)**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans.xsd"
       profile="development">
    
    <!-- 이 안에서 정의한 내용은 지정한 프로파일 내에서만 유효하다. -->
</beans>
```



만약 하나의 XML 안에 다른 프로파일도 함께 정의하고 싶다면 다음과 같이 **\<beans>** 요소를 중첩해서 **profile** 속성을 지정하면 된다.



- **XML 기반 설정 방식에서의 프로파일 정의(XML 파일 하나에 여러 개의 프로파일)**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <beans profile="development">
    	<!-- 이 안에서 정의한 내용은 development 프로파일 내에서만 유효하다. -->
        <bean id="dataSource" class="...">
        	<!-- 생략 -->
        </bean>
    </beans>
    
    <beans profile="staging">
    	<!-- 이 안에서 정의한 내용은 staging 프로파일 내에서만 유효하다. -->
        <bean id="dataSource" class="...">
        	<!-- 생략 -->
        </bean>
    </beans>
    
    <beans profile="production">
    	<!-- 이 안에서 정의한 내용은 production 프로파일 내에서만 유효하다. -->
        <bean id="dataSource" class="...">
        	<!-- 생략 -->
        </bean>
    </beans>
    
</beans>
```



여러 프로파일을 동시에 지정하고 싶다면 **profile="프로파일1, 프로파일2"**와 같이 쉼표로 구분해서 나열할 수 있다.



한편, **애너테이션 기반 설정 방식**에서는 다음과 같이 **@Profile** 애너테이션에 프로파일을 지정할 수 있다.



- **애너테이션 기반 설정 방식에서의 프로파일 정의**

```java
@Component
@Profile("staging")
public class DummyUserRepository implements UserRepository {
    // 생략
}
```



만약 프로파일이 별도로 지정되지 않은 빈 설정이 있다면 이것들은 모든 프로파일에서 사용 가능하다고 보면 된다.





#### 프로파일 선택

앞서 프로파일별로 설정을 정리했다면 이제는 실행 시 어떤 프로파일을 선택해야 할지 알려줄 차례다. 이 정보는 자바의 시스템 프로퍼티를 통해 전달할 수 있는데, 자바 애플리케이션을 실행할 때 명령행 옵션으로 **spring.profiles.active**라는 프로퍼티 값과 사용할 프로파일 이름을 지정하면 된다.



- **자바 명령행 옵션으로 프로파일을 지정하는 방법**

```
-Dspring.profiles.active=production
```



만약 프로파일을 여러 개 선택하고 싶으면 쉼표로 구분해서 나열할 수 있다. 자바 명령행 옵션으로 전달하는 방법 외에도 **환경 변수**를 이용할 수도 있는데 환경 변수명 **SPRING_PROFILES_ACTIVE**에 사용할 프로파일 이름을 지정하면 된다.



- **환경 변수로 프로파일을 지정하는 방법**

```
export SPRING_PROFILES_ACTIVE=production
```



웹 애플리케이션에서는 웹 애플리케이션 설정 파일(**Web Application Deployment Descriptor**)인 **web.xml**에 다음과 같이 지정한다.



- **web.xml에 프로파일을 지정하는 방법**

```xml
<context-param>
	<param-name>spring.profiles.active</param-name>
    <param-value>production</param-value>
</context-param>
```



**spring.profiles.active**를 따로 지정하지 않았다면 기본값으로 **spring.profiles.default**에서 지정된 프로파일을 사용한다. 웹 애플리케이션이라면 위와 같이 **web.xml**에 **spring.profiles.default**를 설정해서 기본 프로파일을 지정한 다음 프로파일을 바꾸고 싶을 때만 자바 명령행 옵션으로 **spring.profiles.active**를 지정해 기본 프로파일을 덮어쓰면 된다.





### 2.1.11 JSR 330

(생략)





















