# [웹을 지탱하는 기술 1부 - 웹 개론] Chapter 03 REST 웹의 아키텍처 스타일

**목표**

- 웹의 설계사상인 REST에 대해서 설명한다.





## 1. 아키텍처 스타일의 중요성

- REST는 웹의 아키텍처 스타일이다.
- 아키텍처 스타일은 '(매크로)아키텍처 패턴'이라고도 하며, 복수의 아키텍처의 공통된 성질, 양식, 규정 혹은 독특한 방식을 가리키는 말이다.
  - 아키텍처 스타일에는 MVC와 파이프 앤 필터, 이벤트 시스템 등이 있다.
- 패턴이라는 말에서 디자인 패턴을 상상할지도 모르지만, 소위 디자인 패턴은 '마이크로 아키텍처 패턴'이라고도 하며, 아키텍처 스타일보다 입도(Granuality)가 작은 클래스 등의 설계양식을 가리킨다.
- 디자인과 디자인 패턴이 다르듯이, 아키텍처와 아키텍처 스타일은 별개다.
  - 디자인 패턴 책에는 소프트웨어의 설계 자체는 나와있지 않다. 우리들은 책에 쓰여 있는 패턴을 학습하고, 그 패턴을 자신의 소프트웨어 설계에 적용한다.
  - 아키텍처 스타일도 마찬가지다. 실제 시스템은 구체적인 아키텍처를 가지고 있다. 그 아키텍처를 설계할 때, 아키텍처 설계 지침, 규정, 방식 즉, 아키텍처 스타일을 적용하는 것이다.





## 2. 아키텍처 스타일로서의 REST

- REST는 수많은 아키텍처 스타일 중에서도, 특히 네트워크 시스템의 아키텍처 스타일이다.
- 네트워크 시스템의 아키텍처 스타일로서 가장 유명한 것은 **클라이언트/서버**다.
  - 그리고 웹은 클라이언트/서버이기도 하다.
- 즉, 웹의 아키텍처 스타일은 REST이기도 하지만, 클라이언트/서버이기도 하다. (이게 대체 무슨 말이냐??)
  - 사실은 REST는 클라이언트 서버 구조에서 파생된 아키텍처 스타일이다.
  - 순수한 클라이언트/서버 아키텍처 스타일에 몇 가지 **제약**을 더해가면, REST라는 아키텍처 스타일이 된다.

- 제약은 아키텍처 스타일에 있어서 중요한 개념이다.
  - 일반적으로 소프트웨어 아키텍처는 복수의 컴포넌트를 조합해 구현하는데, 각각의 컴포넌트가 따로따로 움직여서는 동작하지 않는다.
  - 그래서 각 컴포넌트에 제약을 부과해 간다. 그 결과, 전체적으로 각 컴포넌트가 협력하면서 동작할 수 있게 되는 것이다.
- 아키텍처 스타일은 특정한 구현이나 아키텍처가 아니라는 점을 유의해야 한다.
  - 웹의 아키텍처와 구현은 REST 아키텍처 스타일을 따르고 있지만, 웹 이외의 아키텍처와 구현도 생각해 볼 수 있다.
  - 구현에서 추상도를 한 단계 올린 것이 아키텍처이고, 아키텍처에서 추상도를 한 단계 더 올린 것이 아키텍처 스타일이다.
  - 다만, 현실적으로 REST라고 하면 웹의 아키텍처 스타일을 가리키는 경우가 많기 때문에 앞으로는 REST의 구현 예로 웹을 이용하겠다.
- REST는 웹 전체의 아키텍처 스타일이기도 하며, 개별 웹 서비스와 웹 API의 아키텍처 스타일이기도 하다.





**웹의 아키텍처 스타일과 아키텍처와 구현**

| 추상화 레벨     | 웹에서의 예                                |
| --------------- | ------------------------------------------ |
| 아키텍처 스타일 | REST                                       |
| 아키텍처        | 브라우저, 서버, 프록시, HTTP, URI, HTML    |
| 구현            | Apache, Firefox, Internet Explorer, Chrome |







## 3. 리소스

REST에 있어서 중요한 개념의 하나로 리소스(Resource)가 있다.

REST를 이해하기 위해서는 리소스에 대한 이해가 필요하다.



- 리소스란?
  - 웹 상에 존재하는 이름을 가진 모든 정보
  - '이름을 가진'의 의미?
    - 사물의 이름&middot;명사에는 그 자신과 다른 대상을 구별하여 가리키는 역할이 있다.
    - 필자의 이름인 '야마모토 요헤이'는 필자 자신을 다른 사람과 구별한다.
    - 물론, 동명이인인 야마모토 요헤이가 그밖에도 존재하지만, 사람의 경우는 이 정도는 모호해도 구별할 수 있다.
    - 하지만 프로그램의 경우엔 동명이인을 구별하지 못하기 때문에, 반드시 이름으로 다른 것과 구별하지 않으면 안 된다.
    - **리소스의 이름은 어떤 리소스를 다른 리소스와 구별하기 위한 것이다.**

- 리소스의 예
  - 서울의 일기예보
  - 멘토르 출판사의 '웹을 지탱하는 기술' 페이지
  - 청량리역의 사진
  - Dijkstra의 논문 'Go To Statement Considered Harmful'
  - 필자의 최근 북마크





### 리소스 명칭으로서의 URI

위에서 말한 리소스의 이름이란 URI를 말한다.

앞에서 본 예시를 생각해 보자.

좀 전의 리소스는 각각 다음과 같은 URI로 식별할 수 있다.



- 리소스와 URI
  - 서울의 일기예보 (리소스)
    - http://weather.naver.com/rgn/cityWetrWarea.ngn (URI)
  - 멘토르 출판사의 '웹을 지탱하는 기술' 페이지 (리소스)
    - http://mentorbooks.dothome.co.kr/IT/4864 (URI)





**정리**

- 리소스란 웹 상의 정보이다.
- 전 세계의 무수한 리소스는 각각 URI로 의미있는 이름을 가진다.
- URI를 이용함으로써, 프로그램은 리소스가 표현하는 정보에 접근할 수 있다.





### 복수의 URI를 가진 리소스

- 1개의 리소스는 복수의 URI를 가질 수 있다.
  - 예를 들어, 오늘이 2011년 1월 1일이면, 다음 2개의 URI는 같은 리소스를 가리킨다.
  - http://weather.example.com/seoul/today
  - http://weather.example.com/seoul/2011-01-01
  - 2011년 1월 1일 시점에서는 이 2개의 URI는 같은 리소스를 가리키지만, 각 URI의 의미는 다르다.
  - 첫 번째 예는 '오늘의 서울 날씨'를 가리키는 URI이고, 두 번째 예는 '2011년 1월 1일의 서울 날씨'를 가리키는 URI이기 때문이다.
  - 첫 번째 URI 'http://weather.example.com/seoul/today'는 날짜가 바뀌면 가리키는 리소스가 변화한다.
- 하나의 리소스에 URI를 여러 개 붙여 두면, 클라이언트가 리소스에 접근하기 쉬워진다. 그 반면, 어느 것이 정식 URI인지 알기 힘들다는 결점도 동시에 가지게 된다.





### 리소스의 표현과 상태

- 리소스는 '웹 상에 존재하는 정보'라는 추상적인 개념이다.
- 서버와 클라이언트 간에 실제로 리소스를 주고 받을 때는 어떤 구체적인 데이터를 서로 송신한다.
  - 서버와 클라이언트 사이에 주고받는 데이터를 'Resource Representation'이라고 부른다.
- **하나의 리소스는 복수의 표현**을 가질 수 있다.
  - 예를 들어, 일기 예보 리소스는 HTML 형식은 물론, 텍스트 형식이나 PDF 또는 이미지로도 표현할 수 있습니다.
  - 리소스의 복수 표현에 개별 URI를 부여해도 좋고, HTTP 구조를 이용해 하나의 URI로 복수 표현을 반환할 수도 있습니다.
- 또한, 리소스에는 '**상태**'라는 것이 있는데, 시간의 경과에 따라 리소스의 상태가 변하면 그 표현도 변합니다.
  - 일기 예보의 예를 보면, 현재의 예보가 '맑음'이라도 몇 시간 후에는 '흐림'으로 상태가 변할 수도 있습니다.







## 4. 스타일을 조합하여 REST를 구성한다.

이제부터는 REST 아키텍처 스타일이 과연 어떻게 구성되어 있는지 살펴볼 것입니다.

REST는 복수의 아키텍처 스타일을 조합하여 구축한 복합 아키텍처 스타일입니다.

이제부터 클라이언트/서버 이외의 아키텍처 스타일을 추가하고 제약을 부과하면서, REST를 구축해 나가겠습니다.



### 클라이언트/서버

- 웹은 HTTP라는 프로토콜을 이용해 클라이언트와 서버가 서로 통신하는 **클라이언트/서버**의 아키텍처 스타일을 채용하고 있다.
  - 즉, 클라이언트가 서버에 요청(Request)를 보내면, 서버는 클라이언트에 대해 응답(Response)를 돌려준다.
- 특징
  - 단일 컴퓨터 상에서 모든 것을 처리하는 것이 아니라, 클라이언트와 서버로 분리해서 처리할 수 있다.
  - 이렇게 되면, 클라이언트를 멀티 플랫폼으로 구성할 수 있게 된다.
    - PC뿐만 아니라 휴대전화, 게임기를 통해서도 웹에 접속할 수 있다.
  - 유저 인터페이스는 클라이언트에서 담당하기 때문에 서버는 데이터 스토리지로서의 기능만을 제공하면 된다.
  - 복수의 서버를 조합해 확장함으로써 가용성을 올릴 수 있다.





![](https://docs.google.com/drawings/d/syEfYtazF_c9NIha6dQxmDw/image?parent=e/2PACX-1vQiuXMoUJloXB41go11kimhAxCGB0Jhf5sdczvyrPIjH533basHPtLBcGPi59BcshFWUj6e55GqbGOO&rev=111&drawingRevisionAccessToken=n6a7ufx5FhX13w&h=124&w=601&ac=1)





### 스테이트리스 서버 (Stateless Server)

클라이언트/서버에 최초로 추가할 아키텍처 스타일은 Stateless Server입니다.

여기서 말하는 Stateless란, 클라이언트의 애플리케이션 상태를 서버에서 관리하지 않는다는 것을 의미합니다.



- Stateless 서버의 특징
  - 서버가 클라이언트의 애플리케이션 상태를 가지지 않게 되면, 그만큼 서버 측의 구현을 간략화 할 수 있다.
  - 간략하게 구현된 서버는 클라이언트로부터의 요청에 응답한 뒤 바로 서버의 자원을 해제할 수 있다.

- 하지만 현실적으로는 Stateless가 아닌 웹 서비스와 웹 API가 많이 존재한다.

  - 특히 HTTP를 Stateful하게 만드는 대표적인 예시는 Cookie를 사용한 세션 관리이다.

    - REST 관점에서 본다면, Cookie를 사용한 세션 관리는 HTTP의 잘못된 확장이다.

    - 다만, REST의 기준으로 잘못되었다고 해서, Cookie를 사용한 폼 인증을 그만둘 수 없는 것도 현실이다.
    - Cookie는 Stateless Server의 이점을 버린다는 것을 이해한 후에 최소한으로 이용하도록 하자.

- 클라이언트/서버에 Stateless성을 도입하면, 아키텍처 스타일은 'Client/Stateless Server'가 된다.





![](https://docs.google.com/drawings/d/s0jxRcO7WCSGA_qYmxPBDCQ/image?parent=e/2PACX-1vQiuXMoUJloXB41go11kimhAxCGB0Jhf5sdczvyrPIjH533basHPtLBcGPi59BcshFWUj6e55GqbGOO&rev=178&drawingRevisionAccessToken=OgmqIOv8yFtn4A&h=224&w=601&ac=1)





### 캐시 (Cache)

다음 아키텍처 스타일은 캐시다.



- 캐시란?
  - 리소스의 신선도에 기초해, 한번 가져온 리소스를 클라이언트 쪽에서 돌려쓰는 방식이다.
- 캐시의 특징
  - 장점
    - 서버와 클라이언트 사이의 통신량을 줄여 네트워크 대역의 이용과 처리시간을 축소하고, 더욱 효율적으로 처리할 수 있다.
  - 단점
    - 오래된 캐시를 이용해 정보의 신뢰성이 떨어질 수 있다.

- 캐시를 추가한 아키텍처 스타일은 'Client/Cache/Stateless Server'라고 한다.





![](https://docs.google.com/drawings/d/sPEOumMx9oW_ViMb671qGeQ/image?parent=e/2PACX-1vQiuXMoUJloXB41go11kimhAxCGB0Jhf5sdczvyrPIjH533basHPtLBcGPi59BcshFWUj6e55GqbGOO&rev=161&drawingRevisionAccessToken=QPVFfCo9H3aF1A&h=224&w=601&ac=1)





### 유니폼 인터페이스

다음으로 살펴볼 아키텍처 스타일은 유니폼 인터페이스(Uniform Interface)이다.



- 유니폼 인터페이스란?
  - URI로 지정한 <u>리소스에 대한 조작을 통일되고 한정적인 인터페이스</u>로 수행하는 아키텍처 스타일
- 특징
  - HTTP 1.1에서는 GET과 POST 등 8개의 메서드만 정의되어 있고, 보통은 이 이상 늘어나지 않는다.
  - 메서드가 8개로 고정되어 확장할 수 없는 것은 일반적인 프로그래밍 언어의 기준에서 생각할 때 아주 엄격한 제약으로 느껴지지만, 인터페이스의 유연성에 제약을 가함으로써 전체적인 아키텍처가 간결해진다.
  - 또한 인터페이스를 통일함으로써 클라이언트와 서버 구현의 중립성이 향상된다.
- 유니폼 인터페이스는 REST를 가장 특징짓는 아키텍처 스타일이다.

- 유니폼 인터페이스를 추가한 아키텍처 스타일을 'Uniform Client Cache Stateless Server'라고 한다.





![](https://docs.google.com/drawings/d/sOyj1qIktmH4oo4MUWUQheQ/image?parent=e/2PACX-1vQiuXMoUJloXB41go11kimhAxCGB0Jhf5sdczvyrPIjH533basHPtLBcGPi59BcshFWUj6e55GqbGOO&rev=83&drawingRevisionAccessToken=cBkZrTygUFVw9g&h=224&w=601&ac=1)





### 계층화 시스템

유니폼 인터페이스의 이점 가운데 하나로, 시스템 전체를 계층화하기 쉽다는 점을 들 수 있다.



- 계층화 시스템
  - 예를 들면, 웹 서비스에서는 서버와 클라이언트 간의 로드 밸런서 (Load Balancer)를 설치해 부하를 분산시키거나, 프록시 (Proxy)를 설치해 액세스를 제어합니다.
  - 클라이언트 측에서 보면, 서버나 프록시 모두 동일한 인터페이스로 접속할 수 있기 때문에 접속할 곳이 서버에서 프록시로 바뀐 것을 신경 쓸 필요가 없습니다. 
  - 이것은 서버와 프록시 등 각 컴포넌트 간의 인터페이스를 HTTP로 통일하고 있기에 실현될 수 있었습니다.

- 이와 같이 시스템을 몇 개의 계층으로 분리하는 아키텍처 스타일을 계층화 시스템 (Layered System)이라고 합니다.

- 계층화 시스템을 추가한 아키텍처 스타일을 'Uniform Layered Client Cache Stateless Server'라고 부릅니다.





![](https://docs.google.com/drawings/d/sP8WQfYayXo0wpU7z_tYRtg/image?parent=e/2PACX-1vQiuXMoUJloXB41go11kimhAxCGB0Jhf5sdczvyrPIjH533basHPtLBcGPi59BcshFWUj6e55GqbGOO&rev=216&drawingRevisionAccessToken=fUrRslM4xfCeQw&h=327&w=601&ac=1)





### 코드 온 디맨드 (Code On Demand)

- 코드 온 디맨드란?
  - 프로그램 코드를 서버에서 다운받아 클라이언트에서 실행하는 아키텍처 스타일입니다.
  - 예를 들어, JavaScript나 Flash 등이 여기에 해당합니다.
- 코드 온 디맨드의 특징
  - 장점
    - 클라이언트를 차후에 확장할 수 있다는 점
    - 클라이언트 프로그램에 미리 준비해 둔 기능뿐만 아니라, 새로운 기능을 계속 추가할 수 있다.
  - 단점
    - 네트워크 통신에서의 프로토콜 가시성이 저하된다.
    - HTTP라는 애플리케이션 프로토콜에 따라 통신하고 있는 동안은 통신의 의미와 접근할 리소스가 명백하다.
    - 그러나 코드 온 디맨드로 프로그램을 다운로드하여 클라이언트에서 실행해 버리면 애플리케이션 프로토콜의 가시성은 저하된다.
- 코드 온 디맨드를 추가한 아키텍처 스타일을 'Uniform Layered Code on Demand Client Cache Stateless Server'라고 한다.





![](https://docs.google.com/drawings/d/s4o5-BGz9gr8ksGITS80VFw/image?parent=e/2PACX-1vQiuXMoUJloXB41go11kimhAxCGB0Jhf5sdczvyrPIjH533basHPtLBcGPi59BcshFWUj6e55GqbGOO&rev=97&drawingRevisionAccessToken=zRKD2KpyZA5TAg&h=415&w=601&ac=1)





### REST = Uniform Layered Code on Demand Client Cache Stateless Server

- 앞에서 살펴본 아키텍처 스타일들을 모두 합쳐 놓은 것이 REST 스타일이다.
- 약자로 ULCODC$SS라고도 한다.



**정리**

- Client/Server: User Interface와 처리를 분리한다.
- Stateless Server: 서버 측에서 애플리케이션의 상태를 가지지 않는다.
- Cache: 클라이언트와 서버의 통신횟수와 양을 감소시킨다.
- Uniform Interface: 인터페이스를 고정한다.
- Layered System: 시스템을 계층별로 분리한다.
- Code on Demand: 프로그램을 클라이언트에 다운로드하여 실행한다.



- REST는 아키텍처 스타일이므로 실제로 시스템을 설계할 때는 그 시스템의 아키텍처를 만들어야만 한다.
- 이때, REST에 기초한 아키텍처를 구축할 경우라도 REST를 구성하는 스타일 중 몇 가지를 제외하더라도 상관없다.
  - 예를 들어, 쿠키 정보 등을 통해 세션에 값을 저장하도록 하여 Stateful하지만, URI 형식 등은 REST의 제약에 따르는 아키텍처도 생각해 볼 수 있다.







## 5. REST의 2가지 측면

지금까지 REST의 특징을 하나씩 소개했다.

이번에는 REST와 하이퍼미디어, REST와 분산 시스템의 관계를 살펴봄으로써, 

하이퍼미디어가 REST에 어떻게 영향을 미치고 있는지, 웹이 어째서 세계 규모의 분산 시스템으로서 성공했는지를 살펴보자.





### REST와 하이퍼미디어

- 보통 우리들이 웹을 사용할 때는 링크를 따라가면서 다양한 리소스에 접근하게 된다.
  - 예를 들어, 소셜 북마크 서비스라면 자신의 북마크를 열람하고, 즐겨 찾는 유저의 북마크로 가거나, 마음에 드는 북마크를 자신의 북마크로 복사하는 작업들을 하게 된다.
  - 위의 일련의 작업들의 최소 단위는 '웹 상의 리소스들이 가지는 링크를 따라가는' 것이다.
  - <u>하이퍼미디어의 기본 기능인 링크를 따라가는 작업을 몇 번 거치면서 전체적으로는 소셜 북마크라는 하나의 애플리케이션이 실현된다.</u>
  - 웹이 가진 이 특징을 REST에서는 **애플리케이션 상태 엔진으로서의 하이퍼미디어** (Hypermedia as the engine of application state)라고 한다.
- 애플리케이션 상태
  - 애플리케이션 상태란, 예를 들어 소셜 북마크 애플리케이션의 이용자가 가지는 상태를 말한다. 
  - '북마크 목록을 표시하고 있다', '새로운 북마크를 추가하고 있다' 등이 상태의 구체적인 예다.
  - 애플리케이션 상태는 하이퍼미디어의 링크를 따라가는 작업에 의해 변화한다.
  - 이것이 <u>하이퍼미디어가 애플리케이션 상태 엔진</u>이라고 불리는 까닭이다.

- 이러한 하이퍼미디어를 이용한 애플리케이션에는 리소스의 URI만 알면 어떤 애플리케이션이 제공하고 있는 **리소스를 다른 애플리케이션에서도 간단히 재사용**할 수 있다는 장점이 있다.
  - 소셜 북마크의 예로 말하자면, 뉴스 사이트나 개발자용 도큐먼트 같은 다른 목적의 애플리케이션 리소스를 북마크 함으로써 리소스의 URI를 소셜 북마크에서 재이용한다고 생각할 수 있습니다.
- 리소스를 링크로 연결하여 하나의 애플리케이션을 구성한다는 개념은 REST의 근간을 이루는 사상입니다.
  - 이 개념은 '접속성 (Connectedness)'라고도 불린다.





### REST와 분산 시스템

- RPC와 CORBA, DCOM 등의 분산 오브젝트에서는 함수나 메서드 단위로 서버 쪽의 처리를 호출한다.
  - 네트워크를 통한 함수 호출은 동일 프로세스 내의 함수 호출과는 비교되지 않을 만큼 오버헤드가 심하기 때문에 호출 횟수가 많아질수록 시스템 전체 성능의 저하를 가져온다.
  - 오버헤드로 인한 성능 저하 문제는 이론적으로는 인터페이스의 입도를 크게 하고 호출 횟수를 줄임으로써 회피할 수 있긴 하지만 실제로 구현하기 쉽지 않다.
    - 왜냐하면, RPC와 분산 오브젝트는 서버마다 다른 인터페이스를 가지며, 개별 인터페이스는 프로그램 라이브러리의 인터페이스를 기반으로 개발하는 경우가 많기 때문이다. 
  - 일반적으로 라이브러리에 좋다는 인터페이스는 네트워크로 호출하기에는 지나치게 작은 입도이다.
- 그에 비해, REST에 기초한 웹 서비스에서는 링크를 이용하여 애플리케이션을 실현한다.
  - 리소스는 그 자체로 의미를 가진 하나의 데이터이며, RPC 함수에 의해 주고받는 데이터보다 입도가 크다.
  - 그러므로 링크를 따라 애플리케이션의 상태를 변화시키는 편이 전체적인 성능 저하를 억제할 수 있다.



- 또한, RPC와 분산 시스템에서는 기능을 추가해 버전업 할때마다 메서드가 늘어나거나 메서드의 인수와 반환값이 바뀌어 API 호환성이 상실된다.
  - 그렇기 때문에, 기존의 클라이언트를 모두 동시에 변경해야 된다.
  - 이는 웹과 같은 대규모 시스템에서는 비현실적이다.
- 그에 반해, REST에 기초한 웹에서는 Uniform Interface에 의해 인터페이스가 고정되어 있기 때문에 호환성 문제는 발생하지 않는다.
  - 리소스에 적용할 수 있는 HTTP 메서드는 항상 고정되어 있어, HTTP를 구현한 클라이언트라면 동일하게 접속할 수 있다.
  - 게다가 HTTP에서는 마이너 버전업은 인터페이스의 하위 호환성을 보증하고 있다.





## 6. REST의 의미

- REST란 웹 전체의 아키텍처 스타일이다.
- 웹은 REST라는 분산 네트워크 시스템을 위한 이론이 있었기에 이만큼 성공했다고 말할 수 있다.

- 우리들이 만드는 웹 서비스나 웹 API는 웹을 구성하는 일부분이다.
- 개별 웹 서비스와 웹 API가 RESTful이 되면, 웹은 전체적으로 더욱 좋아진다.
